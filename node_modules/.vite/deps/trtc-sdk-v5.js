import {
  __commonJS
} from "./chunk-LQ2VYIYD.js";

// node_modules/trtc-sdk-v5/trtc.js
var require_trtc = __commonJS({
  "node_modules/trtc-sdk-v5/trtc.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).TRTC = t();
    }(exports, function() {
      function e(e2, t2) {
        return t2.forEach(function(t3) {
          t3 && "string" != typeof t3 && !Array.isArray(t3) && Object.keys(t3).forEach(function(i2) {
            if ("default" !== i2 && !(i2 in e2)) {
              var r2 = Object.getOwnPropertyDescriptor(t3, i2);
              Object.defineProperty(e2, i2, r2.get ? r2 : { enumerable: true, get: function() {
                return t3[i2];
              } });
            }
          });
        }), Object.freeze(e2);
      }
      var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, i = function(e2) {
        try {
          return !!e2();
        } catch (t2) {
          return true;
        }
      }, r = !i(function() {
        var e2 = (function() {
        }).bind();
        return "function" != typeof e2 || e2.hasOwnProperty("prototype");
      }), n = r, o = Function.prototype, s = o.call, a = n && o.bind.bind(s, s), c = n ? a : function(e2) {
        return function() {
          return s.apply(e2, arguments);
        };
      }, l = c, d = l({}.toString), u = l("".slice), h = function(e2) {
        return u(d(e2), 8, -1);
      }, p = i, m = h, _ = Object, f = c("".split), g = p(function() {
        return !_("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return "String" == m(e2) ? f(e2, "") : _(e2);
      } : _, T = function(e2) {
        return null == e2;
      }, E = T, S = TypeError, I = function(e2) {
        if (E(e2))
          throw S("Can't call method on " + e2);
        return e2;
      }, v = g, y = I, A = function(e2) {
        return v(y(e2));
      }, R = function(e2) {
        return e2 && e2.Math == Math && e2;
      }, C = R("object" == typeof globalThis && globalThis) || R("object" == typeof window && window) || R("object" == typeof self && self) || R("object" == typeof t && t) || /* @__PURE__ */ function() {
        return this;
      }() || Function("return this")(), b = {}, k = { get exports() {
        return b;
      }, set exports(e2) {
        b = e2;
      } }, N = C, D = Object.defineProperty, w = function(e2, t2) {
        try {
          D(N, e2, { value: t2, configurable: true, writable: true });
        } catch (i2) {
          N[e2] = t2;
        }
        return t2;
      }, O = w, P = "__core-js_shared__", M = C[P] || O(P, {}), L = M;
      (k.exports = function(e2, t2) {
        return L[e2] || (L[e2] = void 0 !== t2 ? t2 : {});
      })("versions", []).push({ version: "3.30.0", mode: "global", copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.30.0/LICENSE", source: "https://github.com/zloirock/core-js" });
      var x, V, U = I, F = Object, B = function(e2) {
        return F(U(e2));
      }, H = B, j = c({}.hasOwnProperty), G = Object.hasOwn || function(e2, t2) {
        return j(H(e2), t2);
      }, W = c, J = 0, K = Math.random(), z = W(1 .toString), q = function(e2) {
        return "Symbol(" + (void 0 === e2 ? "" : e2) + ")_" + z(++J + K, 36);
      }, Y = "undefined" != typeof navigator && String(navigator.userAgent) || "", Q = C, X = Y, $ = Q.process, Z = Q.Deno, ee = $ && $.versions || Z && Z.version, te = ee && ee.v8;
      te && (V = (x = te.split("."))[0] > 0 && x[0] < 4 ? 1 : +(x[0] + x[1])), !V && X && (!(x = X.match(/Edge\/(\d+)/)) || x[1] >= 74) && (x = X.match(/Chrome\/(\d+)/)) && (V = +x[1]);
      var ie = V, re = ie, ne = i, oe = !!Object.getOwnPropertySymbols && !ne(function() {
        var e2 = Symbol();
        return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && re && re < 41;
      }), se = oe && !Symbol.sham && "symbol" == typeof Symbol.iterator, ae = b, ce = G, le = q, de = oe, ue = se, he = C.Symbol, pe = ae("wks"), me = ue ? he.for || he : he && he.withoutSetter || le, _e = function(e2) {
        return ce(pe, e2) || (pe[e2] = de && ce(he, e2) ? he[e2] : me("Symbol." + e2)), pe[e2];
      }, fe = "object" == typeof document && document.all, ge = { all: fe, IS_HTMLDDA: void 0 === fe && void 0 !== fe }, Te = ge.all, Ee = ge.IS_HTMLDDA ? function(e2) {
        return "function" == typeof e2 || e2 === Te;
      } : function(e2) {
        return "function" == typeof e2;
      }, Se = Ee, Ie = ge.all, ve = ge.IS_HTMLDDA ? function(e2) {
        return "object" == typeof e2 ? null !== e2 : Se(e2) || e2 === Ie;
      } : function(e2) {
        return "object" == typeof e2 ? null !== e2 : Se(e2);
      }, ye = ve, Ae = String, Re = TypeError, Ce = function(e2) {
        if (ye(e2))
          return e2;
        throw Re(Ae(e2) + " is not an object");
      }, be = {}, ke = !i(function() {
        return 7 != Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1];
      }), Ne = ke && i(function() {
        return 42 != Object.defineProperty(function() {
        }, "prototype", { value: 42, writable: false }).prototype;
      }), De = {}, we = ve, Oe = C.document, Pe = we(Oe) && we(Oe.createElement), Me = function(e2) {
        return Pe ? Oe.createElement(e2) : {};
      }, Le = Me, xe = !ke && !i(function() {
        return 7 != Object.defineProperty(Le("div"), "a", { get: function() {
          return 7;
        } }).a;
      }), Ve = r, Ue = Function.prototype.call, Fe = Ve ? Ue.bind(Ue) : function() {
        return Ue.apply(Ue, arguments);
      }, Be = C, He = Ee, je = function(e2, t2) {
        return arguments.length < 2 ? (i2 = Be[e2], He(i2) ? i2 : void 0) : Be[e2] && Be[e2][t2];
        var i2;
      }, Ge = c({}.isPrototypeOf), We = je, Je = Ee, Ke = Ge, ze = Object, qe = se ? function(e2) {
        return "symbol" == typeof e2;
      } : function(e2) {
        var t2 = We("Symbol");
        return Je(t2) && Ke(t2.prototype, ze(e2));
      }, Ye = String, Qe = function(e2) {
        try {
          return Ye(e2);
        } catch (t2) {
          return "Object";
        }
      }, Xe = Ee, $e = Qe, Ze = TypeError, et = function(e2) {
        if (Xe(e2))
          return e2;
        throw Ze($e(e2) + " is not a function");
      }, tt = et, it = T, rt = function(e2, t2) {
        var i2 = e2[t2];
        return it(i2) ? void 0 : tt(i2);
      }, nt = Fe, ot = Ee, st = ve, at = TypeError, ct = Fe, lt = ve, dt = qe, ut = rt, ht = function(e2, t2) {
        var i2, r2;
        if ("string" === t2 && ot(i2 = e2.toString) && !st(r2 = nt(i2, e2)))
          return r2;
        if (ot(i2 = e2.valueOf) && !st(r2 = nt(i2, e2)))
          return r2;
        if ("string" !== t2 && ot(i2 = e2.toString) && !st(r2 = nt(i2, e2)))
          return r2;
        throw at("Can't convert object to primitive value");
      }, pt = TypeError, mt = _e("toPrimitive"), _t = function(e2, t2) {
        if (!lt(e2) || dt(e2))
          return e2;
        var i2, r2 = ut(e2, mt);
        if (r2) {
          if (void 0 === t2 && (t2 = "default"), i2 = ct(r2, e2, t2), !lt(i2) || dt(i2))
            return i2;
          throw pt("Can't convert object to primitive value");
        }
        return void 0 === t2 && (t2 = "number"), ht(e2, t2);
      }, ft = _t, gt = qe, Tt = function(e2) {
        var t2 = ft(e2, "string");
        return gt(t2) ? t2 : t2 + "";
      }, Et = ke, St = xe, It = Ne, vt = Ce, yt = Tt, At = TypeError, Rt = Object.defineProperty, Ct = Object.getOwnPropertyDescriptor, bt = "enumerable", kt = "configurable", Nt = "writable";
      De.f = Et ? It ? function(e2, t2, i2) {
        if (vt(e2), t2 = yt(t2), vt(i2), "function" == typeof e2 && "prototype" === t2 && "value" in i2 && Nt in i2 && !i2[Nt]) {
          var r2 = Ct(e2, t2);
          r2 && r2[Nt] && (e2[t2] = i2.value, i2 = { configurable: kt in i2 ? i2[kt] : r2[kt], enumerable: bt in i2 ? i2[bt] : r2[bt], writable: false });
        }
        return Rt(e2, t2, i2);
      } : Rt : function(e2, t2, i2) {
        if (vt(e2), t2 = yt(t2), vt(i2), St)
          try {
            return Rt(e2, t2, i2);
          } catch (r2) {
          }
        if ("get" in i2 || "set" in i2)
          throw At("Accessors not supported");
        return "value" in i2 && (e2[t2] = i2.value), e2;
      };
      var Dt = Math.ceil, wt = Math.floor, Ot = Math.trunc || function(e2) {
        var t2 = +e2;
        return (t2 > 0 ? wt : Dt)(t2);
      }, Pt = Ot, Mt = function(e2) {
        var t2 = +e2;
        return t2 != t2 || 0 === t2 ? 0 : Pt(t2);
      }, Lt = Mt, xt = Math.max, Vt = Math.min, Ut = function(e2, t2) {
        var i2 = Lt(e2);
        return i2 < 0 ? xt(i2 + t2, 0) : Vt(i2, t2);
      }, Ft = Mt, Bt = Math.min, Ht = function(e2) {
        return e2 > 0 ? Bt(Ft(e2), 9007199254740991) : 0;
      }, jt = Ht, Gt = function(e2) {
        return jt(e2.length);
      }, Wt = A, Jt = Ut, Kt = Gt, zt = function(e2) {
        return function(t2, i2, r2) {
          var n2, o2 = Wt(t2), s2 = Kt(o2), a2 = Jt(r2, s2);
          if (e2 && i2 != i2) {
            for (; s2 > a2; )
              if ((n2 = o2[a2++]) != n2)
                return true;
          } else
            for (; s2 > a2; a2++)
              if ((e2 || a2 in o2) && o2[a2] === i2)
                return e2 || a2 || 0;
          return !e2 && -1;
        };
      }, qt = { includes: zt(true), indexOf: zt(false) }, Yt = {}, Qt = G, Xt = A, $t = qt.indexOf, Zt = Yt, ei = c([].push), ti = function(e2, t2) {
        var i2, r2 = Xt(e2), n2 = 0, o2 = [];
        for (i2 in r2)
          !Qt(Zt, i2) && Qt(r2, i2) && ei(o2, i2);
        for (; t2.length > n2; )
          Qt(r2, i2 = t2[n2++]) && (~$t(o2, i2) || ei(o2, i2));
        return o2;
      }, ii = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ri = ti, ni = ii, oi = Object.keys || function(e2) {
        return ri(e2, ni);
      }, si = ke, ai = Ne, ci = De, li = Ce, di = A, ui = oi;
      be.f = si && !ai ? Object.defineProperties : function(e2, t2) {
        li(e2);
        for (var i2, r2 = di(t2), n2 = ui(t2), o2 = n2.length, s2 = 0; o2 > s2; )
          ci.f(e2, i2 = n2[s2++], r2[i2]);
        return e2;
      };
      var hi, pi = je("document", "documentElement"), mi = q, _i = b("keys"), fi = function(e2) {
        return _i[e2] || (_i[e2] = mi(e2));
      }, gi = Ce, Ti = be, Ei = ii, Si = Yt, Ii = pi, vi = Me, yi = "prototype", Ai = "script", Ri = fi("IE_PROTO"), Ci = function() {
      }, bi = function(e2) {
        return "<" + Ai + ">" + e2 + "</" + Ai + ">";
      }, ki = function(e2) {
        e2.write(bi("")), e2.close();
        var t2 = e2.parentWindow.Object;
        return e2 = null, t2;
      }, Ni = function() {
        try {
          hi = new ActiveXObject("htmlfile");
        } catch (n2) {
        }
        var e2, t2, i2;
        Ni = "undefined" != typeof document ? document.domain && hi ? ki(hi) : (t2 = vi("iframe"), i2 = "java" + Ai + ":", t2.style.display = "none", Ii.appendChild(t2), t2.src = String(i2), (e2 = t2.contentWindow.document).open(), e2.write(bi("document.F=Object")), e2.close(), e2.F) : ki(hi);
        for (var r2 = Ei.length; r2--; )
          delete Ni[yi][Ei[r2]];
        return Ni();
      };
      Si[Ri] = true;
      var Di = Object.create || function(e2, t2) {
        var i2;
        return null !== e2 ? (Ci[yi] = gi(e2), i2 = new Ci(), Ci[yi] = null, i2[Ri] = e2) : i2 = Ni(), void 0 === t2 ? i2 : Ti.f(i2, t2);
      }, wi = _e, Oi = Di, Pi = De.f, Mi = wi("unscopables"), Li = Array.prototype;
      null == Li[Mi] && Pi(Li, Mi, { configurable: true, value: Oi(null) });
      var xi, Vi, Ui, Fi = function(e2) {
        Li[Mi][e2] = true;
      }, Bi = {}, Hi = Ee, ji = C.WeakMap, Gi = Hi(ji) && /native code/.test(String(ji)), Wi = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, Ji = De, Ki = Wi, zi = ke ? function(e2, t2, i2) {
        return Ji.f(e2, t2, Ki(1, i2));
      } : function(e2, t2, i2) {
        return e2[t2] = i2, e2;
      }, qi = Gi, Yi = C, Qi = ve, Xi = zi, $i = G, Zi = M, er = fi, tr = Yt, ir = "Object already initialized", rr = Yi.TypeError, nr = Yi.WeakMap;
      if (qi || Zi.state) {
        var or = Zi.state || (Zi.state = new nr());
        or.get = or.get, or.has = or.has, or.set = or.set, xi = function(e2, t2) {
          if (or.has(e2))
            throw rr(ir);
          return t2.facade = e2, or.set(e2, t2), t2;
        }, Vi = function(e2) {
          return or.get(e2) || {};
        }, Ui = function(e2) {
          return or.has(e2);
        };
      } else {
        var sr = er("state");
        tr[sr] = true, xi = function(e2, t2) {
          if ($i(e2, sr))
            throw rr(ir);
          return t2.facade = e2, Xi(e2, sr, t2), t2;
        }, Vi = function(e2) {
          return $i(e2, sr) ? e2[sr] : {};
        }, Ui = function(e2) {
          return $i(e2, sr);
        };
      }
      var ar = { set: xi, get: Vi, has: Ui, enforce: function(e2) {
        return Ui(e2) ? Vi(e2) : xi(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var i2;
          if (!Qi(t2) || (i2 = Vi(t2)).type !== e2)
            throw rr("Incompatible receiver, " + e2 + " required");
          return i2;
        };
      } }, cr = {}, lr = {}, dr = {}.propertyIsEnumerable, ur = Object.getOwnPropertyDescriptor, hr = ur && !dr.call({ 1: 2 }, 1);
      lr.f = hr ? function(e2) {
        var t2 = ur(this, e2);
        return !!t2 && t2.enumerable;
      } : dr;
      var pr = ke, mr = Fe, _r = lr, fr = Wi, gr = A, Tr = Tt, Er = G, Sr = xe, Ir = Object.getOwnPropertyDescriptor;
      cr.f = pr ? Ir : function(e2, t2) {
        if (e2 = gr(e2), t2 = Tr(t2), Sr)
          try {
            return Ir(e2, t2);
          } catch (i2) {
          }
        if (Er(e2, t2))
          return fr(!mr(_r.f, e2, t2), e2[t2]);
      };
      var vr = {}, yr = { get exports() {
        return vr;
      }, set exports(e2) {
        vr = e2;
      } }, Ar = ke, Rr = G, Cr = Function.prototype, br = Ar && Object.getOwnPropertyDescriptor, kr = Rr(Cr, "name"), Nr = { EXISTS: kr, PROPER: kr && "something" === (function() {
      }).name, CONFIGURABLE: kr && (!Ar || Ar && br(Cr, "name").configurable) }, Dr = Ee, wr = M, Or = c(Function.toString);
      Dr(wr.inspectSource) || (wr.inspectSource = function(e2) {
        return Or(e2);
      });
      var Pr = wr.inspectSource, Mr = c, Lr = i, xr = Ee, Vr = G, Ur = ke, Fr = Nr.CONFIGURABLE, Br = Pr, Hr = ar.enforce, jr = ar.get, Gr = String, Wr = Object.defineProperty, Jr = Mr("".slice), Kr = Mr("".replace), zr = Mr([].join), qr = Ur && !Lr(function() {
        return 8 !== Wr(function() {
        }, "length", { value: 8 }).length;
      }), Yr = String(String).split("String"), Qr = yr.exports = function(e2, t2, i2) {
        "Symbol(" === Jr(Gr(t2), 0, 7) && (t2 = "[" + Kr(Gr(t2), /^Symbol\(([^)]*)\)/, "$1") + "]"), i2 && i2.getter && (t2 = "get " + t2), i2 && i2.setter && (t2 = "set " + t2), (!Vr(e2, "name") || Fr && e2.name !== t2) && (Ur ? Wr(e2, "name", { value: t2, configurable: true }) : e2.name = t2), qr && i2 && Vr(i2, "arity") && e2.length !== i2.arity && Wr(e2, "length", { value: i2.arity });
        try {
          i2 && Vr(i2, "constructor") && i2.constructor ? Ur && Wr(e2, "prototype", { writable: false }) : e2.prototype && (e2.prototype = void 0);
        } catch (n2) {
        }
        var r2 = Hr(e2);
        return Vr(r2, "source") || (r2.source = zr(Yr, "string" == typeof t2 ? t2 : "")), e2;
      };
      Function.prototype.toString = Qr(function() {
        return xr(this) && jr(this).source || Br(this);
      }, "toString");
      var Xr = Ee, $r = De, Zr = vr, en = w, tn = function(e2, t2, i2, r2) {
        r2 || (r2 = {});
        var n2 = r2.enumerable, o2 = void 0 !== r2.name ? r2.name : t2;
        if (Xr(i2) && Zr(i2, o2, r2), r2.global)
          n2 ? e2[t2] = i2 : en(t2, i2);
        else {
          try {
            r2.unsafe ? e2[t2] && (n2 = true) : delete e2[t2];
          } catch (s2) {
          }
          n2 ? e2[t2] = i2 : $r.f(e2, t2, { value: i2, enumerable: false, configurable: !r2.nonConfigurable, writable: !r2.nonWritable });
        }
        return e2;
      }, rn = {}, nn = ti, on = ii.concat("length", "prototype");
      rn.f = Object.getOwnPropertyNames || function(e2) {
        return nn(e2, on);
      };
      var sn = {};
      sn.f = Object.getOwnPropertySymbols;
      var an, cn, ln, dn = je, un = rn, hn = sn, pn = Ce, mn = c([].concat), _n = dn("Reflect", "ownKeys") || function(e2) {
        var t2 = un.f(pn(e2)), i2 = hn.f;
        return i2 ? mn(t2, i2(e2)) : t2;
      }, fn = G, gn = _n, Tn = cr, En = De, Sn = function(e2, t2, i2) {
        for (var r2 = gn(t2), n2 = En.f, o2 = Tn.f, s2 = 0; s2 < r2.length; s2++) {
          var a2 = r2[s2];
          fn(e2, a2) || i2 && fn(i2, a2) || n2(e2, a2, o2(t2, a2));
        }
      }, In = i, vn = Ee, yn = /#|\.prototype\./, An = function(e2, t2) {
        var i2 = Cn[Rn(e2)];
        return i2 == kn || i2 != bn && (vn(t2) ? In(t2) : !!t2);
      }, Rn = An.normalize = function(e2) {
        return String(e2).replace(yn, ".").toLowerCase();
      }, Cn = An.data = {}, bn = An.NATIVE = "N", kn = An.POLYFILL = "P", Nn = An, Dn = C, wn = cr.f, On = zi, Pn = tn, Mn = w, Ln = Sn, xn = Nn, Vn = function(e2, t2) {
        var i2, r2, n2, o2, s2, a2 = e2.target, c2 = e2.global, l2 = e2.stat;
        if (i2 = c2 ? Dn : l2 ? Dn[a2] || Mn(a2, {}) : (Dn[a2] || {}).prototype)
          for (r2 in t2) {
            if (o2 = t2[r2], n2 = e2.dontCallGetSet ? (s2 = wn(i2, r2)) && s2.value : i2[r2], !xn(c2 ? r2 : a2 + (l2 ? "." : "#") + r2, e2.forced) && void 0 !== n2) {
              if (typeof o2 == typeof n2)
                continue;
              Ln(o2, n2);
            }
            (e2.sham || n2 && n2.sham) && On(o2, "sham", true), Pn(i2, r2, o2, e2);
          }
      }, Un = !i(function() {
        function e2() {
        }
        return e2.prototype.constructor = null, Object.getPrototypeOf(new e2()) !== e2.prototype;
      }), Fn = G, Bn = Ee, Hn = B, jn = Un, Gn = fi("IE_PROTO"), Wn = Object, Jn = Wn.prototype, Kn = jn ? Wn.getPrototypeOf : function(e2) {
        var t2 = Hn(e2);
        if (Fn(t2, Gn))
          return t2[Gn];
        var i2 = t2.constructor;
        return Bn(i2) && t2 instanceof i2 ? i2.prototype : t2 instanceof Wn ? Jn : null;
      }, zn = i, qn = Ee, Yn = ve, Qn = Kn, Xn = tn, $n = _e("iterator"), Zn = false;
      [].keys && ("next" in (ln = [].keys()) ? (cn = Qn(Qn(ln))) !== Object.prototype && (an = cn) : Zn = true);
      var eo = !Yn(an) || zn(function() {
        var e2 = {};
        return an[$n].call(e2) !== e2;
      });
      eo && (an = {}), qn(an[$n]) || Xn(an, $n, function() {
        return this;
      });
      var to = { IteratorPrototype: an, BUGGY_SAFARI_ITERATORS: Zn }, io = De.f, ro = G, no = _e("toStringTag"), oo = function(e2, t2, i2) {
        e2 && !i2 && (e2 = e2.prototype), e2 && !ro(e2, no) && io(e2, no, { configurable: true, value: t2 });
      }, so = to.IteratorPrototype, ao = Di, co = Wi, lo = oo, uo = Bi, ho = function() {
        return this;
      }, po = function(e2, t2, i2, r2) {
        var n2 = t2 + " Iterator";
        return e2.prototype = ao(so, { next: co(+!r2, i2) }), lo(e2, n2, false), uo[n2] = ho, e2;
      }, mo = c, _o = et, fo = Ee, go = String, To = TypeError, Eo = function(e2, t2, i2) {
        try {
          return mo(_o(Object.getOwnPropertyDescriptor(e2, t2)[i2]));
        } catch (r2) {
        }
      }, So = Ce, Io = function(e2) {
        if ("object" == typeof e2 || fo(e2))
          return e2;
        throw To("Can't set " + go(e2) + " as a prototype");
      }, vo = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var e2, t2 = false, i2 = {};
        try {
          (e2 = Eo(Object.prototype, "__proto__", "set"))(i2, []), t2 = i2 instanceof Array;
        } catch (r2) {
        }
        return function(i3, r2) {
          return So(i3), Io(r2), t2 ? e2(i3, r2) : i3.__proto__ = r2, i3;
        };
      }() : void 0), yo = Vn, Ao = Fe, Ro = Ee, Co = po, bo = Kn, ko = vo, No = oo, Do = zi, wo = tn, Oo = Bi, Po = Nr.PROPER, Mo = Nr.CONFIGURABLE, Lo = to.IteratorPrototype, xo = to.BUGGY_SAFARI_ITERATORS, Vo = _e("iterator"), Uo = "keys", Fo = "values", Bo = "entries", Ho = function() {
        return this;
      }, jo = function(e2, t2, i2, r2, n2, o2, s2) {
        Co(i2, t2, r2);
        var a2, c2, l2, d2 = function(e3) {
          if (e3 === n2 && _2)
            return _2;
          if (!xo && e3 in p2)
            return p2[e3];
          switch (e3) {
            case Uo:
            case Fo:
            case Bo:
              return function() {
                return new i2(this, e3);
              };
          }
          return function() {
            return new i2(this);
          };
        }, u2 = t2 + " Iterator", h2 = false, p2 = e2.prototype, m2 = p2[Vo] || p2["@@iterator"] || n2 && p2[n2], _2 = !xo && m2 || d2(n2), f2 = "Array" == t2 && p2.entries || m2;
        if (f2 && (a2 = bo(f2.call(new e2()))) !== Object.prototype && a2.next && (bo(a2) !== Lo && (ko ? ko(a2, Lo) : Ro(a2[Vo]) || wo(a2, Vo, Ho)), No(a2, u2, true)), Po && n2 == Fo && m2 && m2.name !== Fo && (Mo ? Do(p2, "name", Fo) : (h2 = true, _2 = function() {
          return Ao(m2, this);
        })), n2)
          if (c2 = { values: d2(Fo), keys: o2 ? _2 : d2(Uo), entries: d2(Bo) }, s2)
            for (l2 in c2)
              (xo || h2 || !(l2 in p2)) && wo(p2, l2, c2[l2]);
          else
            yo({ target: t2, proto: true, forced: xo || h2 }, c2);
        return p2[Vo] !== _2 && wo(p2, Vo, _2, { name: n2 }), Oo[t2] = _2, c2;
      }, Go = function(e2, t2) {
        return { value: e2, done: t2 };
      }, Wo = A, Jo = Fi, Ko = Bi, zo = ar, qo = De.f, Yo = jo, Qo = Go, Xo = ke, $o = "Array Iterator", Zo = zo.set, es = zo.getterFor($o), ts = Yo(Array, "Array", function(e2, t2) {
        Zo(this, { type: $o, target: Wo(e2), index: 0, kind: t2 });
      }, function() {
        var e2 = es(this), t2 = e2.target, i2 = e2.kind, r2 = e2.index++;
        return !t2 || r2 >= t2.length ? (e2.target = void 0, Qo(void 0, true)) : Qo("keys" == i2 ? r2 : "values" == i2 ? t2[r2] : [r2, t2[r2]], false);
      }, "values"), is = Ko.Arguments = Ko.Array;
      if (Jo("keys"), Jo("values"), Jo("entries"), Xo && "values" !== is.name)
        try {
          qo(is, "name", { value: "values" });
        } catch (EF) {
        }
      var rs = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, ns = Me("span").classList, os = ns && ns.constructor && ns.constructor.prototype, ss = os === Object.prototype ? void 0 : os, as = C, cs = rs, ls = ss, ds = ts, us = zi, hs = _e, ps = hs("iterator"), ms = hs("toStringTag"), _s = ds.values, fs = function(e2, t2) {
        if (e2) {
          if (e2[ps] !== _s)
            try {
              us(e2, ps, _s);
            } catch (EF) {
              e2[ps] = _s;
            }
          if (e2[ms] || us(e2, ms, t2), cs[t2]) {
            for (var i2 in ds)
              if (e2[i2] !== ds[i2])
                try {
                  us(e2, i2, ds[i2]);
                } catch (EF) {
                  e2[i2] = ds[i2];
                }
          }
        }
      };
      for (var gs in cs)
        fs(as[gs] && as[gs].prototype, gs);
      fs(ls, "DOMTokenList");
      var Ts = "undefined" != typeof process && "process" == h(process), Es = vr, Ss = De, Is = function(e2, t2, i2) {
        return i2.get && Es(i2.get, t2, { getter: true }), i2.set && Es(i2.set, t2, { setter: true }), Ss.f(e2, t2, i2);
      }, vs = je, ys = Is, As = ke, Rs = _e("species"), Cs = function(e2) {
        var t2 = vs(e2);
        As && t2 && !t2[Rs] && ys(t2, Rs, { configurable: true, get: function() {
          return this;
        } });
      }, bs = Ge, ks = TypeError, Ns = function(e2, t2) {
        if (bs(t2, e2))
          return e2;
        throw ks("Incorrect invocation");
      }, Ds = {};
      Ds[_e("toStringTag")] = "z";
      var ws = "[object z]" === String(Ds), Os = Ee, Ps = h, Ms = _e("toStringTag"), Ls = Object, xs = "Arguments" == Ps(/* @__PURE__ */ function() {
        return arguments;
      }()), Vs = ws ? Ps : function(e2) {
        var t2, i2, r2;
        return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = function(e3, t3) {
          try {
            return e3[t3];
          } catch (EF) {
          }
        }(t2 = Ls(e2), Ms)) ? i2 : xs ? Ps(t2) : "Object" == (r2 = Ps(t2)) && Os(t2.callee) ? "Arguments" : r2;
      }, Us = c, Fs = i, Bs = Ee, Hs = Vs, js = Pr, Gs = function() {
      }, Ws = [], Js = je("Reflect", "construct"), Ks = /^\s*(?:class|function)\b/, zs = Us(Ks.exec), qs = !Ks.exec(Gs), Ys = function(e2) {
        if (!Bs(e2))
          return false;
        try {
          return Js(Gs, Ws, e2), true;
        } catch (EF) {
          return false;
        }
      }, Qs = function(e2) {
        if (!Bs(e2))
          return false;
        switch (Hs(e2)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return false;
        }
        try {
          return qs || !!zs(Ks, js(e2));
        } catch (EF) {
          return true;
        }
      };
      Qs.sham = true;
      var Xs, $s, Zs, ea, ta = !Js || Fs(function() {
        var e2;
        return Ys(Ys.call) || !Ys(Object) || !Ys(function() {
          e2 = true;
        }) || e2;
      }) ? Qs : Ys, ia = ta, ra = Qe, na = TypeError, oa = function(e2) {
        if (ia(e2))
          return e2;
        throw na(ra(e2) + " is not a constructor");
      }, sa = Ce, aa = oa, ca = T, la = _e("species"), da = function(e2, t2) {
        var i2, r2 = sa(e2).constructor;
        return void 0 === r2 || ca(i2 = sa(r2)[la]) ? t2 : aa(i2);
      }, ua = r, ha = Function.prototype, pa = ha.apply, ma = ha.call, _a = "object" == typeof Reflect && Reflect.apply || (ua ? ma.bind(pa) : function() {
        return ma.apply(pa, arguments);
      }), fa = h, ga = c, Ta = function(e2) {
        if ("Function" === fa(e2))
          return ga(e2);
      }, Ea = et, Sa = r, Ia = Ta(Ta.bind), va = function(e2, t2) {
        return Ea(e2), void 0 === t2 ? e2 : Sa ? Ia(e2, t2) : function() {
          return e2.apply(t2, arguments);
        };
      }, ya = c([].slice), Aa = TypeError, Ra = function(e2, t2) {
        if (e2 < t2)
          throw Aa("Not enough arguments");
        return e2;
      }, Ca = /(?:ipad|iphone|ipod).*applewebkit/i.test(Y), ba = C, ka = _a, Na = va, Da = Ee, wa = G, Oa = i, Pa = pi, Ma = ya, La = Me, xa = Ra, Va = Ca, Ua = Ts, Fa = ba.setImmediate, Ba = ba.clearImmediate, Ha = ba.process, ja = ba.Dispatch, Ga = ba.Function, Wa = ba.MessageChannel, Ja = ba.String, Ka = 0, za = {}, qa = "onreadystatechange";
      Oa(function() {
        Xs = ba.location;
      });
      var Ya = function(e2) {
        if (wa(za, e2)) {
          var t2 = za[e2];
          delete za[e2], t2();
        }
      }, Qa = function(e2) {
        return function() {
          Ya(e2);
        };
      }, Xa = function(e2) {
        Ya(e2.data);
      }, $a = function(e2) {
        ba.postMessage(Ja(e2), Xs.protocol + "//" + Xs.host);
      };
      Fa && Ba || (Fa = function(e2) {
        xa(arguments.length, 1);
        var t2 = Da(e2) ? e2 : Ga(e2), i2 = Ma(arguments, 1);
        return za[++Ka] = function() {
          ka(t2, void 0, i2);
        }, $s(Ka), Ka;
      }, Ba = function(e2) {
        delete za[e2];
      }, Ua ? $s = function(e2) {
        Ha.nextTick(Qa(e2));
      } : ja && ja.now ? $s = function(e2) {
        ja.now(Qa(e2));
      } : Wa && !Va ? (ea = (Zs = new Wa()).port2, Zs.port1.onmessage = Xa, $s = Na(ea.postMessage, ea)) : ba.addEventListener && Da(ba.postMessage) && !ba.importScripts && Xs && "file:" !== Xs.protocol && !Oa($a) ? ($s = $a, ba.addEventListener("message", Xa, false)) : $s = qa in La("script") ? function(e2) {
        Pa.appendChild(La("script"))[qa] = function() {
          Pa.removeChild(this), Ya(e2);
        };
      } : function(e2) {
        setTimeout(Qa(e2), 0);
      });
      var Za = { set: Fa, clear: Ba }, ec = function() {
        this.head = null, this.tail = null;
      };
      ec.prototype = { add: function(e2) {
        var t2 = { item: e2, next: null }, i2 = this.tail;
        i2 ? i2.next = t2 : this.head = t2, this.tail = t2;
      }, get: function() {
        var e2 = this.head;
        if (e2)
          return null === (this.head = e2.next) && (this.tail = null), e2.item;
      } };
      var tc, ic, rc, nc, oc, sc = ec, ac = /ipad|iphone|ipod/i.test(Y) && "undefined" != typeof Pebble, cc = /web0s(?!.*chrome)/i.test(Y), lc = C, dc = va, uc = cr.f, hc = Za.set, pc = sc, mc = Ca, _c = ac, fc = cc, gc = Ts, Tc = lc.MutationObserver || lc.WebKitMutationObserver, Ec = lc.document, Sc = lc.process, Ic = lc.Promise, vc = uc(lc, "queueMicrotask"), yc = vc && vc.value;
      if (!yc) {
        var Ac = new pc(), Rc = function() {
          var e2, t2;
          for (gc && (e2 = Sc.domain) && e2.exit(); t2 = Ac.get(); )
            try {
              t2();
            } catch (EF) {
              throw Ac.head && tc(), EF;
            }
          e2 && e2.enter();
        };
        mc || gc || fc || !Tc || !Ec ? !_c && Ic && Ic.resolve ? ((nc = Ic.resolve(void 0)).constructor = Ic, oc = dc(nc.then, nc), tc = function() {
          oc(Rc);
        }) : gc ? tc = function() {
          Sc.nextTick(Rc);
        } : (hc = dc(hc, lc), tc = function() {
          hc(Rc);
        }) : (ic = true, rc = Ec.createTextNode(""), new Tc(Rc).observe(rc, { characterData: true }), tc = function() {
          rc.data = ic = !ic;
        }), yc = function(e2) {
          Ac.head || tc(), Ac.add(e2);
        };
      }
      var Cc = yc, bc = function(e2) {
        try {
          return { error: false, value: e2() };
        } catch (EF) {
          return { error: true, value: EF };
        }
      }, kc = C.Promise, Nc = "object" == typeof Deno && Deno && "object" == typeof Deno.version, Dc = !Nc && !Ts && "object" == typeof window && "object" == typeof document, wc = C, Oc = kc, Pc = Ee, Mc = Nn, Lc = Pr, xc = _e, Vc = Dc, Uc = Nc, Fc = ie;
      Oc && Oc.prototype;
      var Bc = xc("species"), Hc = false, jc = Pc(wc.PromiseRejectionEvent), Gc = Mc("Promise", function() {
        var e2 = Lc(Oc), t2 = e2 !== String(Oc);
        if (!t2 && 66 === Fc)
          return true;
        if (!Fc || Fc < 51 || !/native code/.test(e2)) {
          var i2 = new Oc(function(e3) {
            e3(1);
          }), r2 = function(e3) {
            e3(function() {
            }, function() {
            });
          };
          if ((i2.constructor = {})[Bc] = r2, !(Hc = i2.then(function() {
          }) instanceof r2))
            return true;
        }
        return !t2 && (Vc || Uc) && !jc;
      }), Wc = { CONSTRUCTOR: Gc, REJECTION_EVENT: jc, SUBCLASSING: Hc }, Jc = {}, Kc = et, zc = TypeError, qc = function(e2) {
        var t2, i2;
        this.promise = new e2(function(e3, r2) {
          if (void 0 !== t2 || void 0 !== i2)
            throw zc("Bad Promise constructor");
          t2 = e3, i2 = r2;
        }), this.resolve = Kc(t2), this.reject = Kc(i2);
      };
      Jc.f = function(e2) {
        return new qc(e2);
      };
      var Yc, Qc, Xc, $c = Vn, Zc = Ts, el = C, tl = Fe, il = tn, rl = vo, nl = oo, ol = Cs, sl = et, al = Ee, cl = ve, ll = Ns, dl = da, ul = Za.set, hl = Cc, pl = function(e2, t2) {
        try {
          1 == arguments.length ? console.error(e2) : console.error(e2, t2);
        } catch (EF) {
        }
      }, ml = bc, _l = sc, fl = ar, gl = kc, Tl = Jc, El = "Promise", Sl = Wc.CONSTRUCTOR, Il = Wc.REJECTION_EVENT, vl = Wc.SUBCLASSING, yl = fl.getterFor(El), Al = fl.set, Rl = gl && gl.prototype, Cl = gl, bl = Rl, kl = el.TypeError, Nl = el.document, Dl = el.process, wl = Tl.f, Ol = wl, Pl = !!(Nl && Nl.createEvent && el.dispatchEvent), Ml = "unhandledrejection", Ll = function(e2) {
        var t2;
        return !(!cl(e2) || !al(t2 = e2.then)) && t2;
      }, xl = function(e2, t2) {
        var i2, r2, n2, o2 = t2.value, s2 = 1 == t2.state, a2 = s2 ? e2.ok : e2.fail, c2 = e2.resolve, l2 = e2.reject, d2 = e2.domain;
        try {
          a2 ? (s2 || (2 === t2.rejection && Hl(t2), t2.rejection = 1), true === a2 ? i2 = o2 : (d2 && d2.enter(), i2 = a2(o2), d2 && (d2.exit(), n2 = true)), i2 === e2.promise ? l2(kl("Promise-chain cycle")) : (r2 = Ll(i2)) ? tl(r2, i2, c2, l2) : c2(i2)) : l2(o2);
        } catch (EF) {
          d2 && !n2 && d2.exit(), l2(EF);
        }
      }, Vl = function(e2, t2) {
        e2.notified || (e2.notified = true, hl(function() {
          for (var i2, r2 = e2.reactions; i2 = r2.get(); )
            xl(i2, e2);
          e2.notified = false, t2 && !e2.rejection && Fl(e2);
        }));
      }, Ul = function(e2, t2, i2) {
        var r2, n2;
        Pl ? ((r2 = Nl.createEvent("Event")).promise = t2, r2.reason = i2, r2.initEvent(e2, false, true), el.dispatchEvent(r2)) : r2 = { promise: t2, reason: i2 }, !Il && (n2 = el["on" + e2]) ? n2(r2) : e2 === Ml && pl("Unhandled promise rejection", i2);
      }, Fl = function(e2) {
        tl(ul, el, function() {
          var t2, i2 = e2.facade, r2 = e2.value;
          if (Bl(e2) && (t2 = ml(function() {
            Zc ? Dl.emit("unhandledRejection", r2, i2) : Ul(Ml, i2, r2);
          }), e2.rejection = Zc || Bl(e2) ? 2 : 1, t2.error))
            throw t2.value;
        });
      }, Bl = function(e2) {
        return 1 !== e2.rejection && !e2.parent;
      }, Hl = function(e2) {
        tl(ul, el, function() {
          var t2 = e2.facade;
          Zc ? Dl.emit("rejectionHandled", t2) : Ul("rejectionhandled", t2, e2.value);
        });
      }, jl = function(e2, t2, i2) {
        return function(r2) {
          e2(t2, r2, i2);
        };
      }, Gl = function(e2, t2, i2) {
        e2.done || (e2.done = true, i2 && (e2 = i2), e2.value = t2, e2.state = 2, Vl(e2, true));
      }, Wl = function(e2, t2, i2) {
        if (!e2.done) {
          e2.done = true, i2 && (e2 = i2);
          try {
            if (e2.facade === t2)
              throw kl("Promise can't be resolved itself");
            var r2 = Ll(t2);
            r2 ? hl(function() {
              var i3 = { done: false };
              try {
                tl(r2, t2, jl(Wl, i3, e2), jl(Gl, i3, e2));
              } catch (EF) {
                Gl(i3, EF, e2);
              }
            }) : (e2.value = t2, e2.state = 1, Vl(e2, false));
          } catch (EF) {
            Gl({ done: false }, EF, e2);
          }
        }
      };
      if (Sl && (bl = (Cl = function(e2) {
        ll(this, bl), sl(e2), tl(Yc, this);
        var t2 = yl(this);
        try {
          e2(jl(Wl, t2), jl(Gl, t2));
        } catch (EF) {
          Gl(t2, EF);
        }
      }).prototype, (Yc = function(e2) {
        Al(this, { type: El, done: false, notified: false, parent: false, reactions: new _l(), rejection: false, state: 0, value: void 0 });
      }).prototype = il(bl, "then", function(e2, t2) {
        var i2 = yl(this), r2 = wl(dl(this, Cl));
        return i2.parent = true, r2.ok = !al(e2) || e2, r2.fail = al(t2) && t2, r2.domain = Zc ? Dl.domain : void 0, 0 == i2.state ? i2.reactions.add(r2) : hl(function() {
          xl(r2, i2);
        }), r2.promise;
      }), Qc = function() {
        var e2 = new Yc(), t2 = yl(e2);
        this.promise = e2, this.resolve = jl(Wl, t2), this.reject = jl(Gl, t2);
      }, Tl.f = wl = function(e2) {
        return e2 === Cl || void 0 === e2 ? new Qc(e2) : Ol(e2);
      }, al(gl) && Rl !== Object.prototype)) {
        Xc = Rl.then, vl || il(Rl, "then", function(e2, t2) {
          var i2 = this;
          return new Cl(function(e3, t3) {
            tl(Xc, i2, e3, t3);
          }).then(e2, t2);
        }, { unsafe: true });
        try {
          delete Rl.constructor;
        } catch (EF) {
        }
        rl && rl(Rl, bl);
      }
      $c({ global: true, constructor: true, wrap: true, forced: Sl }, { Promise: Cl }), nl(Cl, El, false), ol(El);
      var Jl = Bi, Kl = _e("iterator"), zl = Array.prototype, ql = function(e2) {
        return void 0 !== e2 && (Jl.Array === e2 || zl[Kl] === e2);
      }, Yl = Vs, Ql = rt, Xl = T, $l = Bi, Zl = _e("iterator"), ed = function(e2) {
        if (!Xl(e2))
          return Ql(e2, Zl) || Ql(e2, "@@iterator") || $l[Yl(e2)];
      }, td = Fe, id = et, rd = Ce, nd = Qe, od = ed, sd = TypeError, ad = function(e2, t2) {
        var i2 = arguments.length < 2 ? od(e2) : t2;
        if (id(i2))
          return rd(td(i2, e2));
        throw sd(nd(e2) + " is not iterable");
      }, cd = Fe, ld = Ce, dd = rt, ud = function(e2, t2, i2) {
        var r2, n2;
        ld(e2);
        try {
          if (!(r2 = dd(e2, "return"))) {
            if ("throw" === t2)
              throw i2;
            return i2;
          }
          r2 = cd(r2, e2);
        } catch (EF) {
          n2 = true, r2 = EF;
        }
        if ("throw" === t2)
          throw i2;
        if (n2)
          throw r2;
        return ld(r2), i2;
      }, hd = va, pd = Fe, md = Ce, _d = Qe, fd = ql, gd = Gt, Td = Ge, Ed = ad, Sd = ed, Id = ud, vd = TypeError, yd = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, Ad = yd.prototype, Rd = function(e2, t2, i2) {
        var r2, n2, o2, s2, a2, c2, l2, d2 = i2 && i2.that, u2 = !(!i2 || !i2.AS_ENTRIES), h2 = !(!i2 || !i2.IS_RECORD), p2 = !(!i2 || !i2.IS_ITERATOR), m2 = !(!i2 || !i2.INTERRUPTED), _2 = hd(t2, d2), f2 = function(e3) {
          return r2 && Id(r2, "normal", e3), new yd(true, e3);
        }, g2 = function(e3) {
          return u2 ? (md(e3), m2 ? _2(e3[0], e3[1], f2) : _2(e3[0], e3[1])) : m2 ? _2(e3, f2) : _2(e3);
        };
        if (h2)
          r2 = e2.iterator;
        else if (p2)
          r2 = e2;
        else {
          if (!(n2 = Sd(e2)))
            throw vd(_d(e2) + " is not iterable");
          if (fd(n2)) {
            for (o2 = 0, s2 = gd(e2); s2 > o2; o2++)
              if ((a2 = g2(e2[o2])) && Td(Ad, a2))
                return a2;
            return new yd(false);
          }
          r2 = Ed(e2, n2);
        }
        for (c2 = h2 ? e2.next : r2.next; !(l2 = pd(c2, r2)).done; ) {
          try {
            a2 = g2(l2.value);
          } catch (EF) {
            Id(r2, "throw", EF);
          }
          if ("object" == typeof a2 && a2 && Td(Ad, a2))
            return a2;
        }
        return new yd(false);
      }, Cd = _e("iterator"), bd = false;
      try {
        var kd = 0, Nd = { next: function() {
          return { done: !!kd++ };
        }, return: function() {
          bd = true;
        } };
        Nd[Cd] = function() {
          return this;
        }, Array.from(Nd, function() {
          throw 2;
        });
      } catch (EF) {
      }
      var Dd = function(e2, t2) {
        if (!t2 && !bd)
          return false;
        var i2 = false;
        try {
          var r2 = {};
          r2[Cd] = function() {
            return { next: function() {
              return { done: i2 = true };
            } };
          }, e2(r2);
        } catch (EF) {
        }
        return i2;
      }, wd = kc, Od = Wc.CONSTRUCTOR || !Dd(function(e2) {
        wd.all(e2).then(void 0, function() {
        });
      }), Pd = Fe, Md = et, Ld = Jc, xd = bc, Vd = Rd;
      Vn({ target: "Promise", stat: true, forced: Od }, { all: function(e2) {
        var t2 = this, i2 = Ld.f(t2), r2 = i2.resolve, n2 = i2.reject, o2 = xd(function() {
          var i3 = Md(t2.resolve), o3 = [], s2 = 0, a2 = 1;
          Vd(e2, function(e3) {
            var c2 = s2++, l2 = false;
            a2++, Pd(i3, t2, e3).then(function(e4) {
              l2 || (l2 = true, o3[c2] = e4, --a2 || r2(o3));
            }, n2);
          }), --a2 || r2(o3);
        });
        return o2.error && n2(o2.value), i2.promise;
      } });
      var Ud = Vn, Fd = Wc.CONSTRUCTOR, Bd = kc, Hd = je, jd = Ee, Gd = tn, Wd = Bd && Bd.prototype;
      if (Ud({ target: "Promise", proto: true, forced: Fd, real: true }, { catch: function(e2) {
        return this.then(void 0, e2);
      } }), jd(Bd)) {
        var Jd = Hd("Promise").prototype.catch;
        Wd.catch !== Jd && Gd(Wd, "catch", Jd, { unsafe: true });
      }
      var Kd = Fe, zd = et, qd = Jc, Yd = bc, Qd = Rd;
      Vn({ target: "Promise", stat: true, forced: Od }, { race: function(e2) {
        var t2 = this, i2 = qd.f(t2), r2 = i2.reject, n2 = Yd(function() {
          var n3 = zd(t2.resolve);
          Qd(e2, function(e3) {
            Kd(n3, t2, e3).then(i2.resolve, r2);
          });
        });
        return n2.error && r2(n2.value), i2.promise;
      } });
      var Xd = Fe, $d = Jc;
      Vn({ target: "Promise", stat: true, forced: Wc.CONSTRUCTOR }, { reject: function(e2) {
        var t2 = $d.f(this);
        return Xd(t2.reject, void 0, e2), t2.promise;
      } });
      var Zd = Ce, eu = ve, tu = Jc, iu = function(e2, t2) {
        if (Zd(e2), eu(t2) && t2.constructor === e2)
          return t2;
        var i2 = tu.f(e2);
        return (0, i2.resolve)(t2), i2.promise;
      }, ru = Vn, nu = Wc.CONSTRUCTOR, ou = iu;
      je("Promise"), ru({ target: "Promise", stat: true, forced: nu }, { resolve: function(e2) {
        return ou(this, e2);
      } });
      var su = Ee, au = ve, cu = vo, lu = function(e2, t2, i2) {
        var r2, n2;
        return cu && su(r2 = t2.constructor) && r2 !== i2 && au(n2 = r2.prototype) && n2 !== i2.prototype && cu(e2, n2), e2;
      }, du = ve, uu = h, hu = _e("match"), pu = function(e2) {
        var t2;
        return du(e2) && (void 0 !== (t2 = e2[hu]) ? !!t2 : "RegExp" == uu(e2));
      }, mu = Vs, _u = String, fu = function(e2) {
        if ("Symbol" === mu(e2))
          throw TypeError("Cannot convert a Symbol value to a string");
        return _u(e2);
      }, gu = Ce, Tu = function() {
        var e2 = gu(this), t2 = "";
        return e2.hasIndices && (t2 += "d"), e2.global && (t2 += "g"), e2.ignoreCase && (t2 += "i"), e2.multiline && (t2 += "m"), e2.dotAll && (t2 += "s"), e2.unicode && (t2 += "u"), e2.unicodeSets && (t2 += "v"), e2.sticky && (t2 += "y"), t2;
      }, Eu = Fe, Su = G, Iu = Ge, vu = Tu, yu = RegExp.prototype, Au = function(e2) {
        var t2 = e2.flags;
        return void 0 !== t2 || "flags" in yu || Su(e2, "flags") || !Iu(yu, e2) ? t2 : Eu(vu, e2);
      }, Ru = i, Cu = C.RegExp, bu = Ru(function() {
        var e2 = Cu("a", "y");
        return e2.lastIndex = 2, null != e2.exec("abcd");
      }), ku = bu || Ru(function() {
        return !Cu("a", "y").sticky;
      }), Nu = bu || Ru(function() {
        var e2 = Cu("^r", "gy");
        return e2.lastIndex = 2, null != e2.exec("str");
      }), Du = { BROKEN_CARET: Nu, MISSED_STICKY: ku, UNSUPPORTED_Y: bu }, wu = De.f, Ou = i, Pu = C.RegExp, Mu = Ou(function() {
        var e2 = Pu(".", "s");
        return !(e2.dotAll && e2.exec("\n") && "s" === e2.flags);
      }), Lu = i, xu = C.RegExp, Vu = Lu(function() {
        var e2 = xu("(?<a>b)", "g");
        return "b" !== e2.exec("b").groups.a || "bc" !== "b".replace(e2, "$<a>c");
      }), Uu = ke, Fu = C, Bu = c, Hu = Nn, ju = lu, Gu = zi, Wu = rn.f, Ju = Ge, Ku = pu, zu = fu, qu = Au, Yu = Du, Qu = function(e2, t2, i2) {
        i2 in e2 || wu(e2, i2, { configurable: true, get: function() {
          return t2[i2];
        }, set: function(e3) {
          t2[i2] = e3;
        } });
      }, Xu = tn, $u = i, Zu = G, eh = ar.enforce, th = Cs, ih = Mu, rh = Vu, nh = _e("match"), oh = Fu.RegExp, sh = oh.prototype, ah = Fu.SyntaxError, ch = Bu(sh.exec), lh = Bu("".charAt), dh = Bu("".replace), uh = Bu("".indexOf), hh = Bu("".slice), ph = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/, mh = /a/g, _h = /a/g, fh = new oh(mh) !== mh, gh = Yu.MISSED_STICKY, Th = Yu.UNSUPPORTED_Y, Eh = Uu && (!fh || gh || ih || rh || $u(function() {
        return _h[nh] = false, oh(mh) != mh || oh(_h) == _h || "/a/i" != oh(mh, "i");
      }));
      if (Hu("RegExp", Eh)) {
        for (var Sh = function(e2, t2) {
          var i2, r2, n2, o2, s2, a2, c2 = Ju(sh, this), l2 = Ku(e2), d2 = void 0 === t2, u2 = [], h2 = e2;
          if (!c2 && l2 && d2 && e2.constructor === Sh)
            return e2;
          if ((l2 || Ju(sh, e2)) && (e2 = e2.source, d2 && (t2 = qu(h2))), e2 = void 0 === e2 ? "" : zu(e2), t2 = void 0 === t2 ? "" : zu(t2), h2 = e2, ih && "dotAll" in mh && (r2 = !!t2 && uh(t2, "s") > -1) && (t2 = dh(t2, /s/g, "")), i2 = t2, gh && "sticky" in mh && (n2 = !!t2 && uh(t2, "y") > -1) && Th && (t2 = dh(t2, /y/g, "")), rh && (o2 = function(e3) {
            for (var t3, i3 = e3.length, r3 = 0, n3 = "", o3 = [], s3 = {}, a3 = false, c3 = false, l3 = 0, d3 = ""; r3 <= i3; r3++) {
              if ("\\" === (t3 = lh(e3, r3)))
                t3 += lh(e3, ++r3);
              else if ("]" === t3)
                a3 = false;
              else if (!a3)
                switch (true) {
                  case "[" === t3:
                    a3 = true;
                    break;
                  case "(" === t3:
                    ch(ph, hh(e3, r3 + 1)) && (r3 += 2, c3 = true), n3 += t3, l3++;
                    continue;
                  case (">" === t3 && c3):
                    if ("" === d3 || Zu(s3, d3))
                      throw new ah("Invalid capture group name");
                    s3[d3] = true, o3[o3.length] = [d3, l3], c3 = false, d3 = "";
                    continue;
                }
              c3 ? d3 += t3 : n3 += t3;
            }
            return [n3, o3];
          }(e2), e2 = o2[0], u2 = o2[1]), s2 = ju(oh(e2, t2), c2 ? this : sh, Sh), (r2 || n2 || u2.length) && (a2 = eh(s2), r2 && (a2.dotAll = true, a2.raw = Sh(function(e3) {
            for (var t3, i3 = e3.length, r3 = 0, n3 = "", o3 = false; r3 <= i3; r3++)
              "\\" !== (t3 = lh(e3, r3)) ? o3 || "." !== t3 ? ("[" === t3 ? o3 = true : "]" === t3 && (o3 = false), n3 += t3) : n3 += "[\\s\\S]" : n3 += t3 + lh(e3, ++r3);
            return n3;
          }(e2), i2)), n2 && (a2.sticky = true), u2.length && (a2.groups = u2)), e2 !== h2)
            try {
              Gu(s2, "source", "" === h2 ? "(?:)" : h2);
            } catch (EF) {
            }
          return s2;
        }, Ih = Wu(oh), vh = 0; Ih.length > vh; )
          Qu(Sh, oh, Ih[vh++]);
        sh.constructor = Sh, Sh.prototype = sh, Xu(Fu, "RegExp", Sh, { constructor: true });
      }
      th("RegExp");
      var yh = Fe, Ah = c, Rh = fu, Ch = Tu, bh = Du, kh = Di, Nh = ar.get, Dh = Mu, wh = Vu, Oh = b("native-string-replace", String.prototype.replace), Ph = RegExp.prototype.exec, Mh = Ph, Lh = Ah("".charAt), xh = Ah("".indexOf), Vh = Ah("".replace), Uh = Ah("".slice), Fh = function() {
        var e2 = /a/, t2 = /b*/g;
        return yh(Ph, e2, "a"), yh(Ph, t2, "a"), 0 !== e2.lastIndex || 0 !== t2.lastIndex;
      }(), Bh = bh.BROKEN_CARET, Hh = void 0 !== /()??/.exec("")[1];
      (Fh || Hh || Bh || Dh || wh) && (Mh = function(e2) {
        var t2, i2, r2, n2, o2, s2, a2, c2 = this, l2 = Nh(c2), d2 = Rh(e2), u2 = l2.raw;
        if (u2)
          return u2.lastIndex = c2.lastIndex, t2 = yh(Mh, u2, d2), c2.lastIndex = u2.lastIndex, t2;
        var h2 = l2.groups, p2 = Bh && c2.sticky, m2 = yh(Ch, c2), _2 = c2.source, f2 = 0, g2 = d2;
        if (p2 && (m2 = Vh(m2, "y", ""), -1 === xh(m2, "g") && (m2 += "g"), g2 = Uh(d2, c2.lastIndex), c2.lastIndex > 0 && (!c2.multiline || c2.multiline && "\n" !== Lh(d2, c2.lastIndex - 1)) && (_2 = "(?: " + _2 + ")", g2 = " " + g2, f2++), i2 = new RegExp("^(?:" + _2 + ")", m2)), Hh && (i2 = new RegExp("^" + _2 + "$(?!\\s)", m2)), Fh && (r2 = c2.lastIndex), n2 = yh(Ph, p2 ? i2 : c2, g2), p2 ? n2 ? (n2.input = Uh(n2.input, f2), n2[0] = Uh(n2[0], f2), n2.index = c2.lastIndex, c2.lastIndex += n2[0].length) : c2.lastIndex = 0 : Fh && n2 && (c2.lastIndex = c2.global ? n2.index + n2[0].length : r2), Hh && n2 && n2.length > 1 && yh(Oh, n2[0], i2, function() {
          for (o2 = 1; o2 < arguments.length - 2; o2++)
            void 0 === arguments[o2] && (n2[o2] = void 0);
        }), n2 && h2)
          for (n2.groups = s2 = kh(null), o2 = 0; o2 < h2.length; o2++)
            s2[(a2 = h2[o2])[0]] = n2[a2[1]];
        return n2;
      });
      var jh = Mh;
      Vn({ target: "RegExp", proto: true, forced: /./.exec !== jh }, { exec: jh });
      var Gh = h, Wh = Array.isArray || function(e2) {
        return "Array" == Gh(e2);
      }, Jh = Wh, Kh = ta, zh = ve, qh = _e("species"), Yh = Array, Qh = function(e2) {
        var t2;
        return Jh(e2) && (t2 = e2.constructor, (Kh(t2) && (t2 === Yh || Jh(t2.prototype)) || zh(t2) && null === (t2 = t2[qh])) && (t2 = void 0)), void 0 === t2 ? Yh : t2;
      }, Xh = va, $h = g, Zh = B, ep = Gt, tp = function(e2, t2) {
        return new (Qh(e2))(0 === t2 ? 0 : t2);
      }, ip = c([].push), rp = function(e2) {
        var t2 = 1 == e2, i2 = 2 == e2, r2 = 3 == e2, n2 = 4 == e2, o2 = 6 == e2, s2 = 7 == e2, a2 = 5 == e2 || o2;
        return function(c2, l2, d2, u2) {
          for (var h2, p2, m2 = Zh(c2), _2 = $h(m2), f2 = Xh(l2, d2), g2 = ep(_2), T2 = 0, E2 = u2 || tp, S2 = t2 ? E2(c2, g2) : i2 || s2 ? E2(c2, 0) : void 0; g2 > T2; T2++)
            if ((a2 || T2 in _2) && (p2 = f2(h2 = _2[T2], T2, m2), e2))
              if (t2)
                S2[T2] = p2;
              else if (p2)
                switch (e2) {
                  case 3:
                    return true;
                  case 5:
                    return h2;
                  case 6:
                    return T2;
                  case 2:
                    ip(S2, h2);
                }
              else
                switch (e2) {
                  case 4:
                    return false;
                  case 7:
                    ip(S2, h2);
                }
          return o2 ? -1 : r2 || n2 ? n2 : S2;
        };
      }, np = { forEach: rp(0), map: rp(1), filter: rp(2), some: rp(3), every: rp(4), find: rp(5), findIndex: rp(6), filterReject: rp(7) }, op = i, sp = function(e2, t2) {
        var i2 = [][e2];
        return !!i2 && op(function() {
          i2.call(null, t2 || function() {
            return 1;
          }, 1);
        });
      }, ap = np.forEach, cp = sp("forEach") ? [].forEach : function(e2) {
        return ap(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      }, lp = C, dp = rs, up = ss, hp = cp, pp = zi, mp = function(e2) {
        if (e2 && e2.forEach !== hp)
          try {
            pp(e2, "forEach", hp);
          } catch (EF) {
            e2.forEach = hp;
          }
      };
      for (var _p in dp)
        dp[_p] && mp(lp[_p] && lp[_p].prototype);
      mp(up);
      var fp = et, gp = B, Tp = g, Ep = Gt, Sp = TypeError, Ip = function(e2) {
        return function(t2, i2, r2, n2) {
          fp(i2);
          var o2 = gp(t2), s2 = Tp(o2), a2 = Ep(o2), c2 = e2 ? a2 - 1 : 0, l2 = e2 ? -1 : 1;
          if (r2 < 2)
            for (; ; ) {
              if (c2 in s2) {
                n2 = s2[c2], c2 += l2;
                break;
              }
              if (c2 += l2, e2 ? c2 < 0 : a2 <= c2)
                throw Sp("Reduce of empty array with no initial value");
            }
          for (; e2 ? c2 >= 0 : a2 > c2; c2 += l2)
            c2 in s2 && (n2 = i2(n2, s2[c2], c2, o2));
          return n2;
        };
      }, vp = { left: Ip(false), right: Ip(true) }.left;
      Vn({ target: "Array", proto: true, forced: !Ts && ie > 79 && ie < 83 || !sp("reduce") }, { reduce: function(e2) {
        var t2 = arguments.length;
        return vp(this, e2, t2, t2 > 1 ? arguments[1] : void 0);
      } });
      var yp = Ta, Ap = tn, Rp = jh, Cp = i, bp = _e, kp = zi, Np = bp("species"), Dp = RegExp.prototype, wp = c, Op = Mt, Pp = fu, Mp = I, Lp = wp("".charAt), xp = wp("".charCodeAt), Vp = wp("".slice), Up = function(e2) {
        return function(t2, i2) {
          var r2, n2, o2 = Pp(Mp(t2)), s2 = Op(i2), a2 = o2.length;
          return s2 < 0 || s2 >= a2 ? e2 ? "" : void 0 : (r2 = xp(o2, s2)) < 55296 || r2 > 56319 || s2 + 1 === a2 || (n2 = xp(o2, s2 + 1)) < 56320 || n2 > 57343 ? e2 ? Lp(o2, s2) : r2 : e2 ? Vp(o2, s2, s2 + 2) : n2 - 56320 + (r2 - 55296 << 10) + 65536;
        };
      }, Fp = { codeAt: Up(false), charAt: Up(true) }, Bp = Fp.charAt, Hp = c, jp = B, Gp = Math.floor, Wp = Hp("".charAt), Jp = Hp("".replace), Kp = Hp("".slice), zp = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, qp = /\$([$&'`]|\d{1,2})/g, Yp = function(e2, t2, i2, r2, n2, o2) {
        var s2 = i2 + e2.length, a2 = r2.length, c2 = qp;
        return void 0 !== n2 && (n2 = jp(n2), c2 = zp), Jp(o2, c2, function(o3, c3) {
          var l2;
          switch (Wp(c3, 0)) {
            case "$":
              return "$";
            case "&":
              return e2;
            case "`":
              return Kp(t2, 0, i2);
            case "'":
              return Kp(t2, s2);
            case "<":
              l2 = n2[Kp(c3, 1, -1)];
              break;
            default:
              var d2 = +c3;
              if (0 === d2)
                return o3;
              if (d2 > a2) {
                var u2 = Gp(d2 / 10);
                return 0 === u2 ? o3 : u2 <= a2 ? void 0 === r2[u2 - 1] ? Wp(c3, 1) : r2[u2 - 1] + Wp(c3, 1) : o3;
              }
              l2 = r2[d2 - 1];
          }
          return void 0 === l2 ? "" : l2;
        });
      }, Qp = Fe, Xp = Ce, $p = Ee, Zp = h, em = jh, tm = TypeError, im = _a, rm = Fe, nm = c, om = function(e2, t2, i2, r2) {
        var n2 = bp(e2), o2 = !Cp(function() {
          var t3 = {};
          return t3[n2] = function() {
            return 7;
          }, 7 != ""[e2](t3);
        }), s2 = o2 && !Cp(function() {
          var t3 = false, i3 = /a/;
          return "split" === e2 && ((i3 = {}).constructor = {}, i3.constructor[Np] = function() {
            return i3;
          }, i3.flags = "", i3[n2] = /./[n2]), i3.exec = function() {
            return t3 = true, null;
          }, i3[n2](""), !t3;
        });
        if (!o2 || !s2 || i2) {
          var a2 = yp(/./[n2]), c2 = t2(n2, ""[e2], function(e3, t3, i3, r3, n3) {
            var s3 = yp(e3), c3 = t3.exec;
            return c3 === Rp || c3 === Dp.exec ? o2 && !n3 ? { done: true, value: a2(t3, i3, r3) } : { done: true, value: s3(i3, t3, r3) } : { done: false };
          });
          Ap(String.prototype, e2, c2[0]), Ap(Dp, n2, c2[1]);
        }
        r2 && kp(Dp[n2], "sham", true);
      }, sm = i, am = Ce, cm = Ee, lm = T, dm = Mt, um = Ht, hm = fu, pm = I, mm = function(e2, t2, i2) {
        return t2 + (i2 ? Bp(e2, t2).length : 1);
      }, _m = rt, fm = Yp, gm = function(e2, t2) {
        var i2 = e2.exec;
        if ($p(i2)) {
          var r2 = Qp(i2, e2, t2);
          return null !== r2 && Xp(r2), r2;
        }
        if ("RegExp" === Zp(e2))
          return Qp(em, e2, t2);
        throw tm("RegExp#exec called on incompatible receiver");
      }, Tm = _e("replace"), Em = Math.max, Sm = Math.min, Im = nm([].concat), vm = nm([].push), ym = nm("".indexOf), Am = nm("".slice), Rm = function(e2) {
        return void 0 === e2 ? e2 : String(e2);
      }, Cm = "$0" === "a".replace(/./, "$0"), bm = !!/./[Tm] && "" === /./[Tm]("a", "$0"), km = !sm(function() {
        var e2 = /./;
        return e2.exec = function() {
          var e3 = [];
          return e3.groups = { a: "7" }, e3;
        }, "7" !== "".replace(e2, "$<a>");
      });
      om("replace", function(e2, t2, i2) {
        var r2 = bm ? "$" : "$0";
        return [function(e3, i3) {
          var r3 = pm(this), n2 = lm(e3) ? void 0 : _m(e3, Tm);
          return n2 ? rm(n2, e3, r3, i3) : rm(t2, hm(r3), e3, i3);
        }, function(e3, n2) {
          var o2 = am(this), s2 = hm(e3);
          if ("string" == typeof n2 && -1 === ym(n2, r2) && -1 === ym(n2, "$<")) {
            var a2 = i2(t2, o2, s2, n2);
            if (a2.done)
              return a2.value;
          }
          var c2 = cm(n2);
          c2 || (n2 = hm(n2));
          var l2 = o2.global;
          if (l2) {
            var d2 = o2.unicode;
            o2.lastIndex = 0;
          }
          for (var u2 = []; ; ) {
            var h2 = gm(o2, s2);
            if (null === h2)
              break;
            if (vm(u2, h2), !l2)
              break;
            "" === hm(h2[0]) && (o2.lastIndex = mm(s2, um(o2.lastIndex), d2));
          }
          for (var p2 = "", m2 = 0, _2 = 0; _2 < u2.length; _2++) {
            for (var f2 = hm((h2 = u2[_2])[0]), g2 = Em(Sm(dm(h2.index), s2.length), 0), T2 = [], E2 = 1; E2 < h2.length; E2++)
              vm(T2, Rm(h2[E2]));
            var S2 = h2.groups;
            if (c2) {
              var I2 = Im([f2], T2, g2, s2);
              void 0 !== S2 && vm(I2, S2);
              var v2 = hm(im(n2, void 0, I2));
            } else
              v2 = fm(f2, s2, g2, T2, S2, n2);
            g2 >= m2 && (p2 += Am(s2, m2, g2) + v2, m2 = g2 + f2.length);
          }
          return p2 + Am(s2, m2);
        }];
      }, !km || !Cm || bm);
      var Nm = qt.includes, Dm = Fi;
      Vn({ target: "Array", proto: true, forced: i(function() {
        return !Array(1).includes();
      }) }, { includes: function(e2) {
        return Nm(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      } }), Dm("includes");
      var wm = Mt, Om = fu, Pm = I, Mm = RangeError, Lm = c, xm = Ht, Vm = fu, Um = function(e2) {
        var t2 = Om(Pm(this)), i2 = "", r2 = wm(e2);
        if (r2 < 0 || Infinity == r2)
          throw Mm("Wrong number of repetitions");
        for (; r2 > 0; (r2 >>>= 1) && (t2 += t2))
          1 & r2 && (i2 += t2);
        return i2;
      }, Fm = I, Bm = Lm(Um), Hm = Lm("".slice), jm = Math.ceil, Gm = function(e2) {
        return function(t2, i2, r2) {
          var n2, o2, s2 = Vm(Fm(t2)), a2 = xm(i2), c2 = s2.length, l2 = void 0 === r2 ? " " : Vm(r2);
          return a2 <= c2 || "" == l2 ? s2 : ((o2 = Bm(l2, jm((n2 = a2 - c2) / l2.length))).length > n2 && (o2 = Hm(o2, 0, n2)), e2 ? s2 + o2 : o2 + s2);
        };
      }, Wm = { start: Gm(false), end: Gm(true) }, Jm = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(Y), Km = Wm.start;
      Vn({ target: "String", proto: true, forced: Jm }, { padStart: function(e2) {
        return Km(this, e2, arguments.length > 1 ? arguments[1] : void 0);
      } });
      var zm = i, qm = ke, Ym = _e("iterator"), Qm = !zm(function() {
        var e2 = new URL("b?a=1&b=2&c=3", "http://a"), t2 = e2.searchParams, i2 = "";
        return e2.pathname = "c%20d", t2.forEach(function(e3, r2) {
          t2.delete("b"), i2 += r2 + e3;
        }), !t2.size && !qm || !t2.sort || "http://a/c%20d?a=1&c=3" !== e2.href || "3" !== t2.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t2[Ym] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("http://a#Ð±").hash || "a1c3" !== i2 || "x" !== new URL("http://x", void 0).host;
      }), Xm = tn, $m = function(e2, t2, i2) {
        for (var r2 in t2)
          Xm(e2, r2, t2[r2], i2);
        return e2;
      }, Zm = Tt, e_ = De, t_ = Wi, i_ = function(e2, t2, i2) {
        var r2 = Zm(t2);
        r2 in e2 ? e_.f(e2, r2, t_(0, i2)) : e2[r2] = i2;
      }, r_ = Ut, n_ = Gt, o_ = i_, s_ = Array, a_ = Math.max, c_ = function(e2, t2, i2) {
        for (var r2 = n_(e2), n2 = r_(t2, r2), o2 = r_(void 0 === i2 ? r2 : i2, r2), s2 = s_(a_(o2 - n2, 0)), a2 = 0; n2 < o2; n2++, a2++)
          o_(s2, a2, e2[n2]);
        return s2.length = a2, s2;
      }, l_ = c_, d_ = Math.floor, u_ = function(e2, t2) {
        var i2 = e2.length, r2 = d_(i2 / 2);
        return i2 < 8 ? h_(e2, t2) : p_(e2, u_(l_(e2, 0, r2), t2), u_(l_(e2, r2), t2), t2);
      }, h_ = function(e2, t2) {
        for (var i2, r2, n2 = e2.length, o2 = 1; o2 < n2; ) {
          for (r2 = o2, i2 = e2[o2]; r2 && t2(e2[r2 - 1], i2) > 0; )
            e2[r2] = e2[--r2];
          r2 !== o2++ && (e2[r2] = i2);
        }
        return e2;
      }, p_ = function(e2, t2, i2, r2) {
        for (var n2 = t2.length, o2 = i2.length, s2 = 0, a2 = 0; s2 < n2 || a2 < o2; )
          e2[s2 + a2] = s2 < n2 && a2 < o2 ? r2(t2[s2], i2[a2]) <= 0 ? t2[s2++] : i2[a2++] : s2 < n2 ? t2[s2++] : i2[a2++];
        return e2;
      }, m_ = u_, __ = Vn, f_ = C, g_ = Fe, T_ = c, E_ = ke, S_ = Qm, I_ = tn, v_ = Is, y_ = $m, A_ = oo, R_ = po, C_ = ar, b_ = Ns, k_ = Ee, N_ = G, D_ = va, w_ = Vs, O_ = Ce, P_ = ve, M_ = fu, L_ = Di, x_ = Wi, V_ = ad, U_ = ed, F_ = Ra, B_ = m_, H_ = _e("iterator"), j_ = "URLSearchParams", G_ = j_ + "Iterator", W_ = C_.set, J_ = C_.getterFor(j_), K_ = C_.getterFor(G_), z_ = Object.getOwnPropertyDescriptor, q_ = function(e2) {
        if (!E_)
          return f_[e2];
        var t2 = z_(f_, e2);
        return t2 && t2.value;
      }, Y_ = q_("fetch"), Q_ = q_("Request"), X_ = q_("Headers"), $_ = Q_ && Q_.prototype, Z_ = X_ && X_.prototype, ef = f_.RegExp, tf = f_.TypeError, rf = f_.decodeURIComponent, nf = f_.encodeURIComponent, of = T_("".charAt), sf = T_([].join), af = T_([].push), cf = T_("".replace), lf = T_([].shift), df = T_([].splice), uf = T_("".split), hf = T_("".slice), pf = /\+/g, mf = Array(4), _f = function(e2) {
        return mf[e2 - 1] || (mf[e2 - 1] = ef("((?:%[\\da-f]{2}){" + e2 + "})", "gi"));
      }, ff = function(e2) {
        try {
          return rf(e2);
        } catch (EF) {
          return e2;
        }
      }, gf = function(e2) {
        var t2 = cf(e2, pf, " "), i2 = 4;
        try {
          return rf(t2);
        } catch (EF) {
          for (; i2; )
            t2 = cf(t2, _f(i2--), ff);
          return t2;
        }
      }, Tf = /[!'()~]|%20/g, Ef = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+" }, Sf = function(e2) {
        return Ef[e2];
      }, If = function(e2) {
        return cf(nf(e2), Tf, Sf);
      }, vf = R_(function(e2, t2) {
        W_(this, { type: G_, iterator: V_(J_(e2).entries), kind: t2 });
      }, "Iterator", function() {
        var e2 = K_(this), t2 = e2.kind, i2 = e2.iterator.next(), r2 = i2.value;
        return i2.done || (i2.value = "keys" === t2 ? r2.key : "values" === t2 ? r2.value : [r2.key, r2.value]), i2;
      }, true), yf = function(e2) {
        this.entries = [], this.url = null, void 0 !== e2 && (P_(e2) ? this.parseObject(e2) : this.parseQuery("string" == typeof e2 ? "?" === of(e2, 0) ? hf(e2, 1) : e2 : M_(e2)));
      };
      yf.prototype = { type: j_, bindURL: function(e2) {
        this.url = e2, this.update();
      }, parseObject: function(e2) {
        var t2, i2, r2, n2, o2, s2, a2, c2 = U_(e2);
        if (c2)
          for (i2 = (t2 = V_(e2, c2)).next; !(r2 = g_(i2, t2)).done; ) {
            if (o2 = (n2 = V_(O_(r2.value))).next, (s2 = g_(o2, n2)).done || (a2 = g_(o2, n2)).done || !g_(o2, n2).done)
              throw tf("Expected sequence with length 2");
            af(this.entries, { key: M_(s2.value), value: M_(a2.value) });
          }
        else
          for (var l2 in e2)
            N_(e2, l2) && af(this.entries, { key: l2, value: M_(e2[l2]) });
      }, parseQuery: function(e2) {
        if (e2)
          for (var t2, i2, r2 = uf(e2, "&"), n2 = 0; n2 < r2.length; )
            (t2 = r2[n2++]).length && (i2 = uf(t2, "="), af(this.entries, { key: gf(lf(i2)), value: gf(sf(i2, "=")) }));
      }, serialize: function() {
        for (var e2, t2 = this.entries, i2 = [], r2 = 0; r2 < t2.length; )
          e2 = t2[r2++], af(i2, If(e2.key) + "=" + If(e2.value));
        return sf(i2, "&");
      }, update: function() {
        this.entries.length = 0, this.parseQuery(this.url.query);
      }, updateURL: function() {
        this.url && this.url.update();
      } };
      var Af = function() {
        b_(this, Rf);
        var e2 = W_(this, new yf(arguments.length > 0 ? arguments[0] : void 0));
        E_ || (this.length = e2.entries.length);
      }, Rf = Af.prototype;
      if (y_(Rf, { append: function(e2, t2) {
        F_(arguments.length, 2);
        var i2 = J_(this);
        af(i2.entries, { key: M_(e2), value: M_(t2) }), E_ || this.length++, i2.updateURL();
      }, delete: function(e2) {
        F_(arguments.length, 1);
        for (var t2 = J_(this), i2 = t2.entries, r2 = M_(e2), n2 = 0; n2 < i2.length; )
          i2[n2].key === r2 ? df(i2, n2, 1) : n2++;
        E_ || (this.length = i2.length), t2.updateURL();
      }, get: function(e2) {
        F_(arguments.length, 1);
        for (var t2 = J_(this).entries, i2 = M_(e2), r2 = 0; r2 < t2.length; r2++)
          if (t2[r2].key === i2)
            return t2[r2].value;
        return null;
      }, getAll: function(e2) {
        F_(arguments.length, 1);
        for (var t2 = J_(this).entries, i2 = M_(e2), r2 = [], n2 = 0; n2 < t2.length; n2++)
          t2[n2].key === i2 && af(r2, t2[n2].value);
        return r2;
      }, has: function(e2) {
        F_(arguments.length, 1);
        for (var t2 = J_(this).entries, i2 = M_(e2), r2 = 0; r2 < t2.length; )
          if (t2[r2++].key === i2)
            return true;
        return false;
      }, set: function(e2, t2) {
        F_(arguments.length, 1);
        for (var i2, r2 = J_(this), n2 = r2.entries, o2 = false, s2 = M_(e2), a2 = M_(t2), c2 = 0; c2 < n2.length; c2++)
          (i2 = n2[c2]).key === s2 && (o2 ? df(n2, c2--, 1) : (o2 = true, i2.value = a2));
        o2 || af(n2, { key: s2, value: a2 }), E_ || (this.length = n2.length), r2.updateURL();
      }, sort: function() {
        var e2 = J_(this);
        B_(e2.entries, function(e3, t2) {
          return e3.key > t2.key ? 1 : -1;
        }), e2.updateURL();
      }, forEach: function(e2) {
        for (var t2, i2 = J_(this).entries, r2 = D_(e2, arguments.length > 1 ? arguments[1] : void 0), n2 = 0; n2 < i2.length; )
          r2((t2 = i2[n2++]).value, t2.key, this);
      }, keys: function() {
        return new vf(this, "keys");
      }, values: function() {
        return new vf(this, "values");
      }, entries: function() {
        return new vf(this, "entries");
      } }, { enumerable: true }), I_(Rf, H_, Rf.entries, { name: "entries" }), I_(Rf, "toString", function() {
        return J_(this).serialize();
      }, { enumerable: true }), E_ && v_(Rf, "size", { get: function() {
        return J_(this).entries.length;
      }, configurable: true, enumerable: true }), A_(Af, j_), __({ global: true, constructor: true, forced: !S_ }, { URLSearchParams: Af }), !S_ && k_(X_)) {
        var Cf = T_(Z_.has), bf = T_(Z_.set), kf = function(e2) {
          if (P_(e2)) {
            var t2, i2 = e2.body;
            if (w_(i2) === j_)
              return t2 = e2.headers ? new X_(e2.headers) : new X_(), Cf(t2, "content-type") || bf(t2, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), L_(e2, { body: x_(0, M_(i2)), headers: x_(0, t2) });
          }
          return e2;
        };
        if (k_(Y_) && __({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, { fetch: function(e2) {
          return Y_(e2, arguments.length > 1 ? kf(arguments[1]) : {});
        } }), k_(Q_)) {
          var Nf = function(e2) {
            return b_(this, $_), new Q_(e2, arguments.length > 1 ? kf(arguments[1]) : {});
          };
          $_.constructor = Nf, Nf.prototype = $_, __({ global: true, constructor: true, dontCallGetSet: true, forced: true }, { Request: Nf });
        }
      }
      var Df = { URLSearchParams: Af, getState: J_ }, wf = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF", Of = I, Pf = fu, Mf = wf, Lf = c("".replace), xf = RegExp("^[" + Mf + "]+"), Vf = RegExp("(^|[^" + Mf + "])[" + Mf + "]+$"), Uf = function(e2) {
        return function(t2) {
          var i2 = Pf(Of(t2));
          return 1 & e2 && (i2 = Lf(i2, xf, "")), 2 & e2 && (i2 = Lf(i2, Vf, "$1")), i2;
        };
      }, Ff = { start: Uf(1), end: Uf(2), trim: Uf(3) }, Bf = Nr.PROPER, Hf = i, jf = wf, Gf = Ff.trim;
      Vn({ target: "String", proto: true, forced: function(e2) {
        return Hf(function() {
          return !!jf[e2]() || "âÂá " !== "âÂá "[e2]() || Bf && jf[e2].name !== e2;
        });
      }("trim") }, { trim: function() {
        return Gf(this);
      } });
      var Wf = Vn, Jf = ke, Kf = c, zf = G, qf = Ee, Yf = Ge, Qf = fu, Xf = Is, $f = Sn, Zf = C.Symbol, eg = Zf && Zf.prototype;
      if (Jf && qf(Zf) && (!("description" in eg) || void 0 !== Zf().description)) {
        var tg = {}, ig = function() {
          var e2 = arguments.length < 1 || void 0 === arguments[0] ? void 0 : Qf(arguments[0]), t2 = Yf(eg, this) ? new Zf(e2) : void 0 === e2 ? Zf() : Zf(e2);
          return "" === e2 && (tg[t2] = true), t2;
        };
        $f(ig, Zf), ig.prototype = eg, eg.constructor = ig;
        var rg = "Symbol(test)" == String(Zf("test")), ng = Kf(eg.valueOf), og = Kf(eg.toString), sg = /^Symbol\((.*)\)[^)]+$/, ag = Kf("".replace), cg = Kf("".slice);
        Xf(eg, "description", { configurable: true, get: function() {
          var e2 = ng(this);
          if (zf(tg, e2))
            return "";
          var t2 = og(e2), i2 = rg ? cg(t2, 7, -1) : ag(t2, sg, "$1");
          return "" === i2 ? void 0 : i2;
        } }), Wf({ global: true, constructor: true, forced: true }, { Symbol: ig });
      }
      var lg = Fp.charAt, dg = fu, ug = ar, hg = jo, pg = Go, mg = "String Iterator", _g = ug.set, fg = ug.getterFor(mg);
      hg(String, "String", function(e2) {
        _g(this, { type: mg, string: dg(e2), index: 0 });
      }, function() {
        var e2, t2 = fg(this), i2 = t2.string, r2 = t2.index;
        return r2 >= i2.length ? pg(void 0, true) : (e2 = lg(i2, r2), t2.index += e2.length, pg(e2, false));
      });
      var gg, Tg = ke, Eg = c, Sg = Fe, Ig = i, vg = oi, yg = sn, Ag = lr, Rg = B, Cg = g, bg = Object.assign, kg = Object.defineProperty, Ng = Eg([].concat), Dg = !bg || Ig(function() {
        if (Tg && 1 !== bg({ b: 1 }, bg(kg({}, "a", { enumerable: true, get: function() {
          kg(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b)
          return true;
        var e2 = {}, t2 = {}, i2 = Symbol(), r2 = "abcdefghijklmnopqrst";
        return e2[i2] = 7, r2.split("").forEach(function(e3) {
          t2[e3] = e3;
        }), 7 != bg({}, e2)[i2] || vg(bg({}, t2)).join("") != r2;
      }) ? function(e2, t2) {
        for (var i2 = Rg(e2), r2 = arguments.length, n2 = 1, o2 = yg.f, s2 = Ag.f; r2 > n2; )
          for (var a2, c2 = Cg(arguments[n2++]), l2 = o2 ? Ng(vg(c2), o2(c2)) : vg(c2), d2 = l2.length, u2 = 0; d2 > u2; )
            a2 = l2[u2++], Tg && !Sg(s2, c2, a2) || (i2[a2] = c2[a2]);
        return i2;
      } : bg, wg = Ce, Og = ud, Pg = va, Mg = Fe, Lg = B, xg = function(e2, t2, i2, r2) {
        try {
          return r2 ? t2(wg(i2)[0], i2[1]) : t2(i2);
        } catch (EF) {
          Og(e2, "throw", EF);
        }
      }, Vg = ql, Ug = ta, Fg = Gt, Bg = i_, Hg = ad, jg = ed, Gg = Array, Wg = c, Jg = 2147483647, Kg = /[^\0-\u007E]/, zg = /[.\u3002\uFF0E\uFF61]/g, qg = "Overflow: input needs wider integers to process", Yg = RangeError, Qg = Wg(zg.exec), Xg = Math.floor, $g = String.fromCharCode, Zg = Wg("".charCodeAt), eT = Wg([].join), tT = Wg([].push), iT = Wg("".replace), rT = Wg("".split), nT = Wg("".toLowerCase), oT = function(e2) {
        return e2 + 22 + 75 * (e2 < 26);
      }, sT = function(e2, t2, i2) {
        var r2 = 0;
        for (e2 = i2 ? Xg(e2 / 700) : e2 >> 1, e2 += Xg(e2 / t2); e2 > 455; )
          e2 = Xg(e2 / 35), r2 += 36;
        return Xg(r2 + 36 * e2 / (e2 + 38));
      }, aT = function(e2) {
        var t2 = [];
        e2 = function(e3) {
          for (var t3 = [], i3 = 0, r3 = e3.length; i3 < r3; ) {
            var n3 = Zg(e3, i3++);
            if (n3 >= 55296 && n3 <= 56319 && i3 < r3) {
              var o3 = Zg(e3, i3++);
              56320 == (64512 & o3) ? tT(t3, ((1023 & n3) << 10) + (1023 & o3) + 65536) : (tT(t3, n3), i3--);
            } else
              tT(t3, n3);
          }
          return t3;
        }(e2);
        var i2, r2, n2 = e2.length, o2 = 128, s2 = 0, a2 = 72;
        for (i2 = 0; i2 < e2.length; i2++)
          (r2 = e2[i2]) < 128 && tT(t2, $g(r2));
        var c2 = t2.length, l2 = c2;
        for (c2 && tT(t2, "-"); l2 < n2; ) {
          var d2 = Jg;
          for (i2 = 0; i2 < e2.length; i2++)
            (r2 = e2[i2]) >= o2 && r2 < d2 && (d2 = r2);
          var u2 = l2 + 1;
          if (d2 - o2 > Xg((Jg - s2) / u2))
            throw Yg(qg);
          for (s2 += (d2 - o2) * u2, o2 = d2, i2 = 0; i2 < e2.length; i2++) {
            if ((r2 = e2[i2]) < o2 && ++s2 > Jg)
              throw Yg(qg);
            if (r2 == o2) {
              for (var h2 = s2, p2 = 36; ; ) {
                var m2 = p2 <= a2 ? 1 : p2 >= a2 + 26 ? 26 : p2 - a2;
                if (h2 < m2)
                  break;
                var _2 = h2 - m2, f2 = 36 - m2;
                tT(t2, $g(oT(m2 + _2 % f2))), h2 = Xg(_2 / f2), p2 += 36;
              }
              tT(t2, $g(oT(h2))), a2 = sT(s2, u2, l2 == c2), s2 = 0, l2++;
            }
          }
          s2++, o2++;
        }
        return eT(t2, "");
      }, cT = Vn, lT = ke, dT = Qm, uT = C, hT = va, pT = c, mT = tn, _T = Is, fT = Ns, gT = G, TT = Dg, ET = function(e2) {
        var t2 = Lg(e2), i2 = Ug(this), r2 = arguments.length, n2 = r2 > 1 ? arguments[1] : void 0, o2 = void 0 !== n2;
        o2 && (n2 = Pg(n2, r2 > 2 ? arguments[2] : void 0));
        var s2, a2, c2, l2, d2, u2, h2 = jg(t2), p2 = 0;
        if (!h2 || this === Gg && Vg(h2))
          for (s2 = Fg(t2), a2 = i2 ? new this(s2) : Gg(s2); s2 > p2; p2++)
            u2 = o2 ? n2(t2[p2], p2) : t2[p2], Bg(a2, p2, u2);
        else
          for (d2 = (l2 = Hg(t2, h2)).next, a2 = i2 ? new this() : []; !(c2 = Mg(d2, l2)).done; p2++)
            u2 = o2 ? xg(l2, n2, [c2.value, p2], true) : c2.value, Bg(a2, p2, u2);
        return a2.length = p2, a2;
      }, ST = c_, IT = Fp.codeAt, vT = function(e2) {
        var t2, i2, r2 = [], n2 = rT(iT(nT(e2), zg, "."), ".");
        for (t2 = 0; t2 < n2.length; t2++)
          i2 = n2[t2], tT(r2, Qg(Kg, i2) ? "xn--" + aT(i2) : i2);
        return eT(r2, ".");
      }, yT = fu, AT = oo, RT = Ra, CT = Df, bT = ar, kT = bT.set, NT = bT.getterFor("URL"), DT = CT.URLSearchParams, wT = CT.getState, OT = uT.URL, PT = uT.TypeError, MT = uT.parseInt, LT = Math.floor, xT = Math.pow, VT = pT("".charAt), UT = pT(/./.exec), FT = pT([].join), BT = pT(1 .toString), HT = pT([].pop), jT = pT([].push), GT = pT("".replace), WT = pT([].shift), JT = pT("".split), KT = pT("".slice), zT = pT("".toLowerCase), qT = pT([].unshift), YT = "Invalid scheme", QT = "Invalid host", XT = "Invalid port", $T = /[a-z]/i, ZT = /[\d+-.a-z]/i, eE = /\d/, tE = /^0x/i, iE = /^[0-7]+$/, rE = /^\d+$/, nE = /^[\da-f]+$/i, oE = /[\0\t\n\r #%/:<>?@[\\\]^|]/, sE = /[\0\t\n\r #/:<>?@[\\\]^|]/, aE = /^[\u0000-\u0020]+/, cE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/, lE = /[\t\n\r]/g, dE = function(e2) {
        var t2, i2, r2, n2;
        if ("number" == typeof e2) {
          for (t2 = [], i2 = 0; i2 < 4; i2++)
            qT(t2, e2 % 256), e2 = LT(e2 / 256);
          return FT(t2, ".");
        }
        if ("object" == typeof e2) {
          for (t2 = "", r2 = function(e3) {
            for (var t3 = null, i3 = 1, r3 = null, n3 = 0, o2 = 0; o2 < 8; o2++)
              0 !== e3[o2] ? (n3 > i3 && (t3 = r3, i3 = n3), r3 = null, n3 = 0) : (null === r3 && (r3 = o2), ++n3);
            return n3 > i3 && (t3 = r3, i3 = n3), t3;
          }(e2), i2 = 0; i2 < 8; i2++)
            n2 && 0 === e2[i2] || (n2 && (n2 = false), r2 === i2 ? (t2 += i2 ? ":" : "::", n2 = true) : (t2 += BT(e2[i2], 16), i2 < 7 && (t2 += ":")));
          return "[" + t2 + "]";
        }
        return e2;
      }, uE = {}, hE = TT({}, uE, { " ": 1, '"': 1, "<": 1, ">": 1, "`": 1 }), pE = TT({}, hE, { "#": 1, "?": 1, "{": 1, "}": 1 }), mE = TT({}, pE, { "/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1 }), _E = function(e2, t2) {
        var i2 = IT(e2, 0);
        return i2 > 32 && i2 < 127 && !gT(t2, e2) ? e2 : encodeURIComponent(e2);
      }, fE = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }, gE = function(e2, t2) {
        var i2;
        return 2 == e2.length && UT($T, VT(e2, 0)) && (":" == (i2 = VT(e2, 1)) || !t2 && "|" == i2);
      }, TE = function(e2) {
        var t2;
        return e2.length > 1 && gE(KT(e2, 0, 2)) && (2 == e2.length || "/" === (t2 = VT(e2, 2)) || "\\" === t2 || "?" === t2 || "#" === t2);
      }, EE = function(e2) {
        return "." === e2 || "%2e" === zT(e2);
      }, SE = {}, IE = {}, vE = {}, yE = {}, AE = {}, RE = {}, CE = {}, bE = {}, kE = {}, NE = {}, DE = {}, wE = {}, OE = {}, PE = {}, ME = {}, LE = {}, xE = {}, VE = {}, UE = {}, FE = {}, BE = {}, HE = function(e2, t2, i2) {
        var r2, n2, o2, s2 = yT(e2);
        if (t2) {
          if (n2 = this.parse(s2))
            throw PT(n2);
          this.searchParams = null;
        } else {
          if (void 0 !== i2 && (r2 = new HE(i2, true)), n2 = this.parse(s2, null, r2))
            throw PT(n2);
          (o2 = wT(new DT())).bindURL(this), this.searchParams = o2;
        }
      };
      HE.prototype = { type: "URL", parse: function(e2, t2, i2) {
        var r2, n2, o2, s2, a2, c2 = this, l2 = t2 || SE, d2 = 0, u2 = "", h2 = false, p2 = false, m2 = false;
        for (e2 = yT(e2), t2 || (c2.scheme = "", c2.username = "", c2.password = "", c2.host = null, c2.port = null, c2.path = [], c2.query = null, c2.fragment = null, c2.cannotBeABaseURL = false, e2 = GT(e2, aE, ""), e2 = GT(e2, cE, "$1")), e2 = GT(e2, lE, ""), r2 = ET(e2); d2 <= r2.length; ) {
          switch (n2 = r2[d2], l2) {
            case SE:
              if (!n2 || !UT($T, n2)) {
                if (t2)
                  return YT;
                l2 = vE;
                continue;
              }
              u2 += zT(n2), l2 = IE;
              break;
            case IE:
              if (n2 && (UT(ZT, n2) || "+" == n2 || "-" == n2 || "." == n2))
                u2 += zT(n2);
              else {
                if (":" != n2) {
                  if (t2)
                    return YT;
                  u2 = "", l2 = vE, d2 = 0;
                  continue;
                }
                if (t2 && (c2.isSpecial() != gT(fE, u2) || "file" == u2 && (c2.includesCredentials() || null !== c2.port) || "file" == c2.scheme && !c2.host))
                  return;
                if (c2.scheme = u2, t2)
                  return void (c2.isSpecial() && fE[c2.scheme] == c2.port && (c2.port = null));
                u2 = "", "file" == c2.scheme ? l2 = PE : c2.isSpecial() && i2 && i2.scheme == c2.scheme ? l2 = yE : c2.isSpecial() ? l2 = bE : "/" == r2[d2 + 1] ? (l2 = AE, d2++) : (c2.cannotBeABaseURL = true, jT(c2.path, ""), l2 = UE);
              }
              break;
            case vE:
              if (!i2 || i2.cannotBeABaseURL && "#" != n2)
                return YT;
              if (i2.cannotBeABaseURL && "#" == n2) {
                c2.scheme = i2.scheme, c2.path = ST(i2.path), c2.query = i2.query, c2.fragment = "", c2.cannotBeABaseURL = true, l2 = BE;
                break;
              }
              l2 = "file" == i2.scheme ? PE : RE;
              continue;
            case yE:
              if ("/" != n2 || "/" != r2[d2 + 1]) {
                l2 = RE;
                continue;
              }
              l2 = kE, d2++;
              break;
            case AE:
              if ("/" == n2) {
                l2 = NE;
                break;
              }
              l2 = VE;
              continue;
            case RE:
              if (c2.scheme = i2.scheme, n2 == gg)
                c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = ST(i2.path), c2.query = i2.query;
              else if ("/" == n2 || "\\" == n2 && c2.isSpecial())
                l2 = CE;
              else if ("?" == n2)
                c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = ST(i2.path), c2.query = "", l2 = FE;
              else {
                if ("#" != n2) {
                  c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = ST(i2.path), c2.path.length--, l2 = VE;
                  continue;
                }
                c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, c2.path = ST(i2.path), c2.query = i2.query, c2.fragment = "", l2 = BE;
              }
              break;
            case CE:
              if (!c2.isSpecial() || "/" != n2 && "\\" != n2) {
                if ("/" != n2) {
                  c2.username = i2.username, c2.password = i2.password, c2.host = i2.host, c2.port = i2.port, l2 = VE;
                  continue;
                }
                l2 = NE;
              } else
                l2 = kE;
              break;
            case bE:
              if (l2 = kE, "/" != n2 || "/" != VT(u2, d2 + 1))
                continue;
              d2++;
              break;
            case kE:
              if ("/" != n2 && "\\" != n2) {
                l2 = NE;
                continue;
              }
              break;
            case NE:
              if ("@" == n2) {
                h2 && (u2 = "%40" + u2), h2 = true, o2 = ET(u2);
                for (var _2 = 0; _2 < o2.length; _2++) {
                  var f2 = o2[_2];
                  if (":" != f2 || m2) {
                    var g2 = _E(f2, mE);
                    m2 ? c2.password += g2 : c2.username += g2;
                  } else
                    m2 = true;
                }
                u2 = "";
              } else if (n2 == gg || "/" == n2 || "?" == n2 || "#" == n2 || "\\" == n2 && c2.isSpecial()) {
                if (h2 && "" == u2)
                  return "Invalid authority";
                d2 -= ET(u2).length + 1, u2 = "", l2 = DE;
              } else
                u2 += n2;
              break;
            case DE:
            case wE:
              if (t2 && "file" == c2.scheme) {
                l2 = LE;
                continue;
              }
              if (":" != n2 || p2) {
                if (n2 == gg || "/" == n2 || "?" == n2 || "#" == n2 || "\\" == n2 && c2.isSpecial()) {
                  if (c2.isSpecial() && "" == u2)
                    return QT;
                  if (t2 && "" == u2 && (c2.includesCredentials() || null !== c2.port))
                    return;
                  if (s2 = c2.parseHost(u2))
                    return s2;
                  if (u2 = "", l2 = xE, t2)
                    return;
                  continue;
                }
                "[" == n2 ? p2 = true : "]" == n2 && (p2 = false), u2 += n2;
              } else {
                if ("" == u2)
                  return QT;
                if (s2 = c2.parseHost(u2))
                  return s2;
                if (u2 = "", l2 = OE, t2 == wE)
                  return;
              }
              break;
            case OE:
              if (!UT(eE, n2)) {
                if (n2 == gg || "/" == n2 || "?" == n2 || "#" == n2 || "\\" == n2 && c2.isSpecial() || t2) {
                  if ("" != u2) {
                    var T2 = MT(u2, 10);
                    if (T2 > 65535)
                      return XT;
                    c2.port = c2.isSpecial() && T2 === fE[c2.scheme] ? null : T2, u2 = "";
                  }
                  if (t2)
                    return;
                  l2 = xE;
                  continue;
                }
                return XT;
              }
              u2 += n2;
              break;
            case PE:
              if (c2.scheme = "file", "/" == n2 || "\\" == n2)
                l2 = ME;
              else {
                if (!i2 || "file" != i2.scheme) {
                  l2 = VE;
                  continue;
                }
                if (n2 == gg)
                  c2.host = i2.host, c2.path = ST(i2.path), c2.query = i2.query;
                else if ("?" == n2)
                  c2.host = i2.host, c2.path = ST(i2.path), c2.query = "", l2 = FE;
                else {
                  if ("#" != n2) {
                    TE(FT(ST(r2, d2), "")) || (c2.host = i2.host, c2.path = ST(i2.path), c2.shortenPath()), l2 = VE;
                    continue;
                  }
                  c2.host = i2.host, c2.path = ST(i2.path), c2.query = i2.query, c2.fragment = "", l2 = BE;
                }
              }
              break;
            case ME:
              if ("/" == n2 || "\\" == n2) {
                l2 = LE;
                break;
              }
              i2 && "file" == i2.scheme && !TE(FT(ST(r2, d2), "")) && (gE(i2.path[0], true) ? jT(c2.path, i2.path[0]) : c2.host = i2.host), l2 = VE;
              continue;
            case LE:
              if (n2 == gg || "/" == n2 || "\\" == n2 || "?" == n2 || "#" == n2) {
                if (!t2 && gE(u2))
                  l2 = VE;
                else if ("" == u2) {
                  if (c2.host = "", t2)
                    return;
                  l2 = xE;
                } else {
                  if (s2 = c2.parseHost(u2))
                    return s2;
                  if ("localhost" == c2.host && (c2.host = ""), t2)
                    return;
                  u2 = "", l2 = xE;
                }
                continue;
              }
              u2 += n2;
              break;
            case xE:
              if (c2.isSpecial()) {
                if (l2 = VE, "/" != n2 && "\\" != n2)
                  continue;
              } else if (t2 || "?" != n2)
                if (t2 || "#" != n2) {
                  if (n2 != gg && (l2 = VE, "/" != n2))
                    continue;
                } else
                  c2.fragment = "", l2 = BE;
              else
                c2.query = "", l2 = FE;
              break;
            case VE:
              if (n2 == gg || "/" == n2 || "\\" == n2 && c2.isSpecial() || !t2 && ("?" == n2 || "#" == n2)) {
                if (".." === (a2 = zT(a2 = u2)) || "%2e." === a2 || ".%2e" === a2 || "%2e%2e" === a2 ? (c2.shortenPath(), "/" == n2 || "\\" == n2 && c2.isSpecial() || jT(c2.path, "")) : EE(u2) ? "/" == n2 || "\\" == n2 && c2.isSpecial() || jT(c2.path, "") : ("file" == c2.scheme && !c2.path.length && gE(u2) && (c2.host && (c2.host = ""), u2 = VT(u2, 0) + ":"), jT(c2.path, u2)), u2 = "", "file" == c2.scheme && (n2 == gg || "?" == n2 || "#" == n2))
                  for (; c2.path.length > 1 && "" === c2.path[0]; )
                    WT(c2.path);
                "?" == n2 ? (c2.query = "", l2 = FE) : "#" == n2 && (c2.fragment = "", l2 = BE);
              } else
                u2 += _E(n2, pE);
              break;
            case UE:
              "?" == n2 ? (c2.query = "", l2 = FE) : "#" == n2 ? (c2.fragment = "", l2 = BE) : n2 != gg && (c2.path[0] += _E(n2, uE));
              break;
            case FE:
              t2 || "#" != n2 ? n2 != gg && ("'" == n2 && c2.isSpecial() ? c2.query += "%27" : c2.query += "#" == n2 ? "%23" : _E(n2, uE)) : (c2.fragment = "", l2 = BE);
              break;
            case BE:
              n2 != gg && (c2.fragment += _E(n2, hE));
          }
          d2++;
        }
      }, parseHost: function(e2) {
        var t2, i2, r2;
        if ("[" == VT(e2, 0)) {
          if ("]" != VT(e2, e2.length - 1))
            return QT;
          if (t2 = function(e3) {
            var t3, i3, r3, n2, o2, s2, a2, c2 = [0, 0, 0, 0, 0, 0, 0, 0], l2 = 0, d2 = null, u2 = 0, h2 = function() {
              return VT(e3, u2);
            };
            if (":" == h2()) {
              if (":" != VT(e3, 1))
                return;
              u2 += 2, d2 = ++l2;
            }
            for (; h2(); ) {
              if (8 == l2)
                return;
              if (":" != h2()) {
                for (t3 = i3 = 0; i3 < 4 && UT(nE, h2()); )
                  t3 = 16 * t3 + MT(h2(), 16), u2++, i3++;
                if ("." == h2()) {
                  if (0 == i3)
                    return;
                  if (u2 -= i3, l2 > 6)
                    return;
                  for (r3 = 0; h2(); ) {
                    if (n2 = null, r3 > 0) {
                      if (!("." == h2() && r3 < 4))
                        return;
                      u2++;
                    }
                    if (!UT(eE, h2()))
                      return;
                    for (; UT(eE, h2()); ) {
                      if (o2 = MT(h2(), 10), null === n2)
                        n2 = o2;
                      else {
                        if (0 == n2)
                          return;
                        n2 = 10 * n2 + o2;
                      }
                      if (n2 > 255)
                        return;
                      u2++;
                    }
                    c2[l2] = 256 * c2[l2] + n2, 2 != ++r3 && 4 != r3 || l2++;
                  }
                  if (4 != r3)
                    return;
                  break;
                }
                if (":" == h2()) {
                  if (u2++, !h2())
                    return;
                } else if (h2())
                  return;
                c2[l2++] = t3;
              } else {
                if (null !== d2)
                  return;
                u2++, d2 = ++l2;
              }
            }
            if (null !== d2)
              for (s2 = l2 - d2, l2 = 7; 0 != l2 && s2 > 0; )
                a2 = c2[l2], c2[l2--] = c2[d2 + s2 - 1], c2[d2 + --s2] = a2;
            else if (8 != l2)
              return;
            return c2;
          }(KT(e2, 1, -1)), !t2)
            return QT;
          this.host = t2;
        } else if (this.isSpecial()) {
          if (e2 = vT(e2), UT(oE, e2))
            return QT;
          if (t2 = function(e3) {
            var t3, i3, r3, n2, o2, s2, a2, c2 = JT(e3, ".");
            if (c2.length && "" == c2[c2.length - 1] && c2.length--, (t3 = c2.length) > 4)
              return e3;
            for (i3 = [], r3 = 0; r3 < t3; r3++) {
              if ("" == (n2 = c2[r3]))
                return e3;
              if (o2 = 10, n2.length > 1 && "0" == VT(n2, 0) && (o2 = UT(tE, n2) ? 16 : 8, n2 = KT(n2, 8 == o2 ? 1 : 2)), "" === n2)
                s2 = 0;
              else {
                if (!UT(10 == o2 ? rE : 8 == o2 ? iE : nE, n2))
                  return e3;
                s2 = MT(n2, o2);
              }
              jT(i3, s2);
            }
            for (r3 = 0; r3 < t3; r3++)
              if (s2 = i3[r3], r3 == t3 - 1) {
                if (s2 >= xT(256, 5 - t3))
                  return null;
              } else if (s2 > 255)
                return null;
            for (a2 = HT(i3), r3 = 0; r3 < i3.length; r3++)
              a2 += i3[r3] * xT(256, 3 - r3);
            return a2;
          }(e2), null === t2)
            return QT;
          this.host = t2;
        } else {
          if (UT(sE, e2))
            return QT;
          for (t2 = "", i2 = ET(e2), r2 = 0; r2 < i2.length; r2++)
            t2 += _E(i2[r2], uE);
          this.host = t2;
        }
      }, cannotHaveUsernamePasswordPort: function() {
        return !this.host || this.cannotBeABaseURL || "file" == this.scheme;
      }, includesCredentials: function() {
        return "" != this.username || "" != this.password;
      }, isSpecial: function() {
        return gT(fE, this.scheme);
      }, shortenPath: function() {
        var e2 = this.path, t2 = e2.length;
        !t2 || "file" == this.scheme && 1 == t2 && gE(e2[0], true) || e2.length--;
      }, serialize: function() {
        var e2 = this, t2 = e2.scheme, i2 = e2.username, r2 = e2.password, n2 = e2.host, o2 = e2.port, s2 = e2.path, a2 = e2.query, c2 = e2.fragment, l2 = t2 + ":";
        return null !== n2 ? (l2 += "//", e2.includesCredentials() && (l2 += i2 + (r2 ? ":" + r2 : "") + "@"), l2 += dE(n2), null !== o2 && (l2 += ":" + o2)) : "file" == t2 && (l2 += "//"), l2 += e2.cannotBeABaseURL ? s2[0] : s2.length ? "/" + FT(s2, "/") : "", null !== a2 && (l2 += "?" + a2), null !== c2 && (l2 += "#" + c2), l2;
      }, setHref: function(e2) {
        var t2 = this.parse(e2);
        if (t2)
          throw PT(t2);
        this.searchParams.update();
      }, getOrigin: function() {
        var e2 = this.scheme, t2 = this.port;
        if ("blob" == e2)
          try {
            return new jE(e2.path[0]).origin;
          } catch (EF) {
            return "null";
          }
        return "file" != e2 && this.isSpecial() ? e2 + "://" + dE(this.host) + (null !== t2 ? ":" + t2 : "") : "null";
      }, getProtocol: function() {
        return this.scheme + ":";
      }, setProtocol: function(e2) {
        this.parse(yT(e2) + ":", SE);
      }, getUsername: function() {
        return this.username;
      }, setUsername: function(e2) {
        var t2 = ET(yT(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.username = "";
          for (var i2 = 0; i2 < t2.length; i2++)
            this.username += _E(t2[i2], mE);
        }
      }, getPassword: function() {
        return this.password;
      }, setPassword: function(e2) {
        var t2 = ET(yT(e2));
        if (!this.cannotHaveUsernamePasswordPort()) {
          this.password = "";
          for (var i2 = 0; i2 < t2.length; i2++)
            this.password += _E(t2[i2], mE);
        }
      }, getHost: function() {
        var e2 = this.host, t2 = this.port;
        return null === e2 ? "" : null === t2 ? dE(e2) : dE(e2) + ":" + t2;
      }, setHost: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, DE);
      }, getHostname: function() {
        var e2 = this.host;
        return null === e2 ? "" : dE(e2);
      }, setHostname: function(e2) {
        this.cannotBeABaseURL || this.parse(e2, wE);
      }, getPort: function() {
        var e2 = this.port;
        return null === e2 ? "" : yT(e2);
      }, setPort: function(e2) {
        this.cannotHaveUsernamePasswordPort() || ("" == (e2 = yT(e2)) ? this.port = null : this.parse(e2, OE));
      }, getPathname: function() {
        var e2 = this.path;
        return this.cannotBeABaseURL ? e2[0] : e2.length ? "/" + FT(e2, "/") : "";
      }, setPathname: function(e2) {
        this.cannotBeABaseURL || (this.path = [], this.parse(e2, xE));
      }, getSearch: function() {
        var e2 = this.query;
        return e2 ? "?" + e2 : "";
      }, setSearch: function(e2) {
        "" == (e2 = yT(e2)) ? this.query = null : ("?" == VT(e2, 0) && (e2 = KT(e2, 1)), this.query = "", this.parse(e2, FE)), this.searchParams.update();
      }, getSearchParams: function() {
        return this.searchParams.facade;
      }, getHash: function() {
        var e2 = this.fragment;
        return e2 ? "#" + e2 : "";
      }, setHash: function(e2) {
        "" != (e2 = yT(e2)) ? ("#" == VT(e2, 0) && (e2 = KT(e2, 1)), this.fragment = "", this.parse(e2, BE)) : this.fragment = null;
      }, update: function() {
        this.query = this.searchParams.serialize() || null;
      } };
      var jE = function(e2) {
        var t2 = fT(this, GE), i2 = RT(arguments.length, 1) > 1 ? arguments[1] : void 0, r2 = kT(t2, new HE(e2, false, i2));
        lT || (t2.href = r2.serialize(), t2.origin = r2.getOrigin(), t2.protocol = r2.getProtocol(), t2.username = r2.getUsername(), t2.password = r2.getPassword(), t2.host = r2.getHost(), t2.hostname = r2.getHostname(), t2.port = r2.getPort(), t2.pathname = r2.getPathname(), t2.search = r2.getSearch(), t2.searchParams = r2.getSearchParams(), t2.hash = r2.getHash());
      }, GE = jE.prototype, WE = function(e2, t2) {
        return { get: function() {
          return NT(this)[e2]();
        }, set: t2 && function(e3) {
          return NT(this)[t2](e3);
        }, configurable: true, enumerable: true };
      };
      if (lT && (_T(GE, "href", WE("serialize", "setHref")), _T(GE, "origin", WE("getOrigin")), _T(GE, "protocol", WE("getProtocol", "setProtocol")), _T(GE, "username", WE("getUsername", "setUsername")), _T(GE, "password", WE("getPassword", "setPassword")), _T(GE, "host", WE("getHost", "setHost")), _T(GE, "hostname", WE("getHostname", "setHostname")), _T(GE, "port", WE("getPort", "setPort")), _T(GE, "pathname", WE("getPathname", "setPathname")), _T(GE, "search", WE("getSearch", "setSearch")), _T(GE, "searchParams", WE("getSearchParams")), _T(GE, "hash", WE("getHash", "setHash"))), mT(GE, "toJSON", function() {
        return NT(this).serialize();
      }, { enumerable: true }), mT(GE, "toString", function() {
        return NT(this).serialize();
      }, { enumerable: true }), OT) {
        var JE = OT.createObjectURL, KE = OT.revokeObjectURL;
        JE && mT(jE, "createObjectURL", hT(JE, OT)), KE && mT(jE, "revokeObjectURL", hT(KE, OT));
      }
      AT(jE, "URL"), cT({ global: true, constructor: true, forced: !dT, sham: !lT }, { URL: jE });
      var zE = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView, qE = Mt, YE = Ht, QE = RangeError, XE = function(e2) {
        if (void 0 === e2)
          return 0;
        var t2 = qE(e2), i2 = YE(t2);
        if (t2 !== i2)
          throw QE("Wrong length or index");
        return i2;
      }, $E = Array, ZE = Math.abs, eS = Math.pow, tS = Math.floor, iS = Math.log, rS = Math.LN2, nS = { pack: function(e2, t2, i2) {
        var r2, n2, o2, s2 = $E(i2), a2 = 8 * i2 - t2 - 1, c2 = (1 << a2) - 1, l2 = c2 >> 1, d2 = 23 === t2 ? eS(2, -24) - eS(2, -77) : 0, u2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0, h2 = 0;
        for ((e2 = ZE(e2)) != e2 || Infinity === e2 ? (n2 = e2 != e2 ? 1 : 0, r2 = c2) : (r2 = tS(iS(e2) / rS), e2 * (o2 = eS(2, -r2)) < 1 && (r2--, o2 *= 2), (e2 += r2 + l2 >= 1 ? d2 / o2 : d2 * eS(2, 1 - l2)) * o2 >= 2 && (r2++, o2 /= 2), r2 + l2 >= c2 ? (n2 = 0, r2 = c2) : r2 + l2 >= 1 ? (n2 = (e2 * o2 - 1) * eS(2, t2), r2 += l2) : (n2 = e2 * eS(2, l2 - 1) * eS(2, t2), r2 = 0)); t2 >= 8; )
          s2[h2++] = 255 & n2, n2 /= 256, t2 -= 8;
        for (r2 = r2 << t2 | n2, a2 += t2; a2 > 0; )
          s2[h2++] = 255 & r2, r2 /= 256, a2 -= 8;
        return s2[--h2] |= 128 * u2, s2;
      }, unpack: function(e2, t2) {
        var i2, r2 = e2.length, n2 = 8 * r2 - t2 - 1, o2 = (1 << n2) - 1, s2 = o2 >> 1, a2 = n2 - 7, c2 = r2 - 1, l2 = e2[c2--], d2 = 127 & l2;
        for (l2 >>= 7; a2 > 0; )
          d2 = 256 * d2 + e2[c2--], a2 -= 8;
        for (i2 = d2 & (1 << -a2) - 1, d2 >>= -a2, a2 += t2; a2 > 0; )
          i2 = 256 * i2 + e2[c2--], a2 -= 8;
        if (0 === d2)
          d2 = 1 - s2;
        else {
          if (d2 === o2)
            return i2 ? NaN : l2 ? -Infinity : Infinity;
          i2 += eS(2, t2), d2 -= s2;
        }
        return (l2 ? -1 : 1) * i2 * eS(2, d2 - t2);
      } }, oS = B, sS = Ut, aS = Gt, cS = function(e2) {
        for (var t2 = oS(this), i2 = aS(t2), r2 = arguments.length, n2 = sS(r2 > 1 ? arguments[1] : void 0, i2), o2 = r2 > 2 ? arguments[2] : void 0, s2 = void 0 === o2 ? i2 : sS(o2, i2); s2 > n2; )
          t2[n2++] = e2;
        return t2;
      }, lS = C, dS = c, uS = ke, hS = zE, pS = Nr, mS = zi, _S = Is, fS = $m, gS = i, TS = Ns, ES = Mt, SS = Ht, IS = XE, vS = nS, yS = Kn, AS = vo, RS = rn.f, CS = cS, bS = c_, kS = oo, NS = ar, DS = pS.PROPER, wS = pS.CONFIGURABLE, OS = "ArrayBuffer", PS = "DataView", MS = "prototype", LS = "Wrong index", xS = NS.getterFor(OS), VS = NS.getterFor(PS), US = NS.set, FS = lS[OS], BS = FS, HS = BS && BS[MS], jS = lS[PS], GS = jS && jS[MS], WS = Object.prototype, JS = lS.Array, KS = lS.RangeError, zS = dS(CS), qS = dS([].reverse), YS = vS.pack, QS = vS.unpack, XS = function(e2) {
        return [255 & e2];
      }, $S = function(e2) {
        return [255 & e2, e2 >> 8 & 255];
      }, ZS = function(e2) {
        return [255 & e2, e2 >> 8 & 255, e2 >> 16 & 255, e2 >> 24 & 255];
      }, eI = function(e2) {
        return e2[3] << 24 | e2[2] << 16 | e2[1] << 8 | e2[0];
      }, tI = function(e2) {
        return YS(e2, 23, 4);
      }, iI = function(e2) {
        return YS(e2, 52, 8);
      }, rI = function(e2, t2, i2) {
        _S(e2[MS], t2, { configurable: true, get: function() {
          return i2(this)[t2];
        } });
      }, nI = function(e2, t2, i2, r2) {
        var n2 = IS(i2), o2 = VS(e2);
        if (n2 + t2 > o2.byteLength)
          throw KS(LS);
        var s2 = o2.bytes, a2 = n2 + o2.byteOffset, c2 = bS(s2, a2, a2 + t2);
        return r2 ? c2 : qS(c2);
      }, oI = function(e2, t2, i2, r2, n2, o2) {
        var s2 = IS(i2), a2 = VS(e2);
        if (s2 + t2 > a2.byteLength)
          throw KS(LS);
        for (var c2 = a2.bytes, l2 = s2 + a2.byteOffset, d2 = r2(+n2), u2 = 0; u2 < t2; u2++)
          c2[l2 + u2] = d2[o2 ? u2 : t2 - u2 - 1];
      };
      if (hS) {
        var sI = DS && FS.name !== OS;
        if (gS(function() {
          FS(1);
        }) && gS(function() {
          new FS(-1);
        }) && !gS(function() {
          return new FS(), new FS(1.5), new FS(NaN), 1 != FS.length || sI && !wS;
        }))
          sI && wS && mS(FS, "name", OS);
        else {
          (BS = function(e2) {
            return TS(this, HS), new FS(IS(e2));
          })[MS] = HS;
          for (var aI, cI = RS(FS), lI = 0; cI.length > lI; )
            (aI = cI[lI++]) in BS || mS(BS, aI, FS[aI]);
          HS.constructor = BS;
        }
        AS && yS(GS) !== WS && AS(GS, WS);
        var dI = new jS(new BS(2)), uI = dS(GS.setInt8);
        dI.setInt8(0, 2147483648), dI.setInt8(1, 2147483649), !dI.getInt8(0) && dI.getInt8(1) || fS(GS, { setInt8: function(e2, t2) {
          uI(this, e2, t2 << 24 >> 24);
        }, setUint8: function(e2, t2) {
          uI(this, e2, t2 << 24 >> 24);
        } }, { unsafe: true });
      } else
        HS = (BS = function(e2) {
          TS(this, HS);
          var t2 = IS(e2);
          US(this, { type: OS, bytes: zS(JS(t2), 0), byteLength: t2 }), uS || (this.byteLength = t2, this.detached = false);
        })[MS], GS = (jS = function(e2, t2, i2) {
          TS(this, GS), TS(e2, HS);
          var r2 = xS(e2), n2 = r2.byteLength, o2 = ES(t2);
          if (o2 < 0 || o2 > n2)
            throw KS("Wrong offset");
          if (o2 + (i2 = void 0 === i2 ? n2 - o2 : SS(i2)) > n2)
            throw KS("Wrong length");
          US(this, { type: PS, buffer: e2, byteLength: i2, byteOffset: o2, bytes: r2.bytes }), uS || (this.buffer = e2, this.byteLength = i2, this.byteOffset = o2);
        })[MS], uS && (rI(BS, "byteLength", xS), rI(jS, "buffer", VS), rI(jS, "byteLength", VS), rI(jS, "byteOffset", VS)), fS(GS, { getInt8: function(e2) {
          return nI(this, 1, e2)[0] << 24 >> 24;
        }, getUint8: function(e2) {
          return nI(this, 1, e2)[0];
        }, getInt16: function(e2) {
          var t2 = nI(this, 2, e2, arguments.length > 1 ? arguments[1] : void 0);
          return (t2[1] << 8 | t2[0]) << 16 >> 16;
        }, getUint16: function(e2) {
          var t2 = nI(this, 2, e2, arguments.length > 1 ? arguments[1] : void 0);
          return t2[1] << 8 | t2[0];
        }, getInt32: function(e2) {
          return eI(nI(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0));
        }, getUint32: function(e2) {
          return eI(nI(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
        }, getFloat32: function(e2) {
          return QS(nI(this, 4, e2, arguments.length > 1 ? arguments[1] : void 0), 23);
        }, getFloat64: function(e2) {
          return QS(nI(this, 8, e2, arguments.length > 1 ? arguments[1] : void 0), 52);
        }, setInt8: function(e2, t2) {
          oI(this, 1, e2, XS, t2);
        }, setUint8: function(e2, t2) {
          oI(this, 1, e2, XS, t2);
        }, setInt16: function(e2, t2) {
          oI(this, 2, e2, $S, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setUint16: function(e2, t2) {
          oI(this, 2, e2, $S, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setInt32: function(e2, t2) {
          oI(this, 4, e2, ZS, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setUint32: function(e2, t2) {
          oI(this, 4, e2, ZS, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setFloat32: function(e2, t2) {
          oI(this, 4, e2, tI, t2, arguments.length > 2 ? arguments[2] : void 0);
        }, setFloat64: function(e2, t2) {
          oI(this, 8, e2, iI, t2, arguments.length > 2 ? arguments[2] : void 0);
        } });
      kS(BS, OS), kS(jS, PS);
      var hI = { ArrayBuffer: BS, DataView: jS }, pI = Vn, mI = Ta, _I = i, fI = Ce, gI = Ut, TI = Ht, EI = da, SI = hI.ArrayBuffer, II = hI.DataView, vI = II.prototype, yI = mI(SI.prototype.slice), AI = mI(vI.getUint8), RI = mI(vI.setUint8);
      pI({ target: "ArrayBuffer", proto: true, unsafe: true, forced: _I(function() {
        return !new SI(2).slice(1, void 0).byteLength;
      }) }, { slice: function(e2, t2) {
        if (yI && void 0 === t2)
          return yI(fI(this), e2);
        for (var i2 = fI(this).byteLength, r2 = gI(e2, i2), n2 = gI(void 0 === t2 ? i2 : t2, i2), o2 = new (EI(this, SI))(TI(n2 - r2)), s2 = new II(this), a2 = new II(o2), c2 = 0; r2 < n2; )
          RI(a2, c2++, AI(s2, r2++));
        return o2;
      } });
      var CI, bI, kI, NI = {}, DI = { get exports() {
        return NI;
      }, set exports(e2) {
        NI = e2;
      } }, wI = zE, OI = ke, PI = C, MI = Ee, LI = ve, xI = G, VI = Vs, UI = Qe, FI = zi, BI = tn, HI = Is, jI = Ge, GI = Kn, WI = vo, JI = _e, KI = q, zI = ar.enforce, qI = ar.get, YI = PI.Int8Array, QI = YI && YI.prototype, XI = PI.Uint8ClampedArray, $I = XI && XI.prototype, ZI = YI && GI(YI), ev = QI && GI(QI), tv = Object.prototype, iv = PI.TypeError, rv = JI("toStringTag"), nv = KI("TYPED_ARRAY_TAG"), ov = "TypedArrayConstructor", sv = wI && !!WI && "Opera" !== VI(PI.opera), av = false, cv = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, lv = { BigInt64Array: 8, BigUint64Array: 8 }, dv = function(e2) {
        var t2 = GI(e2);
        if (LI(t2)) {
          var i2 = qI(t2);
          return i2 && xI(i2, ov) ? i2[ov] : dv(t2);
        }
      }, uv = function(e2) {
        if (!LI(e2))
          return false;
        var t2 = VI(e2);
        return xI(cv, t2) || xI(lv, t2);
      };
      for (CI in cv)
        (kI = (bI = PI[CI]) && bI.prototype) ? zI(kI)[ov] = bI : sv = false;
      for (CI in lv)
        (kI = (bI = PI[CI]) && bI.prototype) && (zI(kI)[ov] = bI);
      if ((!sv || !MI(ZI) || ZI === Function.prototype) && (ZI = function() {
        throw iv("Incorrect invocation");
      }, sv))
        for (CI in cv)
          PI[CI] && WI(PI[CI], ZI);
      if ((!sv || !ev || ev === tv) && (ev = ZI.prototype, sv))
        for (CI in cv)
          PI[CI] && WI(PI[CI].prototype, ev);
      if (sv && GI($I) !== ev && WI($I, ev), OI && !xI(ev, rv))
        for (CI in av = true, HI(ev, rv, { configurable: true, get: function() {
          return LI(this) ? this[nv] : void 0;
        } }), cv)
          PI[CI] && FI(PI[CI], nv, CI);
      var hv = { NATIVE_ARRAY_BUFFER_VIEWS: sv, TYPED_ARRAY_TAG: av && nv, aTypedArray: function(e2) {
        if (uv(e2))
          return e2;
        throw iv("Target is not a typed array");
      }, aTypedArrayConstructor: function(e2) {
        if (MI(e2) && (!WI || jI(ZI, e2)))
          return e2;
        throw iv(UI(e2) + " is not a typed array constructor");
      }, exportTypedArrayMethod: function(e2, t2, i2, r2) {
        if (OI) {
          if (i2)
            for (var n2 in cv) {
              var o2 = PI[n2];
              if (o2 && xI(o2.prototype, e2))
                try {
                  delete o2.prototype[e2];
                } catch (EF) {
                  try {
                    o2.prototype[e2] = t2;
                  } catch (s2) {
                  }
                }
            }
          ev[e2] && !i2 || BI(ev, e2, i2 ? t2 : sv && QI[e2] || t2, r2);
        }
      }, exportTypedArrayStaticMethod: function(e2, t2, i2) {
        var r2, n2;
        if (OI) {
          if (WI) {
            if (i2) {
              for (r2 in cv)
                if ((n2 = PI[r2]) && xI(n2, e2))
                  try {
                    delete n2[e2];
                  } catch (EF) {
                  }
            }
            if (ZI[e2] && !i2)
              return;
            try {
              return BI(ZI, e2, i2 ? t2 : sv && ZI[e2] || t2);
            } catch (EF) {
            }
          }
          for (r2 in cv)
            !(n2 = PI[r2]) || n2[e2] && !i2 || BI(n2, e2, t2);
        }
      }, getTypedArrayConstructor: dv, isView: function(e2) {
        if (!LI(e2))
          return false;
        var t2 = VI(e2);
        return "DataView" === t2 || xI(cv, t2) || xI(lv, t2);
      }, isTypedArray: uv, TypedArray: ZI, TypedArrayPrototype: ev }, pv = C, mv = i, _v = Dd, fv = hv.NATIVE_ARRAY_BUFFER_VIEWS, gv = pv.ArrayBuffer, Tv = pv.Int8Array, Ev = !fv || !mv(function() {
        Tv(1);
      }) || !mv(function() {
        new Tv(-1);
      }) || !_v(function(e2) {
        new Tv(), new Tv(null), new Tv(1.5), new Tv(e2);
      }, true) || mv(function() {
        return 1 !== new Tv(new gv(2), 1, void 0).length;
      }), Sv = ve, Iv = Math.floor, vv = Number.isInteger || function(e2) {
        return !Sv(e2) && isFinite(e2) && Iv(e2) === e2;
      }, yv = Mt, Av = RangeError, Rv = function(e2) {
        var t2 = yv(e2);
        if (t2 < 0)
          throw Av("The argument can't be less than 0");
        return t2;
      }, Cv = RangeError, bv = function(e2, t2) {
        var i2 = Rv(e2);
        if (i2 % t2)
          throw Cv("Wrong offset");
        return i2;
      }, kv = Vs, Nv = _t, Dv = TypeError, wv = function(e2) {
        var t2 = Nv(e2, "number");
        if ("number" == typeof t2)
          throw Dv("Can't convert number to bigint");
        return BigInt(t2);
      }, Ov = va, Pv = Fe, Mv = oa, Lv = B, xv = Gt, Vv = ad, Uv = ed, Fv = ql, Bv = function(e2) {
        var t2 = kv(e2);
        return "BigInt64Array" == t2 || "BigUint64Array" == t2;
      }, Hv = hv.aTypedArrayConstructor, jv = wv, Gv = function(e2) {
        var t2, i2, r2, n2, o2, s2, a2, c2, l2 = Mv(this), d2 = Lv(e2), u2 = arguments.length, h2 = u2 > 1 ? arguments[1] : void 0, p2 = void 0 !== h2, m2 = Uv(d2);
        if (m2 && !Fv(m2))
          for (c2 = (a2 = Vv(d2, m2)).next, d2 = []; !(s2 = Pv(c2, a2)).done; )
            d2.push(s2.value);
        for (p2 && u2 > 2 && (h2 = Ov(h2, arguments[2])), i2 = xv(d2), r2 = new (Hv(l2))(i2), n2 = Bv(r2), t2 = 0; i2 > t2; t2++)
          o2 = p2 ? h2(d2[t2], t2) : d2[t2], r2[t2] = n2 ? jv(o2) : +o2;
        return r2;
      }, Wv = Vn, Jv = C, Kv = Fe, zv = ke, qv = Ev, Yv = hv, Qv = hI, Xv = Ns, $v = Wi, Zv = zi, ey = vv, ty = Ht, iy = XE, ry = bv, ny = Tt, oy = G, sy = Vs, ay = ve, cy = qe, ly = Di, dy = Ge, uy = vo, hy = rn.f, py = Gv, my = np.forEach, _y = Cs, fy = Is, gy = De, Ty = cr, Ey = lu, Sy = ar.get, Iy = ar.set, vy = ar.enforce, yy = gy.f, Ay = Ty.f, Ry = Math.round, Cy = Jv.RangeError, by = Qv.ArrayBuffer, ky = by.prototype, Ny = Qv.DataView, Dy = Yv.NATIVE_ARRAY_BUFFER_VIEWS, wy = Yv.TYPED_ARRAY_TAG, Oy = Yv.TypedArray, Py = Yv.TypedArrayPrototype, My = Yv.aTypedArrayConstructor, Ly = Yv.isTypedArray, xy = "BYTES_PER_ELEMENT", Vy = "Wrong length", Uy = function(e2, t2) {
        My(e2);
        for (var i2 = 0, r2 = t2.length, n2 = new e2(r2); r2 > i2; )
          n2[i2] = t2[i2++];
        return n2;
      }, Fy = function(e2, t2) {
        fy(e2, t2, { configurable: true, get: function() {
          return Sy(this)[t2];
        } });
      }, By = function(e2) {
        var t2;
        return dy(ky, e2) || "ArrayBuffer" == (t2 = sy(e2)) || "SharedArrayBuffer" == t2;
      }, Hy = function(e2, t2) {
        return Ly(e2) && !cy(t2) && t2 in e2 && ey(+t2) && t2 >= 0;
      }, jy = function(e2, t2) {
        return t2 = ny(t2), Hy(e2, t2) ? $v(2, e2[t2]) : Ay(e2, t2);
      }, Gy = function(e2, t2, i2) {
        return t2 = ny(t2), !(Hy(e2, t2) && ay(i2) && oy(i2, "value")) || oy(i2, "get") || oy(i2, "set") || i2.configurable || oy(i2, "writable") && !i2.writable || oy(i2, "enumerable") && !i2.enumerable ? yy(e2, t2, i2) : (e2[t2] = i2.value, e2);
      };
      zv ? (Dy || (Ty.f = jy, gy.f = Gy, Fy(Py, "buffer"), Fy(Py, "byteOffset"), Fy(Py, "byteLength"), Fy(Py, "length")), Wv({ target: "Object", stat: true, forced: !Dy }, { getOwnPropertyDescriptor: jy, defineProperty: Gy }), DI.exports = function(e2, t2, i2) {
        var r2 = e2.match(/\d+/)[0] / 8, n2 = e2 + (i2 ? "Clamped" : "") + "Array", o2 = "get" + e2, s2 = "set" + e2, a2 = Jv[n2], c2 = a2, l2 = c2 && c2.prototype, d2 = {}, u2 = function(e3, t3) {
          yy(e3, t3, { get: function() {
            return function(e4, t4) {
              var i3 = Sy(e4);
              return i3.view[o2](t4 * r2 + i3.byteOffset, true);
            }(this, t3);
          }, set: function(e4) {
            return function(e5, t4, n3) {
              var o3 = Sy(e5);
              i2 && (n3 = (n3 = Ry(n3)) < 0 ? 0 : n3 > 255 ? 255 : 255 & n3), o3.view[s2](t4 * r2 + o3.byteOffset, n3, true);
            }(this, t3, e4);
          }, enumerable: true });
        };
        Dy ? qv && (c2 = t2(function(e3, t3, i3, n3) {
          return Xv(e3, l2), Ey(ay(t3) ? By(t3) ? void 0 !== n3 ? new a2(t3, ry(i3, r2), n3) : void 0 !== i3 ? new a2(t3, ry(i3, r2)) : new a2(t3) : Ly(t3) ? Uy(c2, t3) : Kv(py, c2, t3) : new a2(iy(t3)), e3, c2);
        }), uy && uy(c2, Oy), my(hy(a2), function(e3) {
          e3 in c2 || Zv(c2, e3, a2[e3]);
        }), c2.prototype = l2) : (c2 = t2(function(e3, t3, i3, n3) {
          Xv(e3, l2);
          var o3, s3, a3, d3 = 0, h3 = 0;
          if (ay(t3)) {
            if (!By(t3))
              return Ly(t3) ? Uy(c2, t3) : Kv(py, c2, t3);
            o3 = t3, h3 = ry(i3, r2);
            var p2 = t3.byteLength;
            if (void 0 === n3) {
              if (p2 % r2)
                throw Cy(Vy);
              if ((s3 = p2 - h3) < 0)
                throw Cy(Vy);
            } else if ((s3 = ty(n3) * r2) + h3 > p2)
              throw Cy(Vy);
            a3 = s3 / r2;
          } else
            a3 = iy(t3), o3 = new by(s3 = a3 * r2);
          for (Iy(e3, { buffer: o3, byteOffset: h3, byteLength: s3, length: a3, view: new Ny(o3) }); d3 < a3; )
            u2(e3, d3++);
        }), uy && uy(c2, Oy), l2 = c2.prototype = ly(Py)), l2.constructor !== c2 && Zv(l2, "constructor", c2), vy(l2).TypedArrayConstructor = c2, wy && Zv(l2, wy, n2);
        var h2 = c2 != a2;
        d2[n2] = c2, Wv({ global: true, constructor: true, forced: h2, sham: !Dy }, d2), xy in c2 || Zv(c2, xy, r2), xy in l2 || Zv(l2, xy, r2), _y(n2);
      }) : DI.exports = function() {
      }, NI("Uint8", function(e2) {
        return function(t2, i2, r2) {
          return e2(this, t2, i2, r2);
        };
      });
      var Wy = cS, Jy = wv, Ky = Vs, zy = Fe, qy = i, Yy = hv.aTypedArray, Qy = hv.exportTypedArrayMethod, Xy = c("".slice);
      Qy("fill", function(e2) {
        var t2 = arguments.length;
        Yy(this);
        var i2 = "Big" === Xy(Ky(this), 0, 3) ? Jy(e2) : +e2;
        return zy(Wy, this, i2, t2 > 1 ? arguments[1] : void 0, t2 > 2 ? arguments[2] : void 0);
      }, qy(function() {
        var e2 = 0;
        return new Int8Array(2).fill({ valueOf: function() {
          return e2++;
        } }), 1 !== e2;
      }));
      var $y = C, Zy = Fe, eA = hv, tA = Gt, iA = bv, rA = B, nA = i, oA = $y.RangeError, sA = $y.Int8Array, aA = sA && sA.prototype, cA = aA && aA.set, lA = eA.aTypedArray, dA = eA.exportTypedArrayMethod, uA = !nA(function() {
        var e2 = new Uint8ClampedArray(2);
        return Zy(cA, e2, { length: 1, 0: 3 }, 1), 3 !== e2[1];
      }), hA = uA && eA.NATIVE_ARRAY_BUFFER_VIEWS && nA(function() {
        var e2 = new sA(2);
        return e2.set(1), e2.set("2", 1), 0 !== e2[0] || 2 !== e2[1];
      });
      dA("set", function(e2) {
        lA(this);
        var t2 = iA(arguments.length > 1 ? arguments[1] : void 0, 1), i2 = rA(e2);
        if (uA)
          return Zy(cA, this, i2, t2);
        var r2 = this.length, n2 = tA(i2), o2 = 0;
        if (n2 + t2 > r2)
          throw oA("Wrong length");
        for (; o2 < n2; )
          this[t2 + o2] = i2[o2++];
      }, !uA || hA);
      var pA = Y.match(/firefox\/(\d+)/i), mA = !!pA && +pA[1], _A = /MSIE|Trident/.test(Y), fA = Y.match(/AppleWebKit\/(\d+)\./), gA = !!fA && +fA[1], TA = Ta, EA = i, SA = et, IA = m_, vA = mA, yA = _A, AA = ie, RA = gA, CA = hv.aTypedArray, bA = hv.exportTypedArrayMethod, kA = C.Uint16Array, NA = kA && TA(kA.prototype.sort), DA = !(!NA || EA(function() {
        NA(new kA(2), null);
      }) && EA(function() {
        NA(new kA(2), {});
      })), wA = !!NA && !EA(function() {
        if (AA)
          return AA < 74;
        if (vA)
          return vA < 67;
        if (yA)
          return true;
        if (RA)
          return RA < 602;
        var e2, t2, i2 = new kA(516), r2 = Array(516);
        for (e2 = 0; e2 < 516; e2++)
          t2 = e2 % 4, i2[e2] = 515 - e2, r2[e2] = e2 - 2 * t2 + 3;
        for (NA(i2, function(e3, t3) {
          return (e3 / 4 | 0) - (t3 / 4 | 0);
        }), e2 = 0; e2 < 516; e2++)
          if (i2[e2] !== r2[e2])
            return true;
      });
      bA("sort", function(e2) {
        return void 0 !== e2 && SA(e2), wA ? NA(this, e2) : IA(CA(this), /* @__PURE__ */ function(e3) {
          return function(t2, i2) {
            return void 0 !== e3 ? +e3(t2, i2) || 0 : i2 != i2 ? -1 : t2 != t2 ? 1 : 0 === t2 && 0 === i2 ? 1 / t2 > 0 && 1 / i2 < 0 ? 1 : -1 : t2 > i2;
          };
        }(e2));
      }, !wA || DA);
      var OA = Vn, PA = kc, MA = i, LA = je, xA = Ee, VA = da, UA = iu, FA = tn, BA = PA && PA.prototype;
      if (OA({ target: "Promise", proto: true, real: true, forced: !!PA && MA(function() {
        BA.finally.call({ then: function() {
        } }, function() {
        });
      }) }, { finally: function(e2) {
        var t2 = VA(this, LA("Promise")), i2 = xA(e2);
        return this.then(i2 ? function(i3) {
          return UA(t2, e2()).then(function() {
            return i3;
          });
        } : e2, i2 ? function(i3) {
          return UA(t2, e2()).then(function() {
            throw i3;
          });
        } : e2);
      } }), xA(PA)) {
        var HA = LA("Promise").prototype.finally;
        BA.finally !== HA && FA(BA, "finally", HA, { unsafe: true });
      }
      var jA = Cs, GA = "ArrayBuffer", WA = hI[GA];
      Vn({ global: true, constructor: true, forced: C[GA] !== WA }, { ArrayBuffer: WA }), jA(GA);
      var JA = Qe, KA = TypeError, zA = Vn, qA = c, YA = et, QA = B, XA = Gt, $A = function(e2, t2) {
        if (!delete e2[t2])
          throw KA("Cannot delete property " + JA(t2) + " of " + JA(e2));
      }, ZA = fu, eR = i, tR = m_, iR = sp, rR = mA, nR = _A, oR = ie, sR = gA, aR = [], cR = qA(aR.sort), lR = qA(aR.push), dR = eR(function() {
        aR.sort(void 0);
      }), uR = eR(function() {
        aR.sort(null);
      }), hR = iR("sort"), pR = !eR(function() {
        if (oR)
          return oR < 70;
        if (!(rR && rR > 3)) {
          if (nR)
            return true;
          if (sR)
            return sR < 603;
          var e2, t2, i2, r2, n2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t2 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                i2 = 3;
                break;
              case 68:
              case 71:
                i2 = 4;
                break;
              default:
                i2 = 2;
            }
            for (r2 = 0; r2 < 47; r2++)
              aR.push({ k: t2 + r2, v: i2 });
          }
          for (aR.sort(function(e3, t3) {
            return t3.v - e3.v;
          }), r2 = 0; r2 < aR.length; r2++)
            t2 = aR[r2].k.charAt(0), n2.charAt(n2.length - 1) !== t2 && (n2 += t2);
          return "DGBEFHACIJK" !== n2;
        }
      });
      zA({ target: "Array", proto: true, forced: dR || !uR || !hR || !pR }, { sort: function(e2) {
        void 0 !== e2 && YA(e2);
        var t2 = QA(this);
        if (pR)
          return void 0 === e2 ? cR(t2) : cR(t2, e2);
        var i2, r2, n2 = [], o2 = XA(t2);
        for (r2 = 0; r2 < o2; r2++)
          r2 in t2 && lR(n2, t2[r2]);
        for (tR(n2, /* @__PURE__ */ function(e3) {
          return function(t3, i3) {
            return void 0 === i3 ? -1 : void 0 === t3 ? 1 : void 0 !== e3 ? +e3(t3, i3) || 0 : ZA(t3) > ZA(i3) ? 1 : -1;
          };
        }(e2)), i2 = XA(n2), r2 = 0; r2 < i2; )
          t2[r2] = n2[r2++];
        for (; r2 < o2; )
          $A(t2, r2++);
        return t2;
      } }), NI("Float32", function(e2) {
        return function(t2, i2, r2) {
          return e2(this, t2, i2, r2);
        };
      });
      var mR = Vn, _R = Wh, fR = c([].reverse), gR = [1, 2];
      mR({ target: "Array", proto: true, forced: String(gR) === String(gR.reverse()) }, { reverse: function() {
        return _R(this) && (this.length = this.length), fR(this);
      } });
      var TR = Vn, ER = Fe, SR = c, IR = I, vR = Ee, yR = T, AR = pu, RR = fu, CR = rt, bR = Au, kR = Yp, NR = _e("replace"), DR = TypeError, wR = SR("".indexOf);
      SR("".replace);
      var OR = SR("".slice), PR = Math.max, MR = function(e2, t2, i2) {
        return i2 > e2.length ? -1 : "" === t2 ? i2 : wR(e2, t2, i2);
      };
      TR({ target: "String", proto: true }, { replaceAll: function(e2, t2) {
        var i2, r2, n2, o2, s2, a2, c2, l2, d2 = IR(this), u2 = 0, h2 = 0, p2 = "";
        if (!yR(e2)) {
          if (AR(e2) && (i2 = RR(IR(bR(e2))), !~wR(i2, "g")))
            throw DR("`.replaceAll` does not allow non-global regexes");
          if (r2 = CR(e2, NR))
            return ER(r2, e2, d2, t2);
        }
        for (n2 = RR(d2), o2 = RR(e2), (s2 = vR(t2)) || (t2 = RR(t2)), a2 = o2.length, c2 = PR(1, a2), u2 = MR(n2, o2, 0); -1 !== u2; )
          l2 = s2 ? RR(t2(o2, u2, n2)) : kR(o2, n2, u2, [], void 0, t2), p2 += OR(n2, h2, u2) + l2, h2 = u2 + a2, u2 = MR(n2, o2, u2 + c2);
        return h2 < n2.length && (p2 += OR(n2, h2)), p2;
      } }), (0, hv.exportTypedArrayStaticMethod)("from", Gv, Ev);
      let LR = true, xR = true;
      function VR(e2, t2, i2) {
        const r2 = e2.match(t2);
        return r2 && r2.length >= i2 && parseInt(r2[i2], 10);
      }
      function UR(e2, t2, i2) {
        if (!e2.RTCPeerConnection)
          return;
        const r2 = e2.RTCPeerConnection.prototype, n2 = r2.addEventListener;
        r2.addEventListener = function(e3, r3) {
          if (e3 !== t2)
            return n2.apply(this, arguments);
          const o3 = (e4) => {
            const t3 = i2(e4);
            t3 && (r3.handleEvent ? r3.handleEvent(t3) : r3(t3));
          };
          return this._eventMap = this._eventMap || {}, this._eventMap[t2] || (this._eventMap[t2] = /* @__PURE__ */ new Map()), this._eventMap[t2].set(r3, o3), n2.apply(this, [e3, o3]);
        };
        const o2 = r2.removeEventListener;
        r2.removeEventListener = function(e3, i3) {
          if (e3 !== t2 || !this._eventMap || !this._eventMap[t2])
            return o2.apply(this, arguments);
          if (!this._eventMap[t2].has(i3))
            return o2.apply(this, arguments);
          const r3 = this._eventMap[t2].get(i3);
          return this._eventMap[t2].delete(i3), 0 === this._eventMap[t2].size && delete this._eventMap[t2], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o2.apply(this, [e3, r3]);
        }, Object.defineProperty(r2, "on" + t2, { get() {
          return this["_on" + t2];
        }, set(e3) {
          this["_on" + t2] && (this.removeEventListener(t2, this["_on" + t2]), delete this["_on" + t2]), e3 && this.addEventListener(t2, this["_on" + t2] = e3);
        }, enumerable: true, configurable: true });
      }
      function FR(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (LR = e2, e2 ? "adapter.js logging disabled" : "adapter.js logging enabled");
      }
      function BR(e2) {
        return "boolean" != typeof e2 ? new Error("Argument type: " + typeof e2 + ". Please use a boolean.") : (xR = !e2, "adapter.js deprecation warnings " + (e2 ? "disabled" : "enabled"));
      }
      function HR() {
        if ("object" == typeof window) {
          if (LR)
            return;
          "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments);
        }
      }
      function jR(e2, t2) {
        xR && console.warn(e2 + " is deprecated, please use " + t2 + " instead.");
      }
      function GR(e2) {
        return "[object Object]" === Object.prototype.toString.call(e2);
      }
      function WR(e2) {
        return GR(e2) ? Object.keys(e2).reduce(function(t2, i2) {
          const r2 = GR(e2[i2]), n2 = r2 ? WR(e2[i2]) : e2[i2], o2 = r2 && !Object.keys(n2).length;
          return void 0 === n2 || o2 ? t2 : Object.assign(t2, { [i2]: n2 });
        }, {}) : e2;
      }
      function JR(e2, t2, i2) {
        t2 && !i2.has(t2.id) && (i2.set(t2.id, t2), Object.keys(t2).forEach((r2) => {
          r2.endsWith("Id") ? JR(e2, e2.get(t2[r2]), i2) : r2.endsWith("Ids") && t2[r2].forEach((t3) => {
            JR(e2, e2.get(t3), i2);
          });
        }));
      }
      function KR(e2, t2, i2) {
        const r2 = i2 ? "outbound-rtp" : "inbound-rtp", n2 = /* @__PURE__ */ new Map();
        if (null === t2)
          return n2;
        const o2 = [];
        return e2.forEach((e3) => {
          "track" === e3.type && e3.trackIdentifier === t2.id && o2.push(e3);
        }), o2.forEach((t3) => {
          e2.forEach((i3) => {
            i3.type === r2 && i3.trackId === t3.id && JR(e2, i3, n2);
          });
        }), n2;
      }
      const zR = HR;
      function qR(e2, t2) {
        const i2 = e2 && e2.navigator;
        if (!i2.mediaDevices)
          return;
        const r2 = function(e3) {
          if ("object" != typeof e3 || e3.mandatory || e3.optional)
            return e3;
          const t3 = {};
          return Object.keys(e3).forEach((i3) => {
            if ("require" === i3 || "advanced" === i3 || "mediaSource" === i3)
              return;
            const r3 = "object" == typeof e3[i3] ? e3[i3] : { ideal: e3[i3] };
            void 0 !== r3.exact && "number" == typeof r3.exact && (r3.min = r3.max = r3.exact);
            const n3 = function(e4, t4) {
              return e4 ? e4 + t4.charAt(0).toUpperCase() + t4.slice(1) : "deviceId" === t4 ? "sourceId" : t4;
            };
            if (void 0 !== r3.ideal) {
              t3.optional = t3.optional || [];
              let e4 = {};
              "number" == typeof r3.ideal ? (e4[n3("min", i3)] = r3.ideal, t3.optional.push(e4), e4 = {}, e4[n3("max", i3)] = r3.ideal, t3.optional.push(e4)) : (e4[n3("", i3)] = r3.ideal, t3.optional.push(e4));
            }
            void 0 !== r3.exact && "number" != typeof r3.exact ? (t3.mandatory = t3.mandatory || {}, t3.mandatory[n3("", i3)] = r3.exact) : ["min", "max"].forEach((e4) => {
              void 0 !== r3[e4] && (t3.mandatory = t3.mandatory || {}, t3.mandatory[n3(e4, i3)] = r3[e4]);
            });
          }), e3.advanced && (t3.optional = (t3.optional || []).concat(e3.advanced)), t3;
        }, n2 = function(e3, n3) {
          if (t2.version >= 61)
            return n3(e3);
          if ((e3 = JSON.parse(JSON.stringify(e3))) && "object" == typeof e3.audio) {
            const t3 = function(e4, t4, i3) {
              t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
            };
            t3((e3 = JSON.parse(JSON.stringify(e3))).audio, "autoGainControl", "googAutoGainControl"), t3(e3.audio, "noiseSuppression", "googNoiseSuppression"), e3.audio = r2(e3.audio);
          }
          if (e3 && "object" == typeof e3.video) {
            let o3 = e3.video.facingMode;
            o3 = o3 && ("object" == typeof o3 ? o3 : { ideal: o3 });
            const s2 = t2.version < 66;
            if (o3 && ("user" === o3.exact || "environment" === o3.exact || "user" === o3.ideal || "environment" === o3.ideal) && (!i2.mediaDevices.getSupportedConstraints || !i2.mediaDevices.getSupportedConstraints().facingMode || s2)) {
              let t3;
              if (delete e3.video.facingMode, "environment" === o3.exact || "environment" === o3.ideal ? t3 = ["back", "rear"] : "user" !== o3.exact && "user" !== o3.ideal || (t3 = ["front"]), t3)
                return i2.mediaDevices.enumerateDevices().then((i3) => {
                  let s3 = (i3 = i3.filter((e4) => "videoinput" === e4.kind)).find((e4) => t3.some((t4) => e4.label.toLowerCase().includes(t4)));
                  return !s3 && i3.length && t3.includes("back") && (s3 = i3[i3.length - 1]), s3 && (e3.video.deviceId = o3.exact ? { exact: s3.deviceId } : { ideal: s3.deviceId }), e3.video = r2(e3.video), zR("chrome: " + JSON.stringify(e3)), n3(e3);
                });
            }
            e3.video = r2(e3.video);
          }
          return zR("chrome: " + JSON.stringify(e3)), n3(e3);
        }, o2 = function(e3) {
          return t2.version >= 64 ? e3 : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e3.name] || e3.name, message: e3.message, constraint: e3.constraint || e3.constraintName, toString() {
            return this.name + (this.message && ": ") + this.message;
          } };
        };
        if (i2.getUserMedia = (function(e3, t3, r3) {
          n2(e3, (e4) => {
            i2.webkitGetUserMedia(e4, t3, (e5) => {
              r3 && r3(o2(e5));
            });
          });
        }).bind(i2), i2.mediaDevices.getUserMedia) {
          const e3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          i2.mediaDevices.getUserMedia = function(t3) {
            return n2(t3, (t4) => e3(t4).then((e4) => {
              if (t4.audio && !e4.getAudioTracks().length || t4.video && !e4.getVideoTracks().length)
                throw e4.getTracks().forEach((e5) => {
                  e5.stop();
                }), new DOMException("", "NotFoundError");
              return e4;
            }, (e4) => Promise.reject(o2(e4))));
          };
        }
      }
      function YR(e2) {
        e2.MediaStream = e2.MediaStream || e2.webkitMediaStream;
      }
      function QR(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("ontrack" in e2.RTCPeerConnection.prototype)) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "ontrack", { get() {
            return this._ontrack;
          }, set(e3) {
            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e3);
          }, enumerable: true, configurable: true });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            return this._ontrackpoly || (this._ontrackpoly = (t3) => {
              t3.stream.addEventListener("addtrack", (i2) => {
                let r2;
                r2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.track.id) : { track: i2.track };
                const n2 = new Event("track");
                n2.track = i2.track, n2.receiver = r2, n2.transceiver = { receiver: r2 }, n2.streams = [t3.stream], this.dispatchEvent(n2);
              }), t3.stream.getTracks().forEach((i2) => {
                let r2;
                r2 = e2.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find((e3) => e3.track && e3.track.id === i2.id) : { track: i2 };
                const n2 = new Event("track");
                n2.track = i2, n2.receiver = r2, n2.transceiver = { receiver: r2 }, n2.streams = [t3.stream], this.dispatchEvent(n2);
              });
            }, this.addEventListener("addstream", this._ontrackpoly)), t2.apply(this, arguments);
          };
        } else
          UR(e2, "track", (e3) => (e3.transceiver || Object.defineProperty(e3, "transceiver", { value: { receiver: e3.receiver } }), e3));
      }
      function XR(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && !("getSenders" in e2.RTCPeerConnection.prototype) && "createDTMFSender" in e2.RTCPeerConnection.prototype) {
          const t2 = function(e3, t3) {
            return { track: t3, get dtmf() {
              return void 0 === this._dtmf && ("audio" === t3.kind ? this._dtmf = e3.createDTMFSender(t3) : this._dtmf = null), this._dtmf;
            }, _pc: e3 };
          };
          if (!e2.RTCPeerConnection.prototype.getSenders) {
            e2.RTCPeerConnection.prototype.getSenders = function() {
              return this._senders = this._senders || [], this._senders.slice();
            };
            const i3 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addTrack = function(e3, r4) {
              let n2 = i3.apply(this, arguments);
              return n2 || (n2 = t2(this, e3), this._senders.push(n2)), n2;
            };
            const r3 = e2.RTCPeerConnection.prototype.removeTrack;
            e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
              r3.apply(this, arguments);
              const t3 = this._senders.indexOf(e3);
              -1 !== t3 && this._senders.splice(t3, 1);
            };
          }
          const i2 = e2.RTCPeerConnection.prototype.addStream;
          e2.RTCPeerConnection.prototype.addStream = function(e3) {
            this._senders = this._senders || [], i2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              this._senders.push(t2(this, e4));
            });
          };
          const r2 = e2.RTCPeerConnection.prototype.removeStream;
          e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._senders = this._senders || [], r2.apply(this, [e3]), e3.getTracks().forEach((e4) => {
              const t3 = this._senders.find((t4) => t4.track === e4);
              t3 && this._senders.splice(this._senders.indexOf(t3), 1);
            });
          };
        } else if ("object" == typeof e2 && e2.RTCPeerConnection && "getSenders" in e2.RTCPeerConnection.prototype && "createDTMFSender" in e2.RTCPeerConnection.prototype && e2.RTCRtpSender && !("dtmf" in e2.RTCRtpSender.prototype)) {
          const t2 = e2.RTCPeerConnection.prototype.getSenders;
          e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t2.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }, Object.defineProperty(e2.RTCRtpSender.prototype, "dtmf", { get() {
            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
          } });
        }
      }
      function $R(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, i2, r2] = arguments;
          if (arguments.length > 0 && "function" == typeof e3)
            return t2.apply(this, arguments);
          if (0 === t2.length && (0 === arguments.length || "function" != typeof e3))
            return t2.apply(this, []);
          const n2 = function(e4) {
            const t3 = {};
            return e4.result().forEach((e5) => {
              const i3 = { id: e5.id, timestamp: e5.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e5.type] || e5.type };
              e5.names().forEach((t4) => {
                i3[t4] = e5.stat(t4);
              }), t3[i3.id] = i3;
            }), t3;
          }, o2 = function(e4) {
            return new Map(Object.keys(e4).map((t3) => [t3, e4[t3]]));
          };
          if (arguments.length >= 2) {
            const r3 = function(e4) {
              i2(o2(n2(e4)));
            };
            return t2.apply(this, [r3, e3]);
          }
          return new Promise((e4, i3) => {
            t2.apply(this, [function(t3) {
              e4(o2(n2(t3)));
            }, i3]);
          }).then(i2, r2);
        };
      }
      function ZR(e2) {
        if (!("object" == typeof e2 && e2.RTCPeerConnection && e2.RTCRtpSender && e2.RTCRtpReceiver))
          return;
        if (!("getStats" in e2.RTCRtpSender.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getSenders;
          t3 && (e2.RTCPeerConnection.prototype.getSenders = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          });
          const i2 = e2.RTCPeerConnection.prototype.addTrack;
          i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
            const e3 = i2.apply(this, arguments);
            return e3._pc = this, e3;
          }), e2.RTCRtpSender.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => KR(t4, e3.track, true));
          };
        }
        if (!("getStats" in e2.RTCRtpReceiver.prototype)) {
          const t3 = e2.RTCPeerConnection.prototype.getReceivers;
          t3 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
            const e3 = t3.apply(this, []);
            return e3.forEach((e4) => e4._pc = this), e3;
          }), UR(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
            const e3 = this;
            return this._pc.getStats().then((t4) => KR(t4, e3.track, false));
          };
        }
        if (!("getStats" in e2.RTCRtpSender.prototype) || !("getStats" in e2.RTCRtpReceiver.prototype))
          return;
        const t2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          if (arguments.length > 0 && arguments[0] instanceof e2.MediaStreamTrack) {
            const e3 = arguments[0];
            let t3, i2, r2;
            return this.getSenders().forEach((i3) => {
              i3.track === e3 && (t3 ? r2 = true : t3 = i3);
            }), this.getReceivers().forEach((t4) => (t4.track === e3 && (i2 ? r2 = true : i2 = t4), t4.track === e3)), r2 || t3 && i2 ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t3 ? t3.getStats() : i2 ? i2.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
          }
          return t2.apply(this, arguments);
        };
      }
      function eC(e2) {
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((e3) => this._shimmedLocalStreams[e3][0]);
        };
        const t2 = e2.RTCPeerConnection.prototype.addTrack;
        e2.RTCPeerConnection.prototype.addTrack = function(e3, i3) {
          if (!i3)
            return t2.apply(this, arguments);
          this._shimmedLocalStreams = this._shimmedLocalStreams || {};
          const r3 = t2.apply(this, arguments);
          return this._shimmedLocalStreams[i3.id] ? -1 === this._shimmedLocalStreams[i3.id].indexOf(r3) && this._shimmedLocalStreams[i3.id].push(r3) : this._shimmedLocalStreams[i3.id] = [i3, r3], r3;
        };
        const i2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(e3) {
          this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3.getTracks().forEach((e4) => {
            if (this.getSenders().find((t4) => t4.track === e4))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          });
          const t3 = this.getSenders();
          i2.apply(this, arguments);
          const r3 = this.getSenders().filter((e4) => -1 === t3.indexOf(e4));
          this._shimmedLocalStreams[e3.id] = [e3].concat(r3);
        };
        const r2 = e2.RTCPeerConnection.prototype.removeStream;
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e3.id], r2.apply(this, arguments);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeTrack;
        e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e3 && Object.keys(this._shimmedLocalStreams).forEach((t3) => {
            const i3 = this._shimmedLocalStreams[t3].indexOf(e3);
            -1 !== i3 && this._shimmedLocalStreams[t3].splice(i3, 1), 1 === this._shimmedLocalStreams[t3].length && delete this._shimmedLocalStreams[t3];
          }), n2.apply(this, arguments);
        };
      }
      function tC(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if (e2.RTCPeerConnection.prototype.addTrack && t2.version >= 65)
          return eC(e2);
        const i2 = e2.RTCPeerConnection.prototype.getLocalStreams;
        e2.RTCPeerConnection.prototype.getLocalStreams = function() {
          const e3 = i2.apply(this);
          return this._reverseStreams = this._reverseStreams || {}, e3.map((e4) => this._reverseStreams[e4.id]);
        };
        const r2 = e2.RTCPeerConnection.prototype.addStream;
        e2.RTCPeerConnection.prototype.addStream = function(t3) {
          if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t3.getTracks().forEach((e3) => {
            if (this.getSenders().find((t4) => t4.track === e3))
              throw new DOMException("Track already exists.", "InvalidAccessError");
          }), !this._reverseStreams[t3.id]) {
            const i3 = new e2.MediaStream(t3.getTracks());
            this._streams[t3.id] = i3, this._reverseStreams[i3.id] = t3, t3 = i3;
          }
          r2.apply(this, [t3]);
        };
        const n2 = e2.RTCPeerConnection.prototype.removeStream;
        function o2(e3, t3) {
          let i3 = t3.sdp;
          return Object.keys(e3._reverseStreams || []).forEach((t4) => {
            const r3 = e3._reverseStreams[t4], n3 = e3._streams[r3.id];
            i3 = i3.replace(new RegExp(n3.id, "g"), r3.id);
          }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
        }
        e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, n2.apply(this, [this._streams[e3.id] || e3]), delete this._reverseStreams[this._streams[e3.id] ? this._streams[e3.id].id : e3.id], delete this._streams[e3.id];
        }, e2.RTCPeerConnection.prototype.addTrack = function(t3, i3) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          const r3 = [].slice.call(arguments, 1);
          if (1 !== r3.length || !r3[0].getTracks().find((e3) => e3 === t3))
            throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
          if (this.getSenders().find((e3) => e3.track === t3))
            throw new DOMException("Track already exists.", "InvalidAccessError");
          this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
          const n3 = this._streams[i3.id];
          if (n3)
            n3.addTrack(t3), Promise.resolve().then(() => {
              this.dispatchEvent(new Event("negotiationneeded"));
            });
          else {
            const r4 = new e2.MediaStream([t3]);
            this._streams[i3.id] = r4, this._reverseStreams[r4.id] = i3, this.addStream(r4);
          }
          return this.getSenders().find((e3) => e3.track === t3);
        }, ["createOffer", "createAnswer"].forEach(function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], r3 = { [t3]() {
            const e3 = arguments;
            return arguments.length && "function" == typeof arguments[0] ? i3.apply(this, [(t4) => {
              const i4 = o2(this, t4);
              e3[0].apply(null, [i4]);
            }, (t4) => {
              e3[1] && e3[1].apply(null, t4);
            }, arguments[2]]) : i3.apply(this, arguments).then((e4) => o2(this, e4));
          } };
          e2.RTCPeerConnection.prototype[t3] = r3[t3];
        });
        const s2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          return arguments.length && arguments[0].type ? (arguments[0] = function(e3, t3) {
            let i3 = t3.sdp;
            return Object.keys(e3._reverseStreams || []).forEach((t4) => {
              const r3 = e3._reverseStreams[t4], n3 = e3._streams[r3.id];
              i3 = i3.replace(new RegExp(r3.id, "g"), n3.id);
            }), new RTCSessionDescription({ type: t3.type, sdp: i3 });
          }(this, arguments[0]), s2.apply(this, arguments)) : s2.apply(this, arguments);
        };
        const a2 = Object.getOwnPropertyDescriptor(e2.RTCPeerConnection.prototype, "localDescription");
        Object.defineProperty(e2.RTCPeerConnection.prototype, "localDescription", { get() {
          const e3 = a2.get.apply(this);
          return "" === e3.type ? e3 : o2(this, e3);
        } }), e2.RTCPeerConnection.prototype.removeTrack = function(e3) {
          if ("closed" === this.signalingState)
            throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
          if (!e3._pc)
            throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
          if (!(e3._pc === this))
            throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
          let t3;
          this._streams = this._streams || {}, Object.keys(this._streams).forEach((i3) => {
            this._streams[i3].getTracks().find((t4) => e3.track === t4) && (t3 = this._streams[i3]);
          }), t3 && (1 === t3.getTracks().length ? this.removeStream(this._reverseStreams[t3.id]) : t3.removeTrack(e3.track), this.dispatchEvent(new Event("negotiationneeded")));
        };
      }
      function iC(e2, t2) {
        !e2.RTCPeerConnection && e2.webkitRTCPeerConnection && (e2.RTCPeerConnection = e2.webkitRTCPeerConnection), e2.RTCPeerConnection && t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i2 = e2.RTCPeerConnection.prototype[t3], r2 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i2.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = r2[t3];
        });
      }
      function rC(e2, t2) {
        UR(e2, "negotiationneeded", (e3) => {
          const i2 = e3.target;
          if (!(t2.version < 72 || i2.getConfiguration && "plan-b" === i2.getConfiguration().sdpSemantics) || "stable" === i2.signalingState)
            return e3;
        });
      }
      var nC = Object.freeze({ __proto__: null, shimMediaStream: YR, shimOnTrack: QR, shimGetSendersWithDtmf: XR, shimGetStats: $R, shimSenderReceiverGetStats: ZR, shimAddTrackRemoveTrackWithNative: eC, shimAddTrackRemoveTrack: tC, shimPeerConnection: iC, fixNegotiationNeeded: rC, shimGetUserMedia: qR, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && ("function" == typeof t2 ? e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          return t2(i2).then((t3) => {
            const r2 = i2.video && i2.video.width, n2 = i2.video && i2.video.height, o2 = i2.video && i2.video.frameRate;
            return i2.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t3, maxFrameRate: o2 || 3 } }, r2 && (i2.video.mandatory.maxWidth = r2), n2 && (i2.video.mandatory.maxHeight = n2), e2.navigator.mediaDevices.getUserMedia(i2);
          });
        } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"));
      } });
      function oC(e2, t2) {
        const i2 = e2 && e2.navigator, r2 = e2 && e2.MediaStreamTrack;
        if (i2.getUserMedia = function(e3, t3, r3) {
          jR("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i2.mediaDevices.getUserMedia(e3).then(t3, r3);
        }, !(t2.version > 55 && "autoGainControl" in i2.mediaDevices.getSupportedConstraints())) {
          const e3 = function(e4, t4, i3) {
            t4 in e4 && !(i3 in e4) && (e4[i3] = e4[t4], delete e4[t4]);
          }, t3 = i2.mediaDevices.getUserMedia.bind(i2.mediaDevices);
          if (i2.mediaDevices.getUserMedia = function(i3) {
            return "object" == typeof i3 && "object" == typeof i3.audio && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3.audio, "autoGainControl", "mozAutoGainControl"), e3(i3.audio, "noiseSuppression", "mozNoiseSuppression")), t3(i3);
          }, r2 && r2.prototype.getSettings) {
            const t4 = r2.prototype.getSettings;
            r2.prototype.getSettings = function() {
              const i3 = t4.apply(this, arguments);
              return e3(i3, "mozAutoGainControl", "autoGainControl"), e3(i3, "mozNoiseSuppression", "noiseSuppression"), i3;
            };
          }
          if (r2 && r2.prototype.applyConstraints) {
            const t4 = r2.prototype.applyConstraints;
            r2.prototype.applyConstraints = function(i3) {
              return "audio" === this.kind && "object" == typeof i3 && (i3 = JSON.parse(JSON.stringify(i3)), e3(i3, "autoGainControl", "mozAutoGainControl"), e3(i3, "noiseSuppression", "mozNoiseSuppression")), t4.apply(this, [i3]);
            };
          }
        }
      }
      function sC(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function aC(e2, t2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection && !e2.mozRTCPeerConnection)
          return;
        !e2.RTCPeerConnection && e2.mozRTCPeerConnection && (e2.RTCPeerConnection = e2.mozRTCPeerConnection), t2.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(t3) {
          const i3 = e2.RTCPeerConnection.prototype[t3], r3 = { [t3]() {
            return arguments[0] = new ("addIceCandidate" === t3 ? e2.RTCIceCandidate : e2.RTCSessionDescription)(arguments[0]), i3.apply(this, arguments);
          } };
          e2.RTCPeerConnection.prototype[t3] = r3[t3];
        });
        const i2 = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, r2 = e2.RTCPeerConnection.prototype.getStats;
        e2.RTCPeerConnection.prototype.getStats = function() {
          const [e3, n2, o2] = arguments;
          return r2.apply(this, [e3 || null]).then((e4) => {
            if (t2.version < 53 && !n2)
              try {
                e4.forEach((e5) => {
                  e5.type = i2[e5.type] || e5.type;
                });
              } catch (wb2) {
                if ("TypeError" !== wb2.name)
                  throw wb2;
                e4.forEach((t3, r3) => {
                  e4.set(r3, Object.assign({}, t3, { type: i2[t3.type] || t3.type }));
                });
              }
            return e4;
          }).then(n2, o2);
        };
      }
      function cC(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpSender.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getSenders;
        t2 && (e2.RTCPeerConnection.prototype.getSenders = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        });
        const i2 = e2.RTCPeerConnection.prototype.addTrack;
        i2 && (e2.RTCPeerConnection.prototype.addTrack = function() {
          const e3 = i2.apply(this, arguments);
          return e3._pc = this, e3;
        }), e2.RTCRtpSender.prototype.getStats = function() {
          return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
        };
      }
      function lC(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection || !e2.RTCRtpSender)
          return;
        if (e2.RTCRtpSender && "getStats" in e2.RTCRtpReceiver.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype.getReceivers;
        t2 && (e2.RTCPeerConnection.prototype.getReceivers = function() {
          const e3 = t2.apply(this, []);
          return e3.forEach((e4) => e4._pc = this), e3;
        }), UR(e2, "track", (e3) => (e3.receiver._pc = e3.srcElement, e3)), e2.RTCRtpReceiver.prototype.getStats = function() {
          return this._pc.getStats(this.track);
        };
      }
      function dC(e2) {
        e2.RTCPeerConnection && !("removeStream" in e2.RTCPeerConnection.prototype) && (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
          jR("removeStream", "removeTrack"), this.getSenders().forEach((t2) => {
            t2.track && e3.getTracks().includes(t2.track) && this.removeTrack(t2);
          });
        });
      }
      function uC(e2) {
        e2.DataChannel && !e2.RTCDataChannel && (e2.RTCDataChannel = e2.DataChannel);
      }
      function hC(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.addTransceiver;
        t2 && (e2.RTCPeerConnection.prototype.addTransceiver = function() {
          this.setParametersPromises = [];
          let e3 = arguments[1] && arguments[1].sendEncodings;
          void 0 === e3 && (e3 = []), e3 = [...e3];
          const i2 = e3.length > 0;
          i2 && e3.forEach((e4) => {
            if ("rid" in e4) {
              if (!/^[a-z0-9]{0,16}$/i.test(e4.rid))
                throw new TypeError("Invalid RID value provided.");
            }
            if ("scaleResolutionDownBy" in e4 && !(parseFloat(e4.scaleResolutionDownBy) >= 1))
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in e4 && !(parseFloat(e4.maxFramerate) >= 0))
              throw new RangeError("max_framerate must be >= 0.0");
          });
          const r2 = t2.apply(this, arguments);
          if (i2) {
            const { sender: t3 } = r2, i3 = t3.getParameters();
            (!("encodings" in i3) || 1 === i3.encodings.length && 0 === Object.keys(i3.encodings[0]).length) && (i3.encodings = e3, t3.sendEncodings = e3, this.setParametersPromises.push(t3.setParameters(i3).then(() => {
              delete t3.sendEncodings;
            }).catch(() => {
              delete t3.sendEncodings;
            })));
          }
          return r2;
        });
      }
      function pC(e2) {
        if ("object" != typeof e2 || !e2.RTCRtpSender)
          return;
        const t2 = e2.RTCRtpSender.prototype.getParameters;
        t2 && (e2.RTCRtpSender.prototype.getParameters = function() {
          const e3 = t2.apply(this, arguments);
          return "encodings" in e3 || (e3.encodings = [].concat(this.sendEncodings || [{}])), e3;
        });
      }
      function mC(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      function _C(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype.createAnswer;
        e2.RTCPeerConnection.prototype.createAnswer = function() {
          return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => t2.apply(this, arguments)).finally(() => {
            this.setParametersPromises = [];
          }) : t2.apply(this, arguments);
        };
      }
      var fC = Object.freeze({ __proto__: null, shimOnTrack: sC, shimPeerConnection: aC, shimSenderGetStats: cC, shimReceiverGetStats: lC, shimRemoveStream: dC, shimRTCDataChannel: uC, shimAddTransceiver: hC, shimGetParameters: pC, shimCreateOffer: mC, shimCreateAnswer: _C, shimGetUserMedia: oC, shimGetDisplayMedia: function(e2, t2) {
        e2.navigator.mediaDevices && "getDisplayMedia" in e2.navigator.mediaDevices || e2.navigator.mediaDevices && (e2.navigator.mediaDevices.getDisplayMedia = function(i2) {
          if (!i2 || !i2.video) {
            const e3 = new DOMException("getDisplayMedia without video constraints is undefined");
            return e3.name = "NotFoundError", e3.code = 8, Promise.reject(e3);
          }
          return true === i2.video ? i2.video = { mediaSource: t2 } : i2.video.mediaSource = t2, e2.navigator.mediaDevices.getUserMedia(i2);
        });
      } });
      function gC(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection) {
          if ("getLocalStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getLocalStreams = function() {
            return this._localStreams || (this._localStreams = []), this._localStreams;
          }), !("addStream" in e2.RTCPeerConnection.prototype)) {
            const t2 = e2.RTCPeerConnection.prototype.addTrack;
            e2.RTCPeerConnection.prototype.addStream = function(e3) {
              this._localStreams || (this._localStreams = []), this._localStreams.includes(e3) || this._localStreams.push(e3), e3.getAudioTracks().forEach((i2) => t2.call(this, i2, e3)), e3.getVideoTracks().forEach((i2) => t2.call(this, i2, e3));
            }, e2.RTCPeerConnection.prototype.addTrack = function(e3, ...i2) {
              return i2 && i2.forEach((e4) => {
                this._localStreams ? this._localStreams.includes(e4) || this._localStreams.push(e4) : this._localStreams = [e4];
              }), t2.apply(this, arguments);
            };
          }
          "removeStream" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.removeStream = function(e3) {
            this._localStreams || (this._localStreams = []);
            const t2 = this._localStreams.indexOf(e3);
            if (-1 === t2)
              return;
            this._localStreams.splice(t2, 1);
            const i2 = e3.getTracks();
            this.getSenders().forEach((e4) => {
              i2.includes(e4.track) && this.removeTrack(e4);
            });
          });
        }
      }
      function TC(e2) {
        if ("object" == typeof e2 && e2.RTCPeerConnection && ("getRemoteStreams" in e2.RTCPeerConnection.prototype || (e2.RTCPeerConnection.prototype.getRemoteStreams = function() {
          return this._remoteStreams ? this._remoteStreams : [];
        }), !("onaddstream" in e2.RTCPeerConnection.prototype))) {
          Object.defineProperty(e2.RTCPeerConnection.prototype, "onaddstream", { get() {
            return this._onaddstream;
          }, set(e3) {
            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e3), this.addEventListener("track", this._onaddstreampoly = (e4) => {
              e4.streams.forEach((e5) => {
                if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e5))
                  return;
                this._remoteStreams.push(e5);
                const t3 = new Event("addstream");
                t3.stream = e5, this.dispatchEvent(t3);
              });
            });
          } });
          const t2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
          e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
            const e3 = this;
            return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(t3) {
              t3.streams.forEach((t4) => {
                if (e3._remoteStreams || (e3._remoteStreams = []), e3._remoteStreams.indexOf(t4) >= 0)
                  return;
                e3._remoteStreams.push(t4);
                const i2 = new Event("addstream");
                i2.stream = t4, e3.dispatchEvent(i2);
              });
            }), t2.apply(e3, arguments);
          };
        }
      }
      function EC(e2) {
        if ("object" != typeof e2 || !e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection.prototype, i2 = t2.createOffer, r2 = t2.createAnswer, n2 = t2.setLocalDescription, o2 = t2.setRemoteDescription, s2 = t2.addIceCandidate;
        t2.createOffer = function(e3, t3) {
          const r3 = arguments.length >= 2 ? arguments[2] : arguments[0], n3 = i2.apply(this, [r3]);
          return t3 ? (n3.then(e3, t3), Promise.resolve()) : n3;
        }, t2.createAnswer = function(e3, t3) {
          const i3 = arguments.length >= 2 ? arguments[2] : arguments[0], n3 = r2.apply(this, [i3]);
          return t3 ? (n3.then(e3, t3), Promise.resolve()) : n3;
        };
        let a2 = function(e3, t3, i3) {
          const r3 = n2.apply(this, [e3]);
          return i3 ? (r3.then(t3, i3), Promise.resolve()) : r3;
        };
        t2.setLocalDescription = a2, a2 = function(e3, t3, i3) {
          const r3 = o2.apply(this, [e3]);
          return i3 ? (r3.then(t3, i3), Promise.resolve()) : r3;
        }, t2.setRemoteDescription = a2, a2 = function(e3, t3, i3) {
          const r3 = s2.apply(this, [e3]);
          return i3 ? (r3.then(t3, i3), Promise.resolve()) : r3;
        }, t2.addIceCandidate = a2;
      }
      function SC(e2) {
        const t2 = e2 && e2.navigator;
        if (t2.mediaDevices && t2.mediaDevices.getUserMedia) {
          const e3 = t2.mediaDevices, i2 = e3.getUserMedia.bind(e3);
          t2.mediaDevices.getUserMedia = (e4) => i2(IC(e4));
        }
        !t2.getUserMedia && t2.mediaDevices && t2.mediaDevices.getUserMedia && (t2.getUserMedia = (function(e3, i2, r2) {
          t2.mediaDevices.getUserMedia(e3).then(i2, r2);
        }).bind(t2));
      }
      function IC(e2) {
        return e2 && void 0 !== e2.video ? Object.assign({}, e2, { video: WR(e2.video) }) : e2;
      }
      function vC(e2) {
        if (!e2.RTCPeerConnection)
          return;
        const t2 = e2.RTCPeerConnection;
        e2.RTCPeerConnection = function(e3, i2) {
          if (e3 && e3.iceServers) {
            const t3 = [];
            for (let i3 = 0; i3 < e3.iceServers.length; i3++) {
              let r2 = e3.iceServers[i3];
              void 0 === r2.urls && r2.url ? (jR("RTCIceServer.url", "RTCIceServer.urls"), r2 = JSON.parse(JSON.stringify(r2)), r2.urls = r2.url, delete r2.url, t3.push(r2)) : t3.push(e3.iceServers[i3]);
            }
            e3.iceServers = t3;
          }
          return new t2(e3, i2);
        }, e2.RTCPeerConnection.prototype = t2.prototype, "generateCertificate" in t2 && Object.defineProperty(e2.RTCPeerConnection, "generateCertificate", { get: () => t2.generateCertificate });
      }
      function yC(e2) {
        "object" == typeof e2 && e2.RTCTrackEvent && "receiver" in e2.RTCTrackEvent.prototype && !("transceiver" in e2.RTCTrackEvent.prototype) && Object.defineProperty(e2.RTCTrackEvent.prototype, "transceiver", { get() {
          return { receiver: this.receiver };
        } });
      }
      function AC(e2) {
        const t2 = e2.RTCPeerConnection.prototype.createOffer;
        e2.RTCPeerConnection.prototype.createOffer = function(e3) {
          if (e3) {
            void 0 !== e3.offerToReceiveAudio && (e3.offerToReceiveAudio = !!e3.offerToReceiveAudio);
            const t3 = this.getTransceivers().find((e4) => "audio" === e4.receiver.track.kind);
            false === e3.offerToReceiveAudio && t3 ? "sendrecv" === t3.direction ? t3.setDirection ? t3.setDirection("sendonly") : t3.direction = "sendonly" : "recvonly" === t3.direction && (t3.setDirection ? t3.setDirection("inactive") : t3.direction = "inactive") : true !== e3.offerToReceiveAudio || t3 || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e3.offerToReceiveVideo && (e3.offerToReceiveVideo = !!e3.offerToReceiveVideo);
            const i2 = this.getTransceivers().find((e4) => "video" === e4.receiver.track.kind);
            false === e3.offerToReceiveVideo && i2 ? "sendrecv" === i2.direction ? i2.setDirection ? i2.setDirection("sendonly") : i2.direction = "sendonly" : "recvonly" === i2.direction && (i2.setDirection ? i2.setDirection("inactive") : i2.direction = "inactive") : true !== e3.offerToReceiveVideo || i2 || this.addTransceiver("video", { direction: "recvonly" });
          }
          return t2.apply(this, arguments);
        };
      }
      function RC(e2) {
        "object" != typeof e2 || e2.AudioContext || (e2.AudioContext = e2.webkitAudioContext);
      }
      var CC = Object.freeze({ __proto__: null, shimLocalStreamsAPI: gC, shimRemoteStreamsAPI: TC, shimCallbacksAPI: EC, shimGetUserMedia: SC, shimConstraints: IC, shimRTCIceServerUrls: vC, shimTrackEventTransceiver: yC, shimCreateOfferLegacy: AC, shimAudioContext: RC }), bC = {}, kC = { get exports() {
        return bC;
      }, set exports(e2) {
        bC = e2;
      } };
      !function(e2) {
        const t2 = { generateIdentifier: function() {
          return Math.random().toString(36).substring(2, 12);
        } };
        t2.localCName = t2.generateIdentifier(), t2.splitLines = function(e3) {
          return e3.trim().split("\n").map((e4) => e4.trim());
        }, t2.splitSections = function(e3) {
          return e3.split("\nm=").map((e4, t3) => (t3 > 0 ? "m=" + e4 : e4).trim() + "\r\n");
        }, t2.getDescription = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2 && i2[0];
        }, t2.getMediaSections = function(e3) {
          const i2 = t2.splitSections(e3);
          return i2.shift(), i2;
        }, t2.matchPrefix = function(e3, i2) {
          return t2.splitLines(e3).filter((e4) => 0 === e4.indexOf(i2));
        }, t2.parseCandidate = function(e3) {
          let t3;
          t3 = 0 === e3.indexOf("a=candidate:") ? e3.substring(12).split(" ") : e3.substring(10).split(" ");
          const i2 = { foundation: t3[0], component: { 1: "rtp", 2: "rtcp" }[t3[1]] || t3[1], protocol: t3[2].toLowerCase(), priority: parseInt(t3[3], 10), ip: t3[4], address: t3[4], port: parseInt(t3[5], 10), type: t3[7] };
          for (let r2 = 8; r2 < t3.length; r2 += 2)
            switch (t3[r2]) {
              case "raddr":
                i2.relatedAddress = t3[r2 + 1];
                break;
              case "rport":
                i2.relatedPort = parseInt(t3[r2 + 1], 10);
                break;
              case "tcptype":
                i2.tcpType = t3[r2 + 1];
                break;
              case "ufrag":
                i2.ufrag = t3[r2 + 1], i2.usernameFragment = t3[r2 + 1];
                break;
              default:
                void 0 === i2[t3[r2]] && (i2[t3[r2]] = t3[r2 + 1]);
            }
          return i2;
        }, t2.writeCandidate = function(e3) {
          const t3 = [];
          t3.push(e3.foundation);
          const i2 = e3.component;
          "rtp" === i2 ? t3.push(1) : "rtcp" === i2 ? t3.push(2) : t3.push(i2), t3.push(e3.protocol.toUpperCase()), t3.push(e3.priority), t3.push(e3.address || e3.ip), t3.push(e3.port);
          const r2 = e3.type;
          return t3.push("typ"), t3.push(r2), "host" !== r2 && e3.relatedAddress && e3.relatedPort && (t3.push("raddr"), t3.push(e3.relatedAddress), t3.push("rport"), t3.push(e3.relatedPort)), e3.tcpType && "tcp" === e3.protocol.toLowerCase() && (t3.push("tcptype"), t3.push(e3.tcpType)), (e3.usernameFragment || e3.ufrag) && (t3.push("ufrag"), t3.push(e3.usernameFragment || e3.ufrag)), "candidate:" + t3.join(" ");
        }, t2.parseIceOptions = function(e3) {
          return e3.substring(14).split(" ");
        }, t2.parseRtpMap = function(e3) {
          let t3 = e3.substring(9).split(" ");
          const i2 = { payloadType: parseInt(t3.shift(), 10) };
          return t3 = t3[0].split("/"), i2.name = t3[0], i2.clockRate = parseInt(t3[1], 10), i2.channels = 3 === t3.length ? parseInt(t3[2], 10) : 1, i2.numChannels = i2.channels, i2;
        }, t2.writeRtpMap = function(e3) {
          let t3 = e3.payloadType;
          void 0 !== e3.preferredPayloadType && (t3 = e3.preferredPayloadType);
          const i2 = e3.channels || e3.numChannels || 1;
          return "a=rtpmap:" + t3 + " " + e3.name + "/" + e3.clockRate + (1 !== i2 ? "/" + i2 : "") + "\r\n";
        }, t2.parseExtmap = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { id: parseInt(t3[0], 10), direction: t3[0].indexOf("/") > 0 ? t3[0].split("/")[1] : "sendrecv", uri: t3[1], attributes: t3.slice(2).join(" ") };
        }, t2.writeExtmap = function(e3) {
          return "a=extmap:" + (e3.id || e3.preferredId) + (e3.direction && "sendrecv" !== e3.direction ? "/" + e3.direction : "") + " " + e3.uri + (e3.attributes ? " " + e3.attributes : "") + "\r\n";
        }, t2.parseFmtp = function(e3) {
          const t3 = {};
          let i2;
          const r2 = e3.substring(e3.indexOf(" ") + 1).split(";");
          for (let n2 = 0; n2 < r2.length; n2++)
            i2 = r2[n2].trim().split("="), t3[i2[0].trim()] = i2[1];
          return t3;
        }, t2.writeFmtp = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          if (void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.parameters && Object.keys(e3.parameters).length) {
            const r2 = [];
            Object.keys(e3.parameters).forEach((t4) => {
              void 0 !== e3.parameters[t4] ? r2.push(t4 + "=" + e3.parameters[t4]) : r2.push(t4);
            }), t3 += "a=fmtp:" + i2 + " " + r2.join(";") + "\r\n";
          }
          return t3;
        }, t2.parseRtcpFb = function(e3) {
          const t3 = e3.substring(e3.indexOf(" ") + 1).split(" ");
          return { type: t3.shift(), parameter: t3.join(" ") };
        }, t2.writeRtcpFb = function(e3) {
          let t3 = "", i2 = e3.payloadType;
          return void 0 !== e3.preferredPayloadType && (i2 = e3.preferredPayloadType), e3.rtcpFeedback && e3.rtcpFeedback.length && e3.rtcpFeedback.forEach((e4) => {
            t3 += "a=rtcp-fb:" + i2 + " " + e4.type + (e4.parameter && e4.parameter.length ? " " + e4.parameter : "") + "\r\n";
          }), t3;
        }, t2.parseSsrcMedia = function(e3) {
          const t3 = e3.indexOf(" "), i2 = { ssrc: parseInt(e3.substring(7, t3), 10) }, r2 = e3.indexOf(":", t3);
          return r2 > -1 ? (i2.attribute = e3.substring(t3 + 1, r2), i2.value = e3.substring(r2 + 1)) : i2.attribute = e3.substring(t3 + 1), i2;
        }, t2.parseSsrcGroup = function(e3) {
          const t3 = e3.substring(13).split(" ");
          return { semantics: t3.shift(), ssrcs: t3.map((e4) => parseInt(e4, 10)) };
        }, t2.getMid = function(e3) {
          const i2 = t2.matchPrefix(e3, "a=mid:")[0];
          if (i2)
            return i2.substring(6);
        }, t2.parseFingerprint = function(e3) {
          const t3 = e3.substring(14).split(" ");
          return { algorithm: t3[0].toLowerCase(), value: t3[1].toUpperCase() };
        }, t2.getDtlsParameters = function(e3, i2) {
          return { role: "auto", fingerprints: t2.matchPrefix(e3 + i2, "a=fingerprint:").map(t2.parseFingerprint) };
        }, t2.writeDtlsParameters = function(e3, t3) {
          let i2 = "a=setup:" + t3 + "\r\n";
          return e3.fingerprints.forEach((e4) => {
            i2 += "a=fingerprint:" + e4.algorithm + " " + e4.value + "\r\n";
          }), i2;
        }, t2.parseCryptoLine = function(e3) {
          const t3 = e3.substring(9).split(" ");
          return { tag: parseInt(t3[0], 10), cryptoSuite: t3[1], keyParams: t3[2], sessionParams: t3.slice(3) };
        }, t2.writeCryptoLine = function(e3) {
          return "a=crypto:" + e3.tag + " " + e3.cryptoSuite + " " + ("object" == typeof e3.keyParams ? t2.writeCryptoKeyParams(e3.keyParams) : e3.keyParams) + (e3.sessionParams ? " " + e3.sessionParams.join(" ") : "") + "\r\n";
        }, t2.parseCryptoKeyParams = function(e3) {
          if (0 !== e3.indexOf("inline:"))
            return null;
          const t3 = e3.substring(7).split("|");
          return { keyMethod: "inline", keySalt: t3[0], lifeTime: t3[1], mkiValue: t3[2] ? t3[2].split(":")[0] : void 0, mkiLength: t3[2] ? t3[2].split(":")[1] : void 0 };
        }, t2.writeCryptoKeyParams = function(e3) {
          return e3.keyMethod + ":" + e3.keySalt + (e3.lifeTime ? "|" + e3.lifeTime : "") + (e3.mkiValue && e3.mkiLength ? "|" + e3.mkiValue + ":" + e3.mkiLength : "");
        }, t2.getCryptoParameters = function(e3, i2) {
          return t2.matchPrefix(e3 + i2, "a=crypto:").map(t2.parseCryptoLine);
        }, t2.getIceParameters = function(e3, i2) {
          const r2 = t2.matchPrefix(e3 + i2, "a=ice-ufrag:")[0], n2 = t2.matchPrefix(e3 + i2, "a=ice-pwd:")[0];
          return r2 && n2 ? { usernameFragment: r2.substring(12), password: n2.substring(10) } : null;
        }, t2.writeIceParameters = function(e3) {
          let t3 = "a=ice-ufrag:" + e3.usernameFragment + "\r\na=ice-pwd:" + e3.password + "\r\n";
          return e3.iceLite && (t3 += "a=ice-lite\r\n"), t3;
        }, t2.parseRtpParameters = function(e3) {
          const i2 = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r2 = t2.splitLines(e3)[0].split(" ");
          i2.profile = r2[2];
          for (let o2 = 3; o2 < r2.length; o2++) {
            const n3 = r2[o2], s2 = t2.matchPrefix(e3, "a=rtpmap:" + n3 + " ")[0];
            if (s2) {
              const r3 = t2.parseRtpMap(s2), o3 = t2.matchPrefix(e3, "a=fmtp:" + n3 + " ");
              switch (r3.parameters = o3.length ? t2.parseFmtp(o3[0]) : {}, r3.rtcpFeedback = t2.matchPrefix(e3, "a=rtcp-fb:" + n3 + " ").map(t2.parseRtcpFb), i2.codecs.push(r3), r3.name.toUpperCase()) {
                case "RED":
                case "ULPFEC":
                  i2.fecMechanisms.push(r3.name.toUpperCase());
              }
            }
          }
          t2.matchPrefix(e3, "a=extmap:").forEach((e4) => {
            i2.headerExtensions.push(t2.parseExtmap(e4));
          });
          const n2 = t2.matchPrefix(e3, "a=rtcp-fb:* ").map(t2.parseRtcpFb);
          return i2.codecs.forEach((e4) => {
            n2.forEach((t3) => {
              e4.rtcpFeedback.find((e5) => e5.type === t3.type && e5.parameter === t3.parameter) || e4.rtcpFeedback.push(t3);
            });
          }), i2;
        }, t2.writeRtpDescription = function(e3, i2) {
          let r2 = "";
          r2 += "m=" + e3 + " ", r2 += i2.codecs.length > 0 ? "9" : "0", r2 += " " + (i2.profile || "UDP/TLS/RTP/SAVPF") + " ", r2 += i2.codecs.map((e4) => void 0 !== e4.preferredPayloadType ? e4.preferredPayloadType : e4.payloadType).join(" ") + "\r\n", r2 += "c=IN IP4 0.0.0.0\r\n", r2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n", i2.codecs.forEach((e4) => {
            r2 += t2.writeRtpMap(e4), r2 += t2.writeFmtp(e4), r2 += t2.writeRtcpFb(e4);
          });
          let n2 = 0;
          return i2.codecs.forEach((e4) => {
            e4.maxptime > n2 && (n2 = e4.maxptime);
          }), n2 > 0 && (r2 += "a=maxptime:" + n2 + "\r\n"), i2.headerExtensions && i2.headerExtensions.forEach((e4) => {
            r2 += t2.writeExtmap(e4);
          }), r2;
        }, t2.parseRtpEncodingParameters = function(e3) {
          const i2 = [], r2 = t2.parseRtpParameters(e3), n2 = -1 !== r2.fecMechanisms.indexOf("RED"), o2 = -1 !== r2.fecMechanisms.indexOf("ULPFEC"), s2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute), a2 = s2.length > 0 && s2[0].ssrc;
          let c2;
          const l2 = t2.matchPrefix(e3, "a=ssrc-group:FID").map((e4) => e4.substring(17).split(" ").map((e5) => parseInt(e5, 10)));
          l2.length > 0 && l2[0].length > 1 && l2[0][0] === a2 && (c2 = l2[0][1]), r2.codecs.forEach((e4) => {
            if ("RTX" === e4.name.toUpperCase() && e4.parameters.apt) {
              let t3 = { ssrc: a2, codecPayloadType: parseInt(e4.parameters.apt, 10) };
              a2 && c2 && (t3.rtx = { ssrc: c2 }), i2.push(t3), n2 && (t3 = JSON.parse(JSON.stringify(t3)), t3.fec = { ssrc: a2, mechanism: o2 ? "red+ulpfec" : "red" }, i2.push(t3));
            }
          }), 0 === i2.length && a2 && i2.push({ ssrc: a2 });
          let d2 = t2.matchPrefix(e3, "b=");
          return d2.length && (d2 = 0 === d2[0].indexOf("b=TIAS:") ? parseInt(d2[0].substring(7), 10) : 0 === d2[0].indexOf("b=AS:") ? 1e3 * parseInt(d2[0].substring(5), 10) * 0.95 - 16e3 : void 0, i2.forEach((e4) => {
            e4.maxBitrate = d2;
          })), i2;
        }, t2.parseRtcpParameters = function(e3) {
          const i2 = {}, r2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "cname" === e4.attribute)[0];
          r2 && (i2.cname = r2.value, i2.ssrc = r2.ssrc);
          const n2 = t2.matchPrefix(e3, "a=rtcp-rsize");
          i2.reducedSize = n2.length > 0, i2.compound = 0 === n2.length;
          const o2 = t2.matchPrefix(e3, "a=rtcp-mux");
          return i2.mux = o2.length > 0, i2;
        }, t2.writeRtcpParameters = function(e3) {
          let t3 = "";
          return e3.reducedSize && (t3 += "a=rtcp-rsize\r\n"), e3.mux && (t3 += "a=rtcp-mux\r\n"), void 0 !== e3.ssrc && e3.cname && (t3 += "a=ssrc:" + e3.ssrc + " cname:" + e3.cname + "\r\n"), t3;
        }, t2.parseMsid = function(e3) {
          let i2;
          const r2 = t2.matchPrefix(e3, "a=msid:");
          if (1 === r2.length)
            return i2 = r2[0].substring(7).split(" "), { stream: i2[0], track: i2[1] };
          const n2 = t2.matchPrefix(e3, "a=ssrc:").map((e4) => t2.parseSsrcMedia(e4)).filter((e4) => "msid" === e4.attribute);
          return n2.length > 0 ? (i2 = n2[0].value.split(" "), { stream: i2[0], track: i2[1] }) : void 0;
        }, t2.parseSctpDescription = function(e3) {
          const i2 = t2.parseMLine(e3), r2 = t2.matchPrefix(e3, "a=max-message-size:");
          let n2;
          r2.length > 0 && (n2 = parseInt(r2[0].substring(19), 10)), isNaN(n2) && (n2 = 65536);
          const o2 = t2.matchPrefix(e3, "a=sctp-port:");
          if (o2.length > 0)
            return { port: parseInt(o2[0].substring(12), 10), protocol: i2.fmt, maxMessageSize: n2 };
          const s2 = t2.matchPrefix(e3, "a=sctpmap:");
          if (s2.length > 0) {
            const e4 = s2[0].substring(10).split(" ");
            return { port: parseInt(e4[0], 10), protocol: e4[1], maxMessageSize: n2 };
          }
        }, t2.writeSctpDescription = function(e3, t3) {
          let i2 = [];
          return i2 = "DTLS/SCTP" !== e3.protocol ? ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t3.port + "\r\n"] : ["m=" + e3.kind + " 9 " + e3.protocol + " " + t3.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t3.port + " " + t3.protocol + " 65535\r\n"], void 0 !== t3.maxMessageSize && i2.push("a=max-message-size:" + t3.maxMessageSize + "\r\n"), i2.join("");
        }, t2.generateSessionId = function() {
          return Math.random().toString().substr(2, 22);
        }, t2.writeSessionBoilerplate = function(e3, i2, r2) {
          let n2;
          const o2 = void 0 !== i2 ? i2 : 2;
          n2 = e3 || t2.generateSessionId();
          return "v=0\r\no=" + (r2 || "thisisadapterortc") + " " + n2 + " " + o2 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
        }, t2.getDirection = function(e3, i2) {
          const r2 = t2.splitLines(e3);
          for (let t3 = 0; t3 < r2.length; t3++)
            switch (r2[t3]) {
              case "a=sendrecv":
              case "a=sendonly":
              case "a=recvonly":
              case "a=inactive":
                return r2[t3].substring(2);
            }
          return i2 ? t2.getDirection(i2) : "sendrecv";
        }, t2.getKind = function(e3) {
          return t2.splitLines(e3)[0].split(" ")[0].substring(2);
        }, t2.isRejected = function(e3) {
          return "0" === e3.split(" ", 2)[1];
        }, t2.parseMLine = function(e3) {
          const i2 = t2.splitLines(e3)[0].substring(2).split(" ");
          return { kind: i2[0], port: parseInt(i2[1], 10), protocol: i2[2], fmt: i2.slice(3).join(" ") };
        }, t2.parseOLine = function(e3) {
          const i2 = t2.matchPrefix(e3, "o=")[0].substring(2).split(" ");
          return { username: i2[0], sessionId: i2[1], sessionVersion: parseInt(i2[2], 10), netType: i2[3], addressType: i2[4], address: i2[5] };
        }, t2.isValidSDP = function(e3) {
          if ("string" != typeof e3 || 0 === e3.length)
            return false;
          const i2 = t2.splitLines(e3);
          for (let t3 = 0; t3 < i2.length; t3++)
            if (i2[t3].length < 2 || "=" !== i2[t3].charAt(1))
              return false;
          return true;
        }, e2.exports = t2;
      }(kC);
      var NC = bC, DC = e({ __proto__: null, default: NC }, [bC]);
      function wC(e2) {
        if (!e2.RTCIceCandidate || e2.RTCIceCandidate && "foundation" in e2.RTCIceCandidate.prototype)
          return;
        const t2 = e2.RTCIceCandidate;
        e2.RTCIceCandidate = function(e3) {
          if ("object" == typeof e3 && e3.candidate && 0 === e3.candidate.indexOf("a=") && ((e3 = JSON.parse(JSON.stringify(e3))).candidate = e3.candidate.substring(2)), e3.candidate && e3.candidate.length) {
            const i2 = new t2(e3), r2 = NC.parseCandidate(e3.candidate);
            for (const e4 in r2)
              e4 in i2 || Object.defineProperty(i2, e4, { value: r2[e4] });
            return i2.toJSON = function() {
              return { candidate: i2.candidate, sdpMid: i2.sdpMid, sdpMLineIndex: i2.sdpMLineIndex, usernameFragment: i2.usernameFragment };
            }, i2;
          }
          return new t2(e3);
        }, e2.RTCIceCandidate.prototype = t2.prototype, UR(e2, "icecandidate", (t3) => (t3.candidate && Object.defineProperty(t3, "candidate", { value: new e2.RTCIceCandidate(t3.candidate), writable: "false" }), t3));
      }
      function OC(e2) {
        !e2.RTCIceCandidate || e2.RTCIceCandidate && "relayProtocol" in e2.RTCIceCandidate.prototype || UR(e2, "icecandidate", (e3) => {
          if (e3.candidate) {
            const t2 = NC.parseCandidate(e3.candidate.candidate);
            "relay" === t2.type && (e3.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t2.priority >> 24]);
          }
          return e3;
        });
      }
      function PC(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        "sctp" in e2.RTCPeerConnection.prototype || Object.defineProperty(e2.RTCPeerConnection.prototype, "sctp", { get() {
          return void 0 === this._sctp ? null : this._sctp;
        } });
        const i2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function() {
          if (this._sctp = null, "chrome" === t2.browser && t2.version >= 76) {
            const { sdpSemantics: e3 } = this.getConfiguration();
            "plan-b" === e3 && Object.defineProperty(this, "sctp", { get() {
              return void 0 === this._sctp ? null : this._sctp;
            }, enumerable: true, configurable: true });
          }
          if (function(e3) {
            if (!e3 || !e3.sdp)
              return false;
            const t3 = NC.splitSections(e3.sdp);
            return t3.shift(), t3.some((e4) => {
              const t4 = NC.parseMLine(e4);
              return t4 && "application" === t4.kind && -1 !== t4.protocol.indexOf("SCTP");
            });
          }(arguments[0])) {
            const e3 = function(e4) {
              const t3 = e4.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
              if (null === t3 || t3.length < 2)
                return -1;
              const i4 = parseInt(t3[1], 10);
              return i4 != i4 ? -1 : i4;
            }(arguments[0]), i3 = function(e4) {
              let i4 = 65536;
              return "firefox" === t2.browser && (i4 = t2.version < 57 ? -1 === e4 ? 16384 : 2147483637 : t2.version < 60 ? 57 === t2.version ? 65535 : 65536 : 2147483637), i4;
            }(e3), r2 = function(e4, i4) {
              let r3 = 65536;
              "firefox" === t2.browser && 57 === t2.version && (r3 = 65535);
              const n3 = NC.matchPrefix(e4.sdp, "a=max-message-size:");
              return n3.length > 0 ? r3 = parseInt(n3[0].substring(19), 10) : "firefox" === t2.browser && -1 !== i4 && (r3 = 2147483637), r3;
            }(arguments[0], e3);
            let n2;
            n2 = 0 === i3 && 0 === r2 ? Number.POSITIVE_INFINITY : 0 === i3 || 0 === r2 ? Math.max(i3, r2) : Math.min(i3, r2);
            const o2 = {};
            Object.defineProperty(o2, "maxMessageSize", { get: () => n2 }), this._sctp = o2;
          }
          return i2.apply(this, arguments);
        };
      }
      function MC(e2) {
        if (!e2.RTCPeerConnection || !("createDataChannel" in e2.RTCPeerConnection.prototype))
          return;
        function t2(e3, t3) {
          const i3 = e3.send;
          e3.send = function() {
            const r2 = arguments[0], n2 = r2.length || r2.size || r2.byteLength;
            if ("open" === e3.readyState && t3.sctp && n2 > t3.sctp.maxMessageSize)
              throw new TypeError("Message too large (can send a maximum of " + t3.sctp.maxMessageSize + " bytes)");
            return i3.apply(e3, arguments);
          };
        }
        const i2 = e2.RTCPeerConnection.prototype.createDataChannel;
        e2.RTCPeerConnection.prototype.createDataChannel = function() {
          const e3 = i2.apply(this, arguments);
          return t2(e3, this), e3;
        }, UR(e2, "datachannel", (e3) => (t2(e3.channel, e3.target), e3));
      }
      function LC(e2) {
        if (!e2.RTCPeerConnection || "connectionState" in e2.RTCPeerConnection.prototype)
          return;
        const t2 = e2.RTCPeerConnection.prototype;
        Object.defineProperty(t2, "connectionState", { get() {
          return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState;
        }, enumerable: true, configurable: true }), Object.defineProperty(t2, "onconnectionstatechange", { get() {
          return this._onconnectionstatechange || null;
        }, set(e3) {
          this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e3 && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e3);
        }, enumerable: true, configurable: true }), ["setLocalDescription", "setRemoteDescription"].forEach((e3) => {
          const i2 = t2[e3];
          t2[e3] = function() {
            return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e4) => {
              const t3 = e4.target;
              if (t3._lastConnectionState !== t3.connectionState) {
                t3._lastConnectionState = t3.connectionState;
                const i3 = new Event("connectionstatechange", e4);
                t3.dispatchEvent(i3);
              }
              return e4;
            }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i2.apply(this, arguments);
          };
        });
      }
      function xC(e2, t2) {
        if (!e2.RTCPeerConnection)
          return;
        if ("chrome" === t2.browser && t2.version >= 71)
          return;
        if ("safari" === t2.browser && t2.version >= 605)
          return;
        const i2 = e2.RTCPeerConnection.prototype.setRemoteDescription;
        e2.RTCPeerConnection.prototype.setRemoteDescription = function(t3) {
          if (t3 && t3.sdp && -1 !== t3.sdp.indexOf("\na=extmap-allow-mixed")) {
            const i3 = t3.sdp.split("\n").filter((e3) => "a=extmap-allow-mixed" !== e3.trim()).join("\n");
            e2.RTCSessionDescription && t3 instanceof e2.RTCSessionDescription ? arguments[0] = new e2.RTCSessionDescription({ type: t3.type, sdp: i3 }) : t3.sdp = i3;
          }
          return i2.apply(this, arguments);
        };
      }
      function VC(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
          return;
        const i2 = e2.RTCPeerConnection.prototype.addIceCandidate;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.addIceCandidate = function() {
          return arguments[0] ? ("chrome" === t2.browser && t2.version < 78 || "firefox" === t2.browser && t2.version < 68 || "safari" === t2.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : i2.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
        });
      }
      function UC(e2, t2) {
        if (!e2.RTCPeerConnection || !e2.RTCPeerConnection.prototype)
          return;
        const i2 = e2.RTCPeerConnection.prototype.setLocalDescription;
        i2 && 0 !== i2.length && (e2.RTCPeerConnection.prototype.setLocalDescription = function() {
          let e3 = arguments[0] || {};
          if ("object" != typeof e3 || e3.type && e3.sdp)
            return i2.apply(this, arguments);
          if (e3 = { type: e3.type, sdp: e3.sdp }, !e3.type)
            switch (this.signalingState) {
              case "stable":
              case "have-local-offer":
              case "have-remote-pranswer":
                e3.type = "offer";
                break;
              default:
                e3.type = "answer";
            }
          if (e3.sdp || "offer" !== e3.type && "answer" !== e3.type)
            return i2.apply(this, [e3]);
          return ("offer" === e3.type ? this.createOffer : this.createAnswer).apply(this).then((e4) => i2.apply(this, [e4]));
        });
      }
      var FC = Object.freeze({ __proto__: null, shimRTCIceCandidate: wC, shimRTCIceCandidateRelayProtocol: OC, shimMaxMessageSize: PC, shimSendThrowTypeError: MC, shimConnectionState: LC, removeExtmapAllowMixed: xC, shimAddIceCandidateNullOrEmpty: VC, shimParameterlessSetLocalDescription: UC });
      !function({ window: e2 } = {}, t2 = { shimChrome: true, shimFirefox: true, shimSafari: true }) {
        const i2 = HR, r2 = function(e3) {
          const t3 = { browser: null, version: null };
          if (void 0 === e3 || !e3.navigator || !e3.navigator.userAgent)
            return t3.browser = "Not a browser.", t3;
          const { navigator: i3 } = e3;
          if (i3.mozGetUserMedia)
            t3.browser = "firefox", t3.version = VR(i3.userAgent, /Firefox\/(\d+)\./, 1);
          else if (i3.webkitGetUserMedia || false === e3.isSecureContext && e3.webkitRTCPeerConnection)
            t3.browser = "chrome", t3.version = VR(i3.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          else {
            if (!e3.RTCPeerConnection || !i3.userAgent.match(/AppleWebKit\/(\d+)\./))
              return t3.browser = "Not a supported browser.", t3;
            t3.browser = "safari", t3.version = VR(i3.userAgent, /AppleWebKit\/(\d+)\./, 1), t3.supportsUnifiedPlan = e3.RTCRtpTransceiver && "currentDirection" in e3.RTCRtpTransceiver.prototype;
          }
          return t3;
        }(e2), n2 = { browserDetails: r2, commonShim: FC, extractVersion: VR, disableLog: FR, disableWarnings: BR, sdp: DC };
        switch (r2.browser) {
          case "chrome":
            if (!nC || !iC || !t2.shimChrome)
              return i2("Chrome shim is not included in this adapter release."), n2;
            if (null === r2.version)
              return i2("Chrome shim can not determine version, not shimming."), n2;
            i2("adapter.js shimming chrome."), n2.browserShim = nC, VC(e2, r2), UC(e2), qR(e2, r2), YR(e2), iC(e2, r2), QR(e2), tC(e2, r2), XR(e2), $R(e2), ZR(e2), rC(e2, r2), wC(e2), OC(e2), LC(e2), PC(e2, r2), MC(e2), xC(e2, r2);
            break;
          case "firefox":
            if (!fC || !aC || !t2.shimFirefox)
              return i2("Firefox shim is not included in this adapter release."), n2;
            i2("adapter.js shimming firefox."), n2.browserShim = fC, VC(e2, r2), UC(e2), oC(e2, r2), aC(e2, r2), sC(e2), dC(e2), cC(e2), lC(e2), uC(e2), hC(e2), pC(e2), mC(e2), _C(e2), wC(e2), LC(e2), PC(e2, r2), MC(e2);
            break;
          case "safari":
            if (!CC || !t2.shimSafari)
              return i2("Safari shim is not included in this adapter release."), n2;
            i2("adapter.js shimming safari."), n2.browserShim = CC, VC(e2, r2), UC(e2), vC(e2), AC(e2), EC(e2), gC(e2), TC(e2), yC(e2), SC(e2), RC(e2), wC(e2), OC(e2), PC(e2, r2), MC(e2), xC(e2, r2);
            break;
          default:
            i2("Unsupported browser!");
        }
      }({ window: "undefined" == typeof window ? void 0 : window });
      var BC, HC = Object.create, jC = Object.defineProperty, GC = Object.defineProperties, WC = Object.getOwnPropertyDescriptor, JC = Object.getOwnPropertyDescriptors, KC = Object.getOwnPropertyNames, zC = Object.getOwnPropertySymbols, qC = Object.getPrototypeOf, YC = Object.prototype.hasOwnProperty, QC = Object.prototype.propertyIsEnumerable, XC = Reflect.get, $C = Math.pow, ZC = (e2, t2, i2) => t2 in e2 ? jC(e2, t2, { enumerable: true, configurable: true, writable: true, value: i2 }) : e2[t2] = i2, eb = (e2, t2) => {
        for (var i2 in t2 || (t2 = {}))
          YC.call(t2, i2) && ZC(e2, i2, t2[i2]);
        if (zC)
          for (var i2 of zC(t2))
            QC.call(t2, i2) && ZC(e2, i2, t2[i2]);
        return e2;
      }, tb = (e2, t2) => GC(e2, JC(t2)), ib = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports), rb = (e2, t2) => {
        for (var i2 in t2)
          jC(e2, i2, { get: t2[i2], enumerable: true });
      }, nb = (e2, t2, i2) => (i2 = null != e2 ? HC(qC(e2)) : {}, ((e3, t3, i3, r2) => {
        if (t3 && "object" == typeof t3 || "function" == typeof t3)
          for (let n2 of KC(t3))
            !YC.call(e3, n2) && n2 !== i3 && jC(e3, n2, { get: () => t3[n2], enumerable: !(r2 = WC(t3, n2)) || r2.enumerable });
        return e3;
      })(!t2 && e2 && e2.__esModule ? i2 : jC(i2, "default", { value: e2, enumerable: true }), e2)), ob = (e2, t2, i2, r2) => {
        for (var n2, o2 = r2 > 1 ? void 0 : r2 ? WC(t2, i2) : t2, s2 = e2.length - 1; s2 >= 0; s2--)
          (n2 = e2[s2]) && (o2 = (r2 ? n2(t2, i2, o2) : n2(o2)) || o2);
        return r2 && o2 && jC(t2, i2, o2), o2;
      }, sb = (e2, t2, i2) => (ZC(e2, "symbol" != typeof t2 ? t2 + "" : t2, i2), i2), ab = (e2, t2, i2) => XC(qC(e2), i2, t2), cb = (e2, t2, i2) => new Promise((r2, n2) => {
        var o2 = (e3) => {
          try {
            a2(i2.next(e3));
          } catch (t3) {
            n2(t3);
          }
        }, s2 = (e3) => {
          try {
            a2(i2.throw(e3));
          } catch (t3) {
            n2(t3);
          }
        }, a2 = (e3) => e3.done ? r2(e3.value) : Promise.resolve(e3.value).then(o2, s2);
        a2((i2 = i2.apply(e2, t2)).next());
      }), lb = ib((e2, t2) => {
        var i2 = Object.prototype.hasOwnProperty, r2 = "~";
        function n2() {
        }
        function o2(e3, t3, i3) {
          this.fn = e3, this.context = t3, this.once = i3 || false;
        }
        function s2(e3, t3, i3, n3, s3) {
          if ("function" != typeof i3)
            throw new TypeError("The listener must be a function");
          var a3 = new o2(i3, n3 || e3, s3), c3 = r2 ? r2 + t3 : t3;
          return e3._events[c3] ? e3._events[c3].fn ? e3._events[c3] = [e3._events[c3], a3] : e3._events[c3].push(a3) : (e3._events[c3] = a3, e3._eventsCount++), e3;
        }
        function a2(e3, t3) {
          0 == --e3._eventsCount ? e3._events = new n2() : delete e3._events[t3];
        }
        function c2() {
          this._events = new n2(), this._eventsCount = 0;
        }
        Object.create && (n2.prototype = /* @__PURE__ */ Object.create(null), new n2().__proto__ || (r2 = false)), c2.prototype.eventNames = function() {
          var e3, t3, n3 = [];
          if (0 === this._eventsCount)
            return n3;
          for (t3 in e3 = this._events)
            i2.call(e3, t3) && n3.push(r2 ? t3.slice(1) : t3);
          return Object.getOwnPropertySymbols ? n3.concat(Object.getOwnPropertySymbols(e3)) : n3;
        }, c2.prototype.listeners = function(e3) {
          var t3 = r2 ? r2 + e3 : e3, i3 = this._events[t3];
          if (!i3)
            return [];
          if (i3.fn)
            return [i3.fn];
          for (var n3 = 0, o3 = i3.length, s3 = new Array(o3); n3 < o3; n3++)
            s3[n3] = i3[n3].fn;
          return s3;
        }, c2.prototype.listenerCount = function(e3) {
          var t3 = r2 ? r2 + e3 : e3, i3 = this._events[t3];
          return i3 ? i3.fn ? 1 : i3.length : 0;
        }, c2.prototype.emit = function(e3, t3, i3, n3, o3, s3) {
          var a3 = r2 ? r2 + e3 : e3;
          if (!this._events[a3])
            return false;
          var c3, l2, d2 = this._events[a3], u2 = arguments.length;
          if (d2.fn) {
            switch (d2.once && this.removeListener(e3, d2.fn, void 0, true), u2) {
              case 1:
                return d2.fn.call(d2.context), true;
              case 2:
                return d2.fn.call(d2.context, t3), true;
              case 3:
                return d2.fn.call(d2.context, t3, i3), true;
              case 4:
                return d2.fn.call(d2.context, t3, i3, n3), true;
              case 5:
                return d2.fn.call(d2.context, t3, i3, n3, o3), true;
              case 6:
                return d2.fn.call(d2.context, t3, i3, n3, o3, s3), true;
            }
            for (l2 = 1, c3 = new Array(u2 - 1); l2 < u2; l2++)
              c3[l2 - 1] = arguments[l2];
            d2.fn.apply(d2.context, c3);
          } else {
            var h2, p2 = d2.length;
            for (l2 = 0; l2 < p2; l2++)
              switch (d2[l2].once && this.removeListener(e3, d2[l2].fn, void 0, true), u2) {
                case 1:
                  d2[l2].fn.call(d2[l2].context);
                  break;
                case 2:
                  d2[l2].fn.call(d2[l2].context, t3);
                  break;
                case 3:
                  d2[l2].fn.call(d2[l2].context, t3, i3);
                  break;
                case 4:
                  d2[l2].fn.call(d2[l2].context, t3, i3, n3);
                  break;
                default:
                  if (!c3)
                    for (h2 = 1, c3 = new Array(u2 - 1); h2 < u2; h2++)
                      c3[h2 - 1] = arguments[h2];
                  d2[l2].fn.apply(d2[l2].context, c3);
              }
          }
          return true;
        }, c2.prototype.on = function(e3, t3, i3) {
          return s2(this, e3, t3, i3, false);
        }, c2.prototype.once = function(e3, t3, i3) {
          return s2(this, e3, t3, i3, true);
        }, c2.prototype.removeListener = function(e3, t3, i3, n3) {
          var o3 = r2 ? r2 + e3 : e3;
          if (!this._events[o3])
            return this;
          if (!t3)
            return a2(this, o3), this;
          var s3 = this._events[o3];
          if (s3.fn)
            s3.fn === t3 && (!n3 || s3.once) && (!i3 || s3.context === i3) && a2(this, o3);
          else {
            for (var c3 = 0, l2 = [], d2 = s3.length; c3 < d2; c3++)
              (s3[c3].fn !== t3 || n3 && !s3[c3].once || i3 && s3[c3].context !== i3) && l2.push(s3[c3]);
            l2.length ? this._events[o3] = 1 === l2.length ? l2[0] : l2 : a2(this, o3);
          }
          return this;
        }, c2.prototype.removeAllListeners = function(e3) {
          var t3;
          return e3 ? (t3 = r2 ? r2 + e3 : e3, this._events[t3] && a2(this, t3)) : (this._events = new n2(), this._eventsCount = 0), this;
        }, c2.prototype.off = c2.prototype.removeListener, c2.prototype.addListener = c2.prototype.on, c2.prefixed = r2, c2.EventEmitter = c2, void 0 !== t2 && (t2.exports = c2);
      }), db = ib((e2, t2) => {
        var i2 = t2.exports = { v: [{ name: "version", reg: /^(\d*)$/ }], o: [{ name: "origin", reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/, names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"], format: "%s %s %d %s IP%d %s" }], s: [{ name: "name" }], i: [{ name: "description" }], u: [{ name: "uri" }], e: [{ name: "email" }], p: [{ name: "phone" }], z: [{ name: "timezones" }], r: [{ name: "repeats" }], t: [{ name: "timing", reg: /^(\d*) (\d*)/, names: ["start", "stop"], format: "%d %d" }], c: [{ name: "connection", reg: /^IN IP(\d) (\S*)/, names: ["version", "ip"], format: "IN IP%d %s" }], b: [{ push: "bandwidth", reg: /^(TIAS|AS|CT|RR|RS):(\d*)/, names: ["type", "limit"], format: "%s:%s" }], m: [{ reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/, names: ["type", "port", "protocol", "payloads"], format: "%s %d %s %s" }], a: [{ push: "rtp", reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/, names: ["payload", "codec", "rate", "encoding"], format: function(e3) {
          return e3.encoding ? "rtpmap:%d %s/%s/%s" : e3.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
        } }, { push: "fmtp", reg: /^fmtp:(\d*) ([\S| ]*)/, names: ["payload", "config"], format: "fmtp:%d %s" }, { name: "control", reg: /^control:(.*)/, format: "control:%s" }, { name: "rtcp", reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/, names: ["port", "netType", "ipVer", "address"], format: function(e3) {
          return null != e3.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
        } }, { push: "rtcpFbTrrInt", reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/, names: ["payload", "value"], format: "rtcp-fb:%s trr-int %d" }, { push: "rtcpFb", reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/, names: ["payload", "type", "subtype"], format: function(e3) {
          return null != e3.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
        } }, { push: "ext", reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/, names: ["value", "direction", "encrypt-uri", "uri", "config"], format: function(e3) {
          return "extmap:%d" + (e3.direction ? "/%s" : "%v") + (e3["encrypt-uri"] ? " %s" : "%v") + " %s" + (e3.config ? " %s" : "");
        } }, { name: "extmapAllowMixed", reg: /^(extmap-allow-mixed)/ }, { push: "crypto", reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/, names: ["id", "suite", "config", "sessionConfig"], format: function(e3) {
          return null != e3.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
        } }, { name: "setup", reg: /^setup:(\w*)/, format: "setup:%s" }, { name: "connectionType", reg: /^connection:(new|existing)/, format: "connection:%s" }, { name: "mid", reg: /^mid:([^\s]*)/, format: "mid:%s" }, { name: "msid", reg: /^msid:(.*)/, format: "msid:%s" }, { name: "ptime", reg: /^ptime:(\d*(?:\.\d*)*)/, format: "ptime:%d" }, { name: "maxptime", reg: /^maxptime:(\d*(?:\.\d*)*)/, format: "maxptime:%d" }, { name: "direction", reg: /^(sendrecv|recvonly|sendonly|inactive)/ }, { name: "icelite", reg: /^(ice-lite)/ }, { name: "iceUfrag", reg: /^ice-ufrag:(\S*)/, format: "ice-ufrag:%s" }, { name: "icePwd", reg: /^ice-pwd:(\S*)/, format: "ice-pwd:%s" }, { name: "fingerprint", reg: /^fingerprint:(\S*) (\S*)/, names: ["type", "hash"], format: "fingerprint:%s %s" }, { push: "candidates", reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/, names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"], format: function(e3) {
          var t3 = "candidate:%s %d %s %d %s %d typ %s";
          return t3 += null != e3.raddr ? " raddr %s rport %d" : "%v%v", t3 += null != e3.tcptype ? " tcptype %s" : "%v", null != e3.generation && (t3 += " generation %d"), t3 += null != e3["network-id"] ? " network-id %d" : "%v", t3 += null != e3["network-cost"] ? " network-cost %d" : "%v";
        } }, { name: "endOfCandidates", reg: /^(end-of-candidates)/ }, { name: "remoteCandidates", reg: /^remote-candidates:(.*)/, format: "remote-candidates:%s" }, { name: "iceOptions", reg: /^ice-options:(\S*)/, format: "ice-options:%s" }, { push: "ssrcs", reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/, names: ["id", "attribute", "value"], format: function(e3) {
          var t3 = "ssrc:%d";
          return null != e3.attribute && (t3 += " %s", null != e3.value && (t3 += ":%s")), t3;
        } }, { push: "ssrcGroups", reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/, names: ["semantics", "ssrcs"], format: "ssrc-group:%s %s" }, { name: "msidSemantic", reg: /^msid-semantic:\s?(\w*) (\S*)/, names: ["semantic", "token"], format: "msid-semantic: %s %s" }, { push: "groups", reg: /^group:(\w*) (.*)/, names: ["type", "mids"], format: "group:%s %s" }, { name: "rtcpMux", reg: /^(rtcp-mux)/ }, { name: "rtcpRsize", reg: /^(rtcp-rsize)/ }, { name: "sctpmap", reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/, names: ["sctpmapNumber", "app", "maxMessageSize"], format: function(e3) {
          return null != e3.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
        } }, { name: "xGoogleFlag", reg: /^x-google-flag:([^\s]*)/, format: "x-google-flag:%s" }, { push: "rids", reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/, names: ["id", "direction", "params"], format: function(e3) {
          return e3.params ? "rid:%s %s %s" : "rid:%s %s";
        } }, { push: "imageattrs", reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"), names: ["pt", "dir1", "attrs1", "dir2", "attrs2"], format: function(e3) {
          return "imageattr:%s %s %s" + (e3.dir2 ? " %s %s" : "");
        } }, { name: "simulcast", reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"), names: ["dir1", "list1", "dir2", "list2"], format: function(e3) {
          return "simulcast:%s %s" + (e3.dir2 ? " %s %s" : "");
        } }, { name: "simulcast_03", reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/, names: ["value"], format: "simulcast: %s" }, { name: "framerate", reg: /^framerate:(\d+(?:$|\.\d+))/, format: "framerate:%s" }, { name: "sourceFilter", reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/, names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"], format: "source-filter: %s %s %s %s %s" }, { name: "bundleOnly", reg: /^(bundle-only)/ }, { name: "label", reg: /^label:(.+)/, format: "label:%s" }, { name: "sctpPort", reg: /^sctp-port:(\d+)$/, format: "sctp-port:%s" }, { name: "maxMessageSize", reg: /^max-message-size:(\d+)$/, format: "max-message-size:%s" }, { push: "tsRefClocks", reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/, names: ["clksrc", "clksrcExt"], format: function(e3) {
          return "ts-refclk:%s" + (null != e3.clksrcExt ? "=%s" : "");
        } }, { name: "mediaClk", reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/, names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"], format: function(e3) {
          var t3 = "mediaclk:";
          return t3 += null != e3.id ? "id=%s %s" : "%v%s", t3 += null != e3.mediaClockValue ? "=%s" : "", t3 += null != e3.rateNumerator ? " rate=%s" : "", t3 += null != e3.rateDenominator ? "/%s" : "";
        } }, { name: "keywords", reg: /^keywds:(.+)$/, format: "keywds:%s" }, { name: "content", reg: /^content:(.+)/, format: "content:%s" }, { name: "bfcpFloorCtrl", reg: /^floorctrl:(c-only|s-only|c-s)/, format: "floorctrl:%s" }, { name: "bfcpConfId", reg: /^confid:(\d+)/, format: "confid:%s" }, { name: "bfcpUserId", reg: /^userid:(\d+)/, format: "userid:%s" }, { name: "bfcpFloorId", reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/, names: ["id", "mStream"], format: "floorid:%s mstrm:%s" }, { push: "invalid", names: ["value"] }] };
        Object.keys(i2).forEach(function(e3) {
          i2[e3].forEach(function(e4) {
            e4.reg || (e4.reg = /(.*)/), e4.format || (e4.format = "%s");
          });
        });
      }), ub = ib((e2) => {
        var t2 = function(e3) {
          return String(Number(e3)) === e3 ? Number(e3) : e3;
        }, i2 = function(e3, i3, r3) {
          var n3 = e3.name && e3.names;
          e3.push && !i3[e3.push] ? i3[e3.push] = [] : n3 && !i3[e3.name] && (i3[e3.name] = {});
          var o3 = e3.push ? {} : n3 ? i3[e3.name] : i3;
          (function(e4, i4, r4, n4) {
            if (n4 && !r4)
              i4[n4] = t2(e4[1]);
            else
              for (var o4 = 0; o4 < r4.length; o4 += 1)
                null != e4[o4 + 1] && (i4[r4[o4]] = t2(e4[o4 + 1]));
          })(r3.match(e3.reg), o3, e3.names, e3.name), e3.push && i3[e3.push].push(o3);
        }, r2 = db(), n2 = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
        e2.parse = function(e3) {
          var t3 = {}, o3 = [], s2 = t3;
          return e3.split(/(\r\n|\r|\n)/).filter(n2).forEach(function(e4) {
            var t4 = e4[0], n3 = e4.slice(2);
            "m" === t4 && (o3.push({ rtp: [], fmtp: [] }), s2 = o3[o3.length - 1]);
            for (var a2 = 0; a2 < (r2[t4] || []).length; a2 += 1) {
              var c2 = r2[t4][a2];
              if (c2.reg.test(n3))
                return i2(c2, s2, n3);
            }
          }), t3.media = o3, t3;
        };
        var o2 = function(e3, i3) {
          var r3 = i3.split(/=(.+)/, 2);
          return 2 === r3.length ? e3[r3[0]] = t2(r3[1]) : 1 === r3.length && i3.length > 1 && (e3[r3[0]] = void 0), e3;
        };
        e2.parseParams = function(e3) {
          return e3.split(/;\s?/).reduce(o2, {});
        }, e2.parseFmtpConfig = e2.parseParams, e2.parsePayloads = function(e3) {
          return e3.toString().split(" ").map(Number);
        }, e2.parseRemoteCandidates = function(e3) {
          for (var i3 = [], r3 = e3.split(" ").map(t2), n3 = 0; n3 < r3.length; n3 += 3)
            i3.push({ component: r3[n3], ip: r3[n3 + 1], port: r3[n3 + 2] });
          return i3;
        }, e2.parseImageAttributes = function(e3) {
          return e3.split(" ").map(function(e4) {
            return e4.substring(1, e4.length - 1).split(",").reduce(o2, {});
          });
        }, e2.parseSimulcastStreamList = function(e3) {
          return e3.split(";").map(function(e4) {
            return e4.split(",").map(function(e5) {
              var i3, r3 = false;
              return "~" !== e5[0] ? i3 = t2(e5) : (i3 = t2(e5.substring(1, e5.length)), r3 = true), { scid: i3, paused: r3 };
            });
          });
        };
      }), hb = ib((e2, t2) => {
        var i2 = db(), r2 = /%[sdv%]/g, n2 = function(e3) {
          var t3 = 1, i3 = arguments, n3 = i3.length;
          return e3.replace(r2, function(e4) {
            if (t3 >= n3)
              return e4;
            var r3 = i3[t3];
            switch (t3 += 1, e4) {
              case "%%":
                return "%";
              case "%s":
                return String(r3);
              case "%d":
                return Number(r3);
              case "%v":
                return "";
            }
          });
        }, o2 = function(e3, t3, i3) {
          var r3 = [e3 + "=" + (t3.format instanceof Function ? t3.format(t3.push ? i3 : i3[t3.name]) : t3.format)];
          if (t3.names)
            for (var o3 = 0; o3 < t3.names.length; o3 += 1) {
              var s3 = t3.names[o3];
              t3.name ? r3.push(i3[t3.name][s3]) : r3.push(i3[t3.names[o3]]);
            }
          else
            r3.push(i3[t3.name]);
          return n2.apply(null, r3);
        }, s2 = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], a2 = ["i", "c", "b", "a"];
        t2.exports = function(e3, t3) {
          t3 = t3 || {}, null == e3.version && (e3.version = 0), null == e3.name && (e3.name = " "), e3.media.forEach(function(e4) {
            null == e4.payloads && (e4.payloads = "");
          });
          var r3 = t3.outerOrder || s2, n3 = t3.innerOrder || a2, c2 = [];
          return r3.forEach(function(t4) {
            i2[t4].forEach(function(i3) {
              i3.name in e3 && null != e3[i3.name] ? c2.push(o2(t4, i3, e3)) : i3.push in e3 && null != e3[i3.push] && e3[i3.push].forEach(function(e4) {
                c2.push(o2(t4, i3, e4));
              });
            });
          }), e3.media.forEach(function(e4) {
            c2.push(o2("m", i2.m[0], e4)), n3.forEach(function(t4) {
              i2[t4].forEach(function(i3) {
                i3.name in e4 && null != e4[i3.name] ? c2.push(o2(t4, i3, e4)) : i3.push in e4 && null != e4[i3.push] && e4[i3.push].forEach(function(e5) {
                  c2.push(o2(t4, i3, e5));
                });
              });
            });
          }), c2.join("\r\n") + "\r\n";
        };
      }), pb = ib((e2) => {
        var t2 = ub(), i2 = hb();
        e2.write = i2, e2.parse = t2.parse, e2.parseParams = t2.parseParams, e2.parseFmtpConfig = t2.parseFmtpConfig, e2.parsePayloads = t2.parsePayloads, e2.parseRemoteCandidates = t2.parseRemoteCandidates, e2.parseImageAttributes = t2.parseImageAttributes, e2.parseSimulcastStreamList = t2.parseSimulcastStreamList;
      }), mb = ib((e2, t2) => {
        var i2 = t2.exports = { v: [{ name: "version", reg: /^(\d*)$/ }], o: [{ name: "origin", reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/, names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"], format: "%s %s %d %s IP%d %s" }], s: [{ name: "name" }], i: [{ name: "description" }], u: [{ name: "uri" }], e: [{ name: "email" }], p: [{ name: "phone" }], z: [{ name: "timezones" }], r: [{ name: "repeats" }], t: [{ name: "timing", reg: /^(\d*) (\d*)/, names: ["start", "stop"], format: "%d %d" }], c: [{ name: "connection", reg: /^IN IP(\d) (\S*)/, names: ["version", "ip"], format: "IN IP%d %s" }], b: [{ push: "bandwidth", reg: /^(TIAS|AS|CT|RR|RS):(\d*)/, names: ["type", "limit"], format: "%s:%s" }], m: [{ reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/, names: ["type", "port", "protocol", "payloads"], format: "%s %d %s %s" }], a: [{ push: "rtp", reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/, names: ["payload", "codec", "rate", "encoding"], format: function(e3) {
          return e3.encoding ? "rtpmap:%d %s/%s/%s" : e3.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
        } }, { push: "fmtp", reg: /^fmtp:(\d*) ([\S| ]*)/, names: ["payload", "config"], format: "fmtp:%d %s" }, { name: "control", reg: /^control:(.*)/, format: "control:%s" }, { name: "rtcp", reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/, names: ["port", "netType", "ipVer", "address"], format: function(e3) {
          return null != e3.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
        } }, { push: "rtcpFbTrrInt", reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/, names: ["payload", "value"], format: "rtcp-fb:%s trr-int %d" }, { push: "rtcpFb", reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/, names: ["payload", "type", "subtype"], format: function(e3) {
          return null != e3.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
        } }, { push: "ext", reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/, names: ["value", "direction", "encrypt-uri", "uri", "config"], format: function(e3) {
          return "extmap:%d" + (e3.direction ? "/%s" : "%v") + (e3["encrypt-uri"] ? " %s" : "%v") + " %s" + (e3.config ? " %s" : "");
        } }, { name: "extmapAllowMixed", reg: /^(extmap-allow-mixed)/ }, { push: "crypto", reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/, names: ["id", "suite", "config", "sessionConfig"], format: function(e3) {
          return null != e3.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
        } }, { name: "setup", reg: /^setup:(\w*)/, format: "setup:%s" }, { name: "connectionType", reg: /^connection:(new|existing)/, format: "connection:%s" }, { name: "mid", reg: /^mid:([^\s]*)/, format: "mid:%s" }, { name: "msid", reg: /^msid:(.*)/, format: "msid:%s" }, { name: "ptime", reg: /^ptime:(\d*(?:\.\d*)*)/, format: "ptime:%d" }, { name: "maxptime", reg: /^maxptime:(\d*(?:\.\d*)*)/, format: "maxptime:%d" }, { name: "direction", reg: /^(sendrecv|recvonly|sendonly|inactive)/ }, { name: "icelite", reg: /^(ice-lite)/ }, { name: "iceUfrag", reg: /^ice-ufrag:(\S*)/, format: "ice-ufrag:%s" }, { name: "icePwd", reg: /^ice-pwd:(\S*)/, format: "ice-pwd:%s" }, { name: "fingerprint", reg: /^fingerprint:(\S*) (\S*)/, names: ["type", "hash"], format: "fingerprint:%s %s" }, { push: "candidates", reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/, names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"], format: function(e3) {
          var t3 = "candidate:%s %d %s %d %s %d typ %s";
          return t3 += null != e3.raddr ? " raddr %s rport %d" : "%v%v", t3 += null != e3.tcptype ? " tcptype %s" : "%v", null != e3.generation && (t3 += " generation %d"), t3 += null != e3["network-id"] ? " network-id %d" : "%v", t3 += null != e3["network-cost"] ? " network-cost %d" : "%v";
        } }, { name: "endOfCandidates", reg: /^(end-of-candidates)/ }, { name: "remoteCandidates", reg: /^remote-candidates:(.*)/, format: "remote-candidates:%s" }, { name: "iceOptions", reg: /^ice-options:(\S*)/, format: "ice-options:%s" }, { push: "ssrcs", reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/, names: ["id", "attribute", "value"], format: function(e3) {
          var t3 = "ssrc:%d";
          return null != e3.attribute && (t3 += " %s", null != e3.value && (t3 += ":%s")), t3;
        } }, { push: "ssrcGroups", reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/, names: ["semantics", "ssrcs"], format: "ssrc-group:%s %s" }, { name: "msidSemantic", reg: /^msid-semantic:\s?(\w*) (\S*)/, names: ["semantic", "token"], format: "msid-semantic: %s %s" }, { push: "groups", reg: /^group:(\w*) (.*)/, names: ["type", "mids"], format: "group:%s %s" }, { name: "rtcpMux", reg: /^(rtcp-mux)/ }, { name: "rtcpRsize", reg: /^(rtcp-rsize)/ }, { name: "sctpmap", reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/, names: ["sctpmapNumber", "app", "maxMessageSize"], format: function(e3) {
          return null != e3.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
        } }, { name: "xGoogleFlag", reg: /^x-google-flag:([^\s]*)/, format: "x-google-flag:%s" }, { push: "rids", reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/, names: ["id", "direction", "params"], format: function(e3) {
          return e3.params ? "rid:%s %s %s" : "rid:%s %s";
        } }, { push: "imageattrs", reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"), names: ["pt", "dir1", "attrs1", "dir2", "attrs2"], format: function(e3) {
          return "imageattr:%s %s %s" + (e3.dir2 ? " %s %s" : "");
        } }, { name: "simulcast", reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"), names: ["dir1", "list1", "dir2", "list2"], format: function(e3) {
          return "simulcast:%s %s" + (e3.dir2 ? " %s %s" : "");
        } }, { name: "simulcast_03", reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/, names: ["value"], format: "simulcast: %s" }, { name: "framerate", reg: /^framerate:(\d+(?:$|\.\d+))/, format: "framerate:%s" }, { name: "sourceFilter", reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/, names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"], format: "source-filter: %s %s %s %s %s" }, { name: "bundleOnly", reg: /^(bundle-only)/ }, { name: "label", reg: /^label:(.+)/, format: "label:%s" }, { name: "sctpPort", reg: /^sctp-port:(\d+)$/, format: "sctp-port:%s" }, { name: "maxMessageSize", reg: /^max-message-size:(\d+)$/, format: "max-message-size:%s" }, { push: "tsRefClocks", reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/, names: ["clksrc", "clksrcExt"], format: function(e3) {
          return "ts-refclk:%s" + (null != e3.clksrcExt ? "=%s" : "");
        } }, { name: "mediaClk", reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/, names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"], format: function(e3) {
          var t3 = "mediaclk:";
          return t3 += null != e3.id ? "id=%s %s" : "%v%s", t3 += null != e3.mediaClockValue ? "=%s" : "", t3 += null != e3.rateNumerator ? " rate=%s" : "", t3 += null != e3.rateDenominator ? "/%s" : "";
        } }, { name: "keywords", reg: /^keywds:(.+)$/, format: "keywds:%s" }, { name: "content", reg: /^content:(.+)/, format: "content:%s" }, { name: "bfcpFloorCtrl", reg: /^floorctrl:(c-only|s-only|c-s)/, format: "floorctrl:%s" }, { name: "bfcpConfId", reg: /^confid:(\d+)/, format: "confid:%s" }, { name: "bfcpUserId", reg: /^userid:(\d+)/, format: "userid:%s" }, { name: "bfcpFloorId", reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/, names: ["id", "mStream"], format: "floorid:%s mstrm:%s" }, { push: "invalid", names: ["value"] }] };
        Object.keys(i2).forEach(function(e3) {
          i2[e3].forEach(function(e4) {
            e4.reg || (e4.reg = /(.*)/), e4.format || (e4.format = "%s");
          });
        });
      }), _b = ib((e2) => {
        var t2 = function(e3) {
          return String(Number(e3)) === e3 ? Number(e3) : e3;
        }, i2 = function(e3, i3, r3) {
          var n3 = e3.name && e3.names;
          e3.push && !i3[e3.push] ? i3[e3.push] = [] : n3 && !i3[e3.name] && (i3[e3.name] = {});
          var o3 = e3.push ? {} : n3 ? i3[e3.name] : i3;
          (function(e4, i4, r4, n4) {
            if (n4 && !r4)
              i4[n4] = t2(e4[1]);
            else
              for (var o4 = 0; o4 < r4.length; o4 += 1)
                null != e4[o4 + 1] && (i4[r4[o4]] = t2(e4[o4 + 1]));
          })(r3.match(e3.reg), o3, e3.names, e3.name), e3.push && i3[e3.push].push(o3);
        }, r2 = mb(), n2 = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
        e2.parse = function(e3) {
          var t3 = {}, o3 = [], s2 = t3;
          return e3.split(/(\r\n|\r|\n)/).filter(n2).forEach(function(e4) {
            var t4 = e4[0], n3 = e4.slice(2);
            "m" === t4 && (o3.push({ rtp: [], fmtp: [] }), s2 = o3[o3.length - 1]);
            for (var a2 = 0; a2 < (r2[t4] || []).length; a2 += 1) {
              var c2 = r2[t4][a2];
              if (c2.reg.test(n3))
                return i2(c2, s2, n3);
            }
          }), t3.media = o3, t3;
        };
        var o2 = function(e3, i3) {
          var r3 = i3.split(/=(.+)/, 2);
          return 2 === r3.length ? e3[r3[0]] = t2(r3[1]) : 1 === r3.length && i3.length > 1 && (e3[r3[0]] = void 0), e3;
        };
        e2.parseParams = function(e3) {
          return e3.split(/;\s?/).reduce(o2, {});
        }, e2.parseFmtpConfig = e2.parseParams, e2.parsePayloads = function(e3) {
          return e3.toString().split(" ").map(Number);
        }, e2.parseRemoteCandidates = function(e3) {
          for (var i3 = [], r3 = e3.split(" ").map(t2), n3 = 0; n3 < r3.length; n3 += 3)
            i3.push({ component: r3[n3], ip: r3[n3 + 1], port: r3[n3 + 2] });
          return i3;
        }, e2.parseImageAttributes = function(e3) {
          return e3.split(" ").map(function(e4) {
            return e4.substring(1, e4.length - 1).split(",").reduce(o2, {});
          });
        }, e2.parseSimulcastStreamList = function(e3) {
          return e3.split(";").map(function(e4) {
            return e4.split(",").map(function(e5) {
              var i3, r3 = false;
              return "~" !== e5[0] ? i3 = t2(e5) : (i3 = t2(e5.substring(1, e5.length)), r3 = true), { scid: i3, paused: r3 };
            });
          });
        };
      }), fb = ib((e2, t2) => {
        var i2 = mb(), r2 = /%[sdv%]/g, n2 = function(e3) {
          var t3 = 1, i3 = arguments, n3 = i3.length;
          return e3.replace(r2, function(e4) {
            if (t3 >= n3)
              return e4;
            var r3 = i3[t3];
            switch (t3 += 1, e4) {
              case "%%":
                return "%";
              case "%s":
                return String(r3);
              case "%d":
                return Number(r3);
              case "%v":
                return "";
            }
          });
        }, o2 = function(e3, t3, i3) {
          var r3 = [e3 + "=" + (t3.format instanceof Function ? t3.format(t3.push ? i3 : i3[t3.name]) : t3.format)];
          if (t3.names)
            for (var o3 = 0; o3 < t3.names.length; o3 += 1) {
              var s3 = t3.names[o3];
              t3.name ? r3.push(i3[t3.name][s3]) : r3.push(i3[t3.names[o3]]);
            }
          else
            r3.push(i3[t3.name]);
          return n2.apply(null, r3);
        }, s2 = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], a2 = ["i", "c", "b", "a"];
        t2.exports = function(e3, t3) {
          t3 = t3 || {}, null == e3.version && (e3.version = 0), null == e3.name && (e3.name = " "), e3.media.forEach(function(e4) {
            null == e4.payloads && (e4.payloads = "");
          });
          var r3 = t3.outerOrder || s2, n3 = t3.innerOrder || a2, c2 = [];
          return r3.forEach(function(t4) {
            i2[t4].forEach(function(i3) {
              i3.name in e3 && null != e3[i3.name] ? c2.push(o2(t4, i3, e3)) : i3.push in e3 && null != e3[i3.push] && e3[i3.push].forEach(function(e4) {
                c2.push(o2(t4, i3, e4));
              });
            });
          }), e3.media.forEach(function(e4) {
            c2.push(o2("m", i2.m[0], e4)), n3.forEach(function(t4) {
              i2[t4].forEach(function(i3) {
                i3.name in e4 && null != e4[i3.name] ? c2.push(o2(t4, i3, e4)) : i3.push in e4 && null != e4[i3.push] && e4[i3.push].forEach(function(e5) {
                  c2.push(o2(t4, i3, e5));
                });
              });
            });
          }), c2.join("\r\n") + "\r\n";
        };
      }), gb = ib((e2) => {
        var t2 = _b(), i2 = fb();
        e2.write = i2, e2.parse = t2.parse, e2.parseParams = t2.parseParams, e2.parseFmtpConfig = t2.parseFmtpConfig, e2.parsePayloads = t2.parsePayloads, e2.parseRemoteCandidates = t2.parseRemoteCandidates, e2.parseImageAttributes = t2.parseImageAttributes, e2.parseSimulcastStreamList = t2.parseSimulcastStreamList;
      }), Tb = nb(lb()), Eb = ((BC = Eb || {})[BC.INVALID_PARAMETER = 4096] = "INVALID_PARAMETER", BC[BC.INVALID_OPERATION = 4097] = "INVALID_OPERATION", BC[BC.NOT_SUPPORTED = 4098] = "NOT_SUPPORTED", BC[BC.DEVICE_NOT_FOUND = 4099] = "DEVICE_NOT_FOUND", BC[BC.INITIALIZE_FAILED = 4100] = "INITIALIZE_FAILED", BC[BC.SIGNAL_CHANNEL_SETUP_FAILED = 16385] = "SIGNAL_CHANNEL_SETUP_FAILED", BC[BC.SIGNAL_CHANNEL_ERROR = 16386] = "SIGNAL_CHANNEL_ERROR", BC[BC.ICE_TRANSPORT_ERROR = 16387] = "ICE_TRANSPORT_ERROR", BC[BC.JOIN_ROOM_FAILED = 16388] = "JOIN_ROOM_FAILED", BC[BC.CREATE_OFFER_FAILED = 16389] = "CREATE_OFFER_FAILED", BC[BC.SIGNAL_CHANNEL_RECONNECTION_FAILED = 16390] = "SIGNAL_CHANNEL_RECONNECTION_FAILED", BC[BC.UPLINK_RECONNECTION_FAILED = 16391] = "UPLINK_RECONNECTION_FAILED", BC[BC.DOWNLINK_RECONNECTION_FAILED = 16392] = "DOWNLINK_RECONNECTION_FAILED", BC[BC.REMOTE_STREAM_NOT_EXIST = 16400] = "REMOTE_STREAM_NOT_EXIST", BC[BC.CLIENT_BANNED = 16448] = "CLIENT_BANNED", BC[BC.SERVER_TIMEOUT = 16449] = "SERVER_TIMEOUT", BC[BC.SUBSCRIPTION_TIMEOUT = 16450] = "SUBSCRIPTION_TIMEOUT", BC[BC.PLAY_NOT_ALLOWED = 16451] = "PLAY_NOT_ALLOWED", BC[BC.DEVICE_AUTO_RECOVER_FAILED = 16452] = "DEVICE_AUTO_RECOVER_FAILED", BC[BC.START_PUBLISH_CDN_FAILED = 16453] = "START_PUBLISH_CDN_FAILED", BC[BC.STOP_PUBLISH_CDN_FAILED = 16454] = "STOP_PUBLISH_CDN_FAILED", BC[BC.START_MIX_TRANSCODE_FAILED = 16455] = "START_MIX_TRANSCODE_FAILED", BC[BC.STOP_MIX_TRANSCODE_FAILED = 16456] = "STOP_MIX_TRANSCODE_FAILED", BC[BC.NOT_SUPPORTED_H264 = 16457] = "NOT_SUPPORTED_H264", BC[BC.SWITCH_ROLE_FAILED = 16458] = "SWITCH_ROLE_FAILED", BC[BC.API_CALL_TIMEOUT = 16459] = "API_CALL_TIMEOUT", BC[BC.SCHEDULE_FAILED = 16460] = "SCHEDULE_FAILED", BC[BC.API_CALL_ABORTED = 16461] = "API_CALL_ABORTED", BC[BC.SPC_INITIALIZED_FAILED = 16462] = "SPC_INITIALIZED_FAILED", BC[BC.UNKNOWN = 65535] = "UNKNOWN", BC), Sb = Eb, Ib = class extends Error {
        constructor(e2) {
          let { name: t2 = "RtcError", message: i2, code: r2 = Sb.UNKNOWN, extraCode: n2 = 0, constraint: o2 } = e2, s2 = "<".concat(function(e3) {
            for (let t3 in Sb)
              if (Sb[t3] === e3)
                return t3;
            return "UNKNOWN";
          }(r2), " 0x").concat(r2.toString(16), ">"), a2 = "".concat(i2).concat(o2 ? " constraint: ".concat(o2) : "").concat(null != i2 && i2.includes(s2) ? "" : " ".concat(s2));
          super(a2), sb(this, "code"), sb(this, "extraCode"), sb(this, "message"), sb(this, "originMessage"), sb(this, "name"), sb(this, "constraint"), this.code = r2, this.extraCode = n2, this.name = t2, this.message = a2, this.constraint = o2, this.originMessage = i2;
        }
        getCode() {
          return this.code;
        }
        getExtraCode() {
          return this.extraCode;
        }
        toString() {
          return this.originMessage;
        }
      }, vb = Ib, yb = ((/* @__PURE__ */ new Date()).getTime(), 0), Ab = function() {
        return (/* @__PURE__ */ new Date()).getTime() + yb;
      }, Rb = function() {
        let e2 = /* @__PURE__ */ new Date();
        return e2.setTime(Ab()), e2.toLocaleString();
      }, Cb = {};
      rb(Cb, { bytes2ms: () => yw, convertObjectNumberToInt: () => pO, copyProperties: () => vw, deepClone: () => iO, deepMerge: () => tO, fibonacci: () => Dw, formatedTime: () => sO, getAbilityConfigUrl: () => dw, getConstructorName: () => Ww, getContainerFromElement: () => nO, getEnv: () => mw, getInternalVersion: () => Yw, getLoggerUrl: () => fw, getMuteStateFromFlag: () => $w, getNetworkType: () => Tw, getNumNetworkType: () => Iw, getReconnectionTimeout: () => ww, getStringByteLength: () => lO, getTurnServer: () => Zw, getUint32Version: () => hO, getValueType: () => Ow, getViewListFromView: () => rO, glog: () => bw, ipv4ToUint32: () => eO, isArray: () => Fw, isAudioWorkletSupported: () => Jw, isBoolean: () => Vw, isConstructor: () => Gw, isEmpty: () => Xw, isFunction: () => Pw, isLangChinese: () => kw, isMediaStreamTrack: () => Bw, isNumber: () => xw, isObject: () => Uw, isOverseaSdkAppId: () => _w, isPlainObject: () => Nw, isPortrait: () => dO, isPromise: () => jw, isRemoteTrack: () => Hw, isString: () => Lw, isUndefined: () => Mw, loadImage: () => uO, ms2bytes: () => Rw, ms2samples: () => Cw, performanceNow: () => zw, promiseAny: () => Kw, samples2ms: () => Aw, setNetworkType: () => Sw, stringify: () => aO, stringifyIncludeValue: () => cO });
      var bb = {};
      rb(bb, { AUDIO_MUTE_BIT: () => pk, AUDIO_STAT_BIT: () => hk, AUX_STAT_BIT: () => uk, AUX_STREAM_MSID: () => fk, BACKEND_ENV: () => ak, BASE_DOC_URL: () => Gb, BASE_HOST: () => Fb, CAPABILITIES_KEYS: () => aN, CLASS_NAME: () => qk, CLOUD_CONSOLE_URL: () => jb, DATA_FREEZE_TIMING: () => Hk, DOC_URL: () => Wb, DTLS_STATE_UNKNOWN: () => Ck, ENV_NAME: () => Yb, EXCHANGE_SDP_TIMEOUT: () => xk, INTERVAL: () => oN, IS_WORKER: () => Mb, IS_WORKLET: () => Lb, KIBANA_EVENT: () => Pk, LOCAL_STREAM_PUBLISH_STATE: () => Bk, LOGGER_CMD_TYPE: () => qb, LOGGER_DOMAIN: () => Jb, LOGGER_DOMAIN_OVERSEA: () => Kb, LOG_LEVEL: () => Qb, LOG_LEVEL_NAME: () => Zk, MAIN_STREAM_MSID: () => _k, MICROPHONE_COMMUNICATIONS: () => $k, MICROPHONE_DEFAULT: () => Qk, NAME: () => ok, NETWORK_TYPE: () => Zb, NOT_SUPPORTED_H264: () => Fk, PAUSED_RETRY_COUNT: () => Yk, PEERCONNECTION_CONNECTING_TIMEOUT: () => Jk, PEER_CONNECTION_STATE: () => bk, PEER_LEAVE_REASON: () => eN, RAF: () => nN, RECOVER_CAPTURE_INTERVAL: () => iN, REMOTE_STREAM_TYPE_AUX: () => Tk, REMOTE_STREAM_TYPE_MAIN: () => gk, RENDER_FREEZE_TIMING: () => jk, RIC: () => rN, SCHEDULE_DOMAIN: () => Kk, SCHEDULE_TIMEOUT: () => zk, SDP_SEMANTICS_PLAN_B: () => Uk, SDP_SEMANTICS_UNIFIED_PLAN: () => Vk, SECOND_HOST: () => Bb, SIGNAL_PING_PONG_INTERVAL: () => $b, SIGNAL_PING_TIMEOUT: () => Xb, SIGNAL_RECONNECTION_COUNT: () => Ok, SMALL_STAT_BIT: () => dk, SPEAKER_DEFAULT: () => Xk, STORAGE_EXPIRES_TIME: () => ek, STREAM_TYPE_BIG: () => Gk, STREAM_TYPE_SMALL: () => Wk, SUBSCRIBE_SMALL_RETRY_COUNT: () => tN, SYNC_USER_LIST_INTERVAL: () => Mk, Scene: () => ck, Switch: () => tk, THIRD_HOST: () => Hb, TIMEOUT: () => sN, TRANSPORT_DIRECTION: () => sk, TRTC_ERROR_ASSISTANCE: () => zb, TRTC_QUALITY_BAD: () => yk, TRTC_QUALITY_DISCONNECTED: () => Rk, TRTC_QUALITY_EXCELLENT: () => Sk, TRTC_QUALITY_GOOD: () => Ik, TRTC_QUALITY_POOR: () => vk, TRTC_QUALITY_UNKNOWN: () => Ek, TRTC_QUALITY_VERY_BAD: () => Ak, UPDATE_OFFER_TIMEOUT: () => Lk, VIDEO_MUTE_BIT: () => mk, VIDEO_STAT_BIT: () => lk, audioProfileMap: () => ik, getRetryCount: () => Dk, getScriptDir: () => xb, innerVersion: () => kb, loggerProxy: () => Vb, screenProfileMap: () => nk, setLoggerProxy: () => Ub, setRetryCount: () => Nk, setVersion: () => Db, version: () => Nb, videoProfileMap: () => rk });
      var kb = "4.15.00.1600", Nb = "5.0.0";
      function Db(e2) {
        Nb = e2;
        let [t2, i2, r2] = e2.split(".").map((e3) => parseInt(e3, 10));
        kb = "".concat(t2, ".").concat(Math.min(15, i2), ".").concat(Math.min(15, r2), ".").concat(i2.toString().padStart(2, "0")).concat(r2.toString().padStart(2, "0"));
      }
      var wb, Ob, Pb, Mb = "undefined" != typeof importScripts, Lb = "undefined" != typeof registerProcessor, xb = () => {
        let e2 = Mb ? self.location.href : document.currentScript.src;
        return e2.substring(0, e2.lastIndexOf("/") + 1);
      }, Vb = "", Ub = (e2) => Vb = e2, Fb = "web.sdk.qcloud.com", Bb = "web.sdk.tencent.cn", Hb = "web.sdk.cloud.tencent.cn", jb = "https://console.cloud.tencent.com/trtc", Gb = "https://".concat(Fb, "/trtc/webrtc/v5/doc"), Wb = "".concat(Gb, "/zh-cn/"), Jb = "https://yun.tim.qq.com", Kb = "https://apisgp.my-imcloud.com", zb = "trtc_error_assistance", qb = { LOG: "jssdk_log", EVENT: "jssdk_event", KEY_POINT: "jssdk_new_endreport", KV_STAT: "jssdk_key_metrics_report" }, Yb = { QCLOUD: "qcloud", OLD_CLOUD_LADDER: "trtc", WEBRTC: "webrtc" }, Qb = ((Pb = Qb || {})[Pb.TRACE = 0] = "TRACE", Pb[Pb.DEBUG = 1] = "DEBUG", Pb[Pb.INFO = 2] = "INFO", Pb[Pb.WARN = 3] = "WARN", Pb[Pb.ERROR = 4] = "ERROR", Pb[Pb.NONE = 5] = "NONE", Pb), Xb = 18e3, $b = 2e3, Zb = { unknown: 0, wifi: 1, "3g": 2, "2g": 3, "4g": 4, wired: 5, "5g": 6 }, ek = 6048e5, tk = ((Ob = tk || {}).USEAINS = "useAINS", Ob.ENABLEDEBUG = "enableDebug", Ob.USEV2 = "useV2", Ob.USEWT = "useWt", Ob), ik = { standard: { sampleRate: 48e3, channelCount: 1, bitrate: 40 }, "standard-stereo": { sampleRate: 48e3, channelCount: 2, bitrate: 64 }, high: { sampleRate: 48e3, channelCount: 1, bitrate: 128 }, "high-stereo": { sampleRate: 48e3, channelCount: 2, bitrate: 192 } }, rk = { "120p": { width: 160, height: 120, frameRate: 15, bitrate: 200 }, "120p_2": { width: 160, height: 120, frameRate: 15, bitrate: 100 }, "180p": { width: 320, height: 180, frameRate: 15, bitrate: 350 }, "180p_2": { width: 320, height: 180, frameRate: 15, bitrate: 150 }, "240p": { width: 320, height: 240, frameRate: 15, bitrate: 400 }, "240p_2": { width: 320, height: 240, frameRate: 15, bitrate: 200 }, "360p": { width: 640, height: 360, frameRate: 15, bitrate: 800 }, "360p_2": { width: 640, height: 360, frameRate: 15, bitrate: 400 }, "480p": { width: 640, height: 480, frameRate: 15, bitrate: 900 }, "480p_2": { width: 640, height: 480, frameRate: 15, bitrate: 500 }, "720p": { width: 1280, height: 720, frameRate: 15, bitrate: 1500 }, "1080p": { width: 1920, height: 1080, frameRate: 15, bitrate: 2e3 }, "1440p": { width: 2560, height: 1440, frameRate: 30, bitrate: 4860 }, "4K": { width: 3840, height: 2160, frameRate: 30, bitrate: 9e3 } }, nk = { "480p": { width: 640, height: 480, frameRate: 5, bitrate: 900 }, "480p_2": { width: 640, height: 480, frameRate: 30, bitrate: 1e3 }, "720p": { width: 1280, height: 720, frameRate: 5, bitrate: 1200 }, "720p_2": { width: 1280, height: 720, frameRate: 30, bitrate: 3e3 }, "1080p": { width: 1920, height: 1080, frameRate: 5, bitrate: 1600 }, "1080p_2": { width: 1920, height: 1080, frameRate: 30, bitrate: 4e3 } }, ok = { CANVAS: "canvas", AUDIO: "audio", VIDEO: "video", SCREEN: "screen", SMALL: "small", BIG: "big", AUXILIARY: "auxiliary", SMALL_VIDEO: "smallVideo", FACING_MODE_USER: "user", FACING_MODE_ENVIRONMENT: "environment", MUTE: "mute", UNMUTE: "unmute", ENDED: "ended", PLAYING: "playing", PAUSE: "pause", ERROR: "error", LOADEDDATA: "loadeddata", AUDIO_INPUT: "audioinput", VIDEO_INPUT: "videoinput", DETAIL: "detail", TEXT: "text", MAIN: "main", BACKUP: "backup", BANNED: "banned", KICK: "kick", USER_TIME_OUT: "user_time_out", ROOM_DISBAND: "room_disband", SEI_MESSAGE: "sei-message", ADD: "add", REMOVE: "remove", REPLACE: "replace", TRACK: "track", SUBSCRIBE: "subscribe", UNSUBSCRIBE: "unsubscribe", TRANSCEIVER_DIRECTION_SENDONLY: "sendonly", TRANSCEIVER_DIRECTION_RECVONLY: "recvonly", ENTER_PICTURE_IN_PICTURE: "enterpictureinpicture", LEAVE_PICTURE_IN_PICTURE: "leavepictureinpicture" }, sk = { INACTIVE: "inactive", SENDONLY: "sendonly", RECVONLY: "recvonly" }, ak = { OLD_CLOUD_LADDER: "wss://trtc.rtc.qq.com", WEBRTC: "wss://webrtc.qq.com" }, ck = ((wb = ck || {}).LIVE = "live", wb.RTC = "rtc", wb), lk = 1, dk = 2, uk = 4, hk = 8, pk = 64, mk = 16, _k = "5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV", fk = "224d130c-7b5c-415b-aaa2-79c2eb5a6df2", gk = ok.MAIN, Tk = ok.AUXILIARY, Ek = 0, Sk = 1, Ik = 2, vk = 3, yk = 4, Ak = 5, Rk = 6, Ck = "unknown", bk = { NEW: "new", CONNECTING: "connecting", FAILED: "failed", CLOSED: "closed", DISCONNECTED: "disconnected", CONNECTED: "connected", COMPLETED: "completed" }, kk = 1 / 0;
      function Nk(e2) {
        kk = e2;
      }
      function Dk() {
        return kk;
      }
      var wk, Ok = 30, Pk = { JOIN: "join", DELTA_JOIN: "delta-join", REJOIN: "rejoin", LEAVE: "leave", DELTA_LEAVE: "delta-leave", PUBLISH: "publish", DELTA_PUBLISH: "delta-publish", UNPUBLISH: "unpublish", SUBSCRIBE: "subscribe", UNSUBSCRIBE: "unsubscribe", UPLINK_CONNECTION: "uplink-connection", UPLINK_RECONNECTION: "uplink-reconnection", DOWNLINK_CONNECTION: "downlink-connection", DOWNLINK_RECONNECTION: "downlink-reconnection", ON_TRACK: "ontrack", ICE_CONNECTION_STATE: "iceConnectionState", LOCAL_STREAM_INITIALIZE: "stream-initialize", SIGNAL_CONNECTION: "websocketConnectionState", SIGNAL_RECONNECTION: "websocketReconnectionState", UPDATE_STREAM: "update-stream", RECOVER_LOCAL_AUDIO_TRACK: "recover-local-audio-track", RECOVER_LOCAL_VIDEO_TRACK: "recover-local-video-track", RECOVER_SUBSCRIPTION: "recover-subscription", START_MIX_TRANSCODE: "start-mix-transcode", STOP_MIX_TRANSCODE: "stop-mix-transcode", PLAYER_ERROR: "player-error", SCHEDULE: "schedule", LOAD_WORKLET: "load-worklet", VIDEO_FROZEN_COUNT: "videoFrozenCount", GET_USER_MEDIA_RETRY: "getUserMedia-retry" }, Mk = 1e4, Lk = 1e4, xk = 1e4, Vk = "unified-plan", Uk = "plan-b", Fk = 1028, Bk = ((wk = Bk || {})[wk.UNPUBLISH = -1] = "UNPUBLISH", wk[wk.PUBLISHING = 0] = "PUBLISHING", wk[wk.PUBLISHED = 1] = "PUBLISHED", wk), Hk = 500, jk = 1e3, Gk = ok.BIG, Wk = ok.SMALL, Jk = 1e4, Kk = { MAIN: "schedule.cloud-rtc.com", BACKUP: "schedule.rtc.qcloud.com", MAIN_OVERSEA: "schedule.rtc-web.com", BACKUP_OVERSEA: "schedule.rtc-web.io", MAIN_OVERSEA_OLD: "schedule.rtc.tencentcloud.com", BACKUP_OVERSEA_OLD: "schedule-ecdn.rtc.tencentcloud.com" }, zk = 2e3, qk = { TRTC: "TRTC", CLIENT: "Client", LOCAL_STREAM: "LocalStream", REMOTE_STREAM: "RemoteStream", STREAM: "Stream" }, Yk = 5, Qk = "default", Xk = Qk, $k = "communications", Zk = Object.keys(Qb), eN = ["normal leave", "timeout leave", "kick", "role change"], tN = 10, iN = 2e3, rN = "ric", nN = "raf", oN = "interval", sN = "timeout", aN = ["width", "height", "frameRate", "facingMode", "sampleRate", "sampleSize", "channelCount", "deviceId", "min", "max"];
      function cN(e2) {
        let { url: t2, body: i2, method: r2, timeout: n2 } = e2, o2 = new XMLHttpRequest();
        return new Promise((e3, s2) => {
          o2.onreadystatechange = () => {
            if (4 === o2.readyState)
              if (o2.status >= 200 && o2.status < 300)
                try {
                  let t3 = JSON.parse(o2.response);
                  e3({ data: t3 });
                } catch (t3) {
                  e3({ data: o2.response });
                }
              else
                s2({ status: o2.status, statusText: o2.statusText || "request failed!" });
          }, o2.timeout = n2 || 5e3, o2.open(r2 || "POST", t2, true), o2.send(i2);
        });
      }
      function lN(e2) {
        return cb(this, null, function* () {
          let t2 = zw(), i2 = JSON.stringify(e2);
          try {
            if (!CompressionStream || i2.length <= 2800)
              return i2;
            let e3 = new Blob([i2], { type: "application/json" }).stream().pipeThrough(new CompressionStream("gzip")), r2 = yield (yield (yield new Response(e3)).blob()).arrayBuffer();
            return EO.debug("compressJSON ".concat(i2.length, " -> ").concat(r2.byteLength, " ").concat(zw() - t2, "ms")), r2;
          } catch (wk2) {
            return i2;
          }
        });
      }
      var dN = 1e8, uN = { AVOID_REPEATED_CALL: "AVOID_REPEATED_CALL", INVALID_PARAMETER_REQUIRED: "INVALID_PARAMETER_REQUIRED", INVALID_PARAMETER_TYPE: "INVALID_PARAMETER_TYPE", INVALID_PARAMETER_EMPTY: "INVALID_PARAMETER_EMPTY", INVALID_PARAMETER_INSTANCE: "INVALID_PARAMETER_INSTANCE", INVALID_PARAMETER_RANGE: "INVALID_PARAMETER_RANGE", INVALID_PARAMETER_MIN: "INVALID_PARAMETER_MIN", INVALID_PARAMETER_MAX: "INVALID_PARAMETER_MAX", INVALID_PARAMETER_STREAMTYPE: "INVALID_PARAMETER_STREAMTYPE", API_CALL_TIMEOUT: "API_CALL_TIMEOUT", SIGNAL_CHANNEL_RECONNECTION_FAILED: "SIGNAL_CHANNEL_RECONNECTION_FAILED", SIGNAL_CHANNEL_SETUP_FAILED: "SIGNAL_CHANNEL_SETUP_FAILED", ERROR_MESSAGE: "ERROR_MESSAGE", EXCHANGE_SDP_TIMEOUT: "EXCHANGE_SDP_TIMEOUT", DOWNLINK_RECONNECTION_FAILED: "DOWNLINK_RECONNECTION_FAILED", EXCHANGE_SDP_FAILED: "EXCHANGE_SDP_FAILED", UPDATE_OFFER_TIMEOUT: "UPDATE_OFFER_TIMEOUT", UPLINK_RECONNECTION_FAILED: "UPLINK_RECONNECTION_FAILED", INVALID_RECORDID: "INVALID_RECORDID", INVALID_PURE_AUDIO: "INVALID_PURE_AUDIO", INVALID_STREAMID: "INVALID_STREAMID", INVALID_USER_DEFINE_RECORDID: "INVALID_USER_DEFINE_RECORDID", INVALID_USER_DEFINE_PUSH_ARGS: "INVALID_USER_DEFINE_PUSH_ARGS", INVALID_PROXY: "INVALID_PROXY", INVALID_JOIN: "INVALID_JOIN", INVALID_ROOMID_STRING: "INVALID_ROOMID_STRING", INVALID_ROOMID_INTEGER: "INVALID_ROOMID_INTEGER", INVALID_SIGNAL_CHANNEL: "INVALID_SIGNAL_CHANNEL", JOIN_ROOM_TIMEOUT: "JOIN_ROOM_TIMEOUT", JOIN_ROOM_FAILED: "JOIN_ROOM_FAILED", REJOIN_ROOM_FAILED: "REJOIN_ROOM_FAILED", INVALID_DESTROY: "INVALID_DESTROY", INVALID_PUBLISH: "INVALID_PUBLISH", INVALID_UNPUBLISH: "INVALID_UNPUBLISH", INVALID_AUDIENCE: "INVALID_AUDIENCE", INVALID_INITIALIZE: "INVALID_INITIALIZE", INVALID_DUPLICATE_PUBLISHING: "INVALID_DUPLICATE_PUBLISHING", INVALID_SUBSCRIBE_UNDEFINED: "INVALID_SUBSCRIBE_UNDEFINED", INVALID_SUBSCRIBE_LOCAL: "INVALID_SUBSCRIBE_LOCAL", INVALID_REMOTE_STREAM: "INVALID_REMOTE_STREAM", SUBSCRIBE_FAILED: "SUBSCRIBE_FAILED", INVALID_ROLE: "INVALID_ROLE", INVALID_PARAMETER_SWITCH_ROLE: "INVALID_PARAMETER_SWITCH_ROLE", INVALID_OPERATION_SWITCH_ROLE: "INVALID_OPERATION_SWITCH_ROLE", SWITCH_ROLE_TIMEOUT: "SWITCH_ROLE_TIMEOUT", SWITCH_ROLE_FAILED: "SWITCH_ROLE_FAILED", CLIENT_BANNED: "CLIENT_BANNED", INVALID_OPERATION_START_PUBLISH_CDN: "INVALID_OPERATION_START_PUBLISH_CDN", INVALID_OPERATION_STOP_PUBLISH_CDN: "INVALID_OPERATION_STOP_PUBLISH_CDN", INVALID_STREAM_ID: "INVALID_STREAM_ID", START_PUBLISH_CDN_FAILED: "START_PUBLISH_CDN_FAILED", STOP_PUBLISH_CDN_FAILED: "STOP_PUBLISH_CDN_FAILED", START_MIX_TRANSCODE: "START_MIX_TRANSCODE", STOP_MIX_TRANSCODE: "STOP_MIX_TRANSCODE", INVALID_AUDIO_VOLUME: "INVALID_AUDIO_VOLUME", ENABLE_SMALL_STREAM_PUBLISHED: "ENABLE_SMALL_STREAM_PUBLISHED", DISABLE_SMALL_STREAM_PUBLISHED: "DISABLE_SMALL_STREAM_PUBLISHED", NOT_SUPPORTED_SMALL_STREAM: "NOT_SUPPORTED_SMALL_STREAM", INVALID_SMALL_STREAM_PROFILE: "INVALID_SMALL_STREAM_PROFILE", INVALID_PARAMETER_REMOTE_STREAM: "INVALID_PARAMETER_REMOTE_STREAM", INVALID_OPERATION_CHANGE_SMALL: "INVALID_OPERATION_CHANGE_SMALL", REMOTE_NOT_PUBLISH_SMALL_STREAM: "REMOTE_NOT_PUBLISH_SMALL_STREAM", INVALID_SWITCH_DEVICE: "INVALID_SWITCH_DEVICE", INVALID_SWITCH_DEVICE_PUBLISHING: "INVALID_SWITCH_DEVICE_PUBLISHING", INVALID_REPLACE_TRACK: "INVALID_REPLACE_TRACK", INVALID_INITIALIZE_LOCAL_STREAM: "INVALID_INITIALIZE_LOCAL_STREAM", INVALID_ADD_TRACK_REPETITIVE: "INVALID_ADD_TRACK_REPETITIVE", INVALID_ADD_TRACK_REMOVING: "INVALID_ADD_TRACK_REMOVING", INVALID_ADD_TRACK_PUBLISHING: "INVALID_ADD_TRACK_PUBLISHING", INVALID_STREAM_INITIALIZED: "INVALID_STREAM_INITIALIZED", INVALID_ADD_TRACK_NUMBER: "INVALID_ADD_TRACK_NUMBER", INVALID_REMOVE_AUDIO_TRACK: "INVALID_REMOVE_AUDIO_TRACK", INVALID_REMOVE_AUDIO_ADDING: "INVALID_REMOVE_AUDIO_ADDING", INVALID_REMOVE_AUDIO_ON: "INVALID_REMOVE_AUDIO_ON", INVALID_REMOVE_TRACK_PUBLISHING: "INVALID_REMOVE_TRACK_PUBLISHING", INVALID_REMOVE_TRACK_NOT_TRACK: "INVALID_REMOVE_TRACK_NOT_TRACK", INVALID_REMOVE_TRACK_NUMBER: "INVALID_REMOVE_TRACK_NUMBER", INVALID_REPLACE_TRACK_NO_TRACK: "INVALID_REPLACE_TRACK_NO_TRACK", REPEAT_JOIN: "REPEAT_JOIN", CLIENT_DESTROYED: "CLIENT_DESTROYED", NOT_BUG_PACKAGE: "NOT_BUG_PACKAGE", START_MIX_TRANSCODE_FAILED: "START_MIX_TRANSCODE_FAILED", STOP_MIX_TRANSCODE_FAILED: "STOP_MIX_TRANSCODE_FAILED", MIX_TRANSCODE_NOT_STARTED: "MIX_TRANSCODE_NOT_STARTED", CANNOT_LESS_THAN_ZERO: "CANNOT_LESS_THAN_ZERO", MIX_PARAMS_VIDEO_FRAMERATE: "MIX_PARAMS_VIDEO_FRAMERATE", MIX_PARAMS_VIDEO_GOP: "MIX_PARAMS_VIDEO_GOP", MIX_PARAMS_AUDIO_BITRATE: "MIX_PARAMS_AUDIO_BITRATE", MIX_PARAMS_USER_Z_ORDER: "MIX_PARAMS_USER_Z_ORDER", MIX_PARAMS_NOT_SELF: "MIX_PARAMS_NOT_SELF", MIX_PARAMS_USER_STREAM: "MIX_PARAMS_USER_STREAM", INVALID_PLAY: "INVALID_PLAY", INVALID_ELEMENT_ID: "INVALID_ELEMENT_ID", INVALID_ELEMENT_ID_TYPE: "INVALID_ELEMENT_ID_TYPE", PLAY_FAILED: "PLAY_FAILED", INVALID_USERID: "INVALID_USERID", INVALID_CREATE_STREAM_SOURCE: "INVALID_CREATE_STREAM_SOURCE", INVALID_CREATE_STREAM_SCREEN: "INVALID_CREATE_STREAM_SCREEN", INVALID_CREATE_STREAM_AUDIO: "INVALID_CREATE_STREAM_AUDIO", INVALID_CREATE_STREAM_SCREEN_AUDIO: "INVALID_CREATE_STREAM_SCREEN_AUDIO", NOT_SUPPORTED_HTTP: "NOT_SUPPORTED_HTTP", NOT_SUPPORTED_WEBRTC: "NOT_SUPPORTED_WEBRTC", NOT_SUPPORTED_PROFILE: "NOT_SUPPORTED_PROFILE", NOT_SUPPORTED_MEDIA: "NOT_SUPPORTED_MEDIA", NOT_SUPPORTED_H264ENCODE: "NOT_SUPPORTED_H264ENCODE", NOT_SUPPORTED_H264DECODE: "NOT_SUPPORTED_H264DECODE", NOT_SUPPORTED_TRACK: "NOT_SUPPORTED_TRACK", NOT_SUPPORTED_SWITCH_DEVICE: "NOT_SUPPORTED_SWITCH_DEVICE", NOT_SUPPORTED_CAPTURE: "NOT_SUPPORTED_CAPTURE", NOT_SUPPORTED_AUX: "NOT_SUPPORTED_AUX", MICROPHONE_NOT_FOUND: "MICROPHONE_NOT_FOUND", CAMERA_NOT_FOUND: "CAMERA_NOT_FOUND", SIGNAL_RESPONSE_FAILED: "SIGNAL_RESPONSE_FAILED", CATCH_HANDLER_ERROR: "CATCH_HANDLER_ERROR", API_NOT_EXIST: "API_NOT_EXIST", CONNECTION_CLOSED: "CONNECTION_CLOSED", SUBSCRIBE_ALL_FALSE: "SUBSCRIBE_ALL_FALSE", SEI_NOT_SUPPORT: "SEI_NOT_SUPPORT", SEI_DISABLED: "SEI_DISABLED", SEI_BEFORE_PUBLISH: "SEI_BEFORE_PUBLISH", SEI_NOT_VIDEO: "SEI_NOT_VIDEO", CALL_FREQUENCY_LIMIT: "CALL_FREQUENCY_LIMIT", CONNECTION_ABORTED: "CONNECTION_ABORTED", API_CALL_ABORTED: "API_CALL_ABORTED", DUPLICATE_AUX: "DUPLICATE_AUX" }, hN = { AVOID_REPEATED_CALL: (e2) => "previous ".concat(e2.name, "() is ongoing, please avoid repeated calls."), INVALID_PARAMETER_REQUIRED(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "'".concat(t2 || i2.name, "' is a required param when calling ").concat(r2, "(), received: ").concat(n2, ".");
      }, INVALID_PARAMETER_TYPE(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2, o2 = "".concat(t2 || i2.name), s2 = "";
        return s2 = Array.isArray(i2.type) ? i2.type.join("|") : i2.type, "'".concat(o2, "' must be type of ").concat(s2, " when calling ").concat(r2, "(), received type: ").concat(Ow(n2), ".");
      }, INVALID_PARAMETER_EMPTY(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "'".concat(t2 || i2.name, "' cannot be '").concat(n2, "' when calling ").concat(r2, "().");
      }, INVALID_PARAMETER_INSTANCE(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2, o2 = "".concat(t2 || i2.name), s2 = "".concat(i2.instanceOf.name || i2.instanceOf);
        return "'".concat(o2, "' must be instanceof ").concat(s2, " when calling ").concat(r2, "(), received type: ").concat(Ow(n2), ".");
      }, INVALID_PARAMETER_RANGE(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "'".concat(t2 || i2.name, "' must be one of ").concat(i2.values.join("|"), " when calling ").concat(r2, "(), received: ").concat(n2, ".");
      }, INVALID_PARAMETER_MIN(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "the min value of ".concat(t2 || i2.name, " is ").concat(i2.min, ", received: ").concat(n2, ".");
      }, INVALID_PARAMETER_MAX(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "the max value of ".concat(t2 || i2.name, " is ").concat(i2.max, ", received: ").concat(n2, ".");
      }, API_CALL_TIMEOUT: (e2) => "".concat(e2.commandDesc || e2.command, " timeout observed."), SIGNAL_CHANNEL_RECONNECTION_FAILED: "signal channel reconnection failed, please check your network.", SIGNAL_CHANNEL_SETUP_FAILED: (e2) => "SignalChannel setup failure: (errorCode: ".concat(e2.errorCode, ", errorMsg: ").concat(e2.errorMsg, " })."), ERROR_MESSAGE(e2) {
        let t2 = "".concat(e2.type, " failed");
        return e2.message && (t2 = "".concat(t2, ": ").concat(e2.message, ".")), t2;
      }, EXCHANGE_SDP_TIMEOUT: "exchange sdp timeout.", DOWNLINK_RECONNECTION_FAILED: "downlink reconnection failed, please check your network and re-join room.", EXCHANGE_SDP_FAILED: (e2) => "exchange sdp failed ".concat(e2.errMsg, "."), UPDATE_OFFER_TIMEOUT: "update offer timeout observed.", UPLINK_RECONNECTION_FAILED: "uplink reconnection failed, please check your network and publish again.", INVALID_RECORDID: "recordId must be an integer number.", INVALID_PURE_AUDIO: "pureAudioPushMode must be 1 or 2.", INVALID_STREAMID: "streamId must be a sting literal within 64 bytes, and not be empty.", INVALID_USER_DEFINE_RECORDID: "userDefineRecordId must be a sting literal contains (a-zA-Z),(0-9), underline and hyphen, within 64 bytes, and not be empty.", INVALID_USER_DEFINE_PUSH_ARGS: "userDefinePushArgs must be a sting literal within 256 bytes, and not be empty.", INVALID_PROXY: 'proxy server url must start with "wss://".', INVALID_JOIN: "duplicate join() called.", INVALID_ROOMID_STRING: (e2) => "'".concat(e2, "' must be validate string when useStringRoomId is true."), INVALID_ROOMID_INTEGER: (e2) => "'".concat(e2, "' must be an integer between [1, 4294967294] when useStringRoomId is false."), INVALID_SIGNAL_CHANNEL: "SignalChannel is not ready yet.", JOIN_ROOM_TIMEOUT: "join room timeout.", JOIN_ROOM_FAILED(e2) {
        let { error: t2, code: i2 } = e2;
        return "Failed to join room - ".concat(t2, " code: ").concat(i2);
      }, REJOIN_ROOM_FAILED: (e2) => "reJoin room: ".concat(e2.roomId, " failed, please check your network."), INVALID_DESTROY: "please call leave() before destroy().", INVALID_PUBLISH: "please call join() before publish().", INVALID_UNPUBLISH: "stream has not been published yet.", INVALID_AUDIENCE: "no permission to publish() under live/".concat("audience", ', please call switchRole("', "anchor", '") firstly before publish().'), INVALID_INITIALIZE: "cannot publish stream because stream is not initialized, is switching device, or has been closed.", INVALID_DUPLICATE_PUBLISHING: (e2) => "duplicate ".concat(e2, " stream publishing, please unpublish your prev ").concat(e2, " stream and then re-publish."), INVALID_SUBSCRIBE_UNDEFINED: "stream is undefined or null.", INVALID_SUBSCRIBE_LOCAL: "stream cannot be LocalStream.", INVALID_REMOTE_STREAM: "remoteStream does not exist because it has been unpublished by remote peer.", SUBSCRIBE_FAILED(e2) {
        let { message: t2, userId: i2, streamType: r2 } = e2;
        return "failed to subscribe ".concat(i2, " ").concat(r2, " stream, reason: ").concat(t2, ".");
      }, INVALID_ROLE: "switchRole can only be called in live mode.", INVALID_PARAMETER_SWITCH_ROLE: "role could only be set to a value as ".concat("anchor", " or ", "audience", "."), INVALID_OPERATION_SWITCH_ROLE: "please call join() before switchRole().", SWITCH_ROLE_TIMEOUT: "switchRole timeout.", SWITCH_ROLE_FAILED: (e2) => "switchRole failed, errCode: ".concat(e2.code, " errMsg: ").concat(e2.message, "."), CLIENT_BANNED: (e2) => "client was banned because of ".concat(e2.message, "."), INVALID_OPERATION_START_PUBLISH_CDN: "please call startPublishCDNStream() after join room and publish the local stream.", INVALID_OPERATION_STOP_PUBLISH_CDN: "please call startPublishCDNStream() before stopPublishCDNStream().", START_PUBLISH_CDN_FAILED: (e2) => "startPublishCDNStream failed, errMsg: ".concat(e2.message, "."), STOP_PUBLISH_CDN_FAILED: (e2) => "stopPublishCDNStream failed, errMsg: ".concat(e2.message, "."), INVALID_STREAM_ID: (e2) => "'".concat(e2, "' can only consist of uppercase and lowercase english letters (a-zA-Z), numbers (0-9), hyphens and underscores."), START_MIX_TRANSCODE: "please call startMixTranscode() after join().", STOP_MIX_TRANSCODE: "please call stopMixTranscode() after startMixTranscode().", INVALID_AUDIO_VOLUME: "interval must be a number.", ENABLE_SMALL_STREAM_PUBLISHED: "Cannot enable small stream after localStream published.", DISABLE_SMALL_STREAM_PUBLISHED: "Cannot disable small stream after localStream published.", NOT_SUPPORTED_SMALL_STREAM: "your browser does not support opening small stream.", INVALID_SMALL_STREAM_PROFILE: "small stream profile is invalid.", INVALID_PARAMETER_REMOTE_STREAM: "remoteStream is invalid.", INVALID_OPERATION_CHANGE_SMALL: "cannot switch to the small stream without subscribing to the video of remoteStream.", REMOTE_NOT_PUBLISH_SMALL_STREAM: "remote peer does not publish small stream.", INVALID_SWITCH_DEVICE: "cannot switch device on current stream.", INVALID_SWITCH_DEVICE_PUBLISHING: "cannot switch device when publishing localStream.", INVALID_REPLACE_TRACK: "cannot replace track when publishing localStream.", INVALID_INITIALIZE_LOCAL_STREAM: "local stream has not initialized yet.", INVALID_ADD_TRACK_REPETITIVE: "previous addTrack is ongoing, please avoid repetitive execution.", INVALID_ADD_TRACK_REMOVING: "cannot add track when a track is removing.", INVALID_ADD_TRACK_PUBLISHING: "cannot add track when publishing localStream.", INVALID_STREAM_INITIALIZED: "your local stream haven't been initialized yet.", INVALID_ADD_TRACK_NUMBER: "a Stream has at most one audio track and one video track.", INVALID_REMOVE_AUDIO_TRACK: "remove audio track is not supported on your browser.", INVALID_REMOVE_AUDIO_ADDING: "cannot remove track when a track is adding.", INVALID_REMOVE_AUDIO_ON: "previous removeTrack is ongoing, please avoid repetitive execution.", INVALID_REMOVE_TRACK_PUBLISHING: "cannot remove track when publishing localStream.", INVALID_REMOVE_TRACK_NOT_TRACK: "localStream has not this track.", INVALID_REMOVE_TRACK_NUMBER: "remove the only video track is not supported, please use replaceTrack or muteVideo.", INVALID_REPLACE_TRACK_NO_TRACK: (e2) => "cannot replace ".concat(e2.kind, " track because stream has not ").concat(e2.kind, " track"), NOT_BUG_PACKAGE: "You need to buy packages, refer to tencent console.", START_MIX_TRANSCODE_FAILED: (e2) => "startMixTranscode failed, errMsg: ".concat(e2.message, "."), STOP_MIX_TRANSCODE_FAILED: (e2) => "stopMixTranscode failed, errMsg: ".concat(e2.message, "."), MIX_TRANSCODE_NOT_STARTED: "mixTranscode has not been started.", CANNOT_LESS_THAN_ZERO(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "'".concat(t2 || i2.name, "' cannot be less than 0 when calling ").concat(r2, "().");
      }, MIX_PARAMS_VIDEO_FRAMERATE: "'config.videoFramerate' should be an integer between 0 and 30, excluding 0.", MIX_PARAMS_VIDEO_GOP: "'config.videoGOP' should be an integer between 1 and 8.", MIX_PARAMS_AUDIO_BITRATE: "'config.audioBitrate' should be an integer between 32 and 192.", MIX_PARAMS_USER_Z_ORDER: (e2) => "'".concat(e2, "' is required and must be between 1 and 15."), MIX_PARAMS_NOT_SELF: "'config.mixUsers' must contain self.", MIX_PARAMS_USER_STREAM: "'config.videoWidth' and 'config.videoHeight' of output stream should be contain all mix stream.", INVALID_PLAY: "duplicate play() call observed, please stop() firstly.", INVALID_ELEMENT_ID: (e2) => {
        let { key: t2, fnName: i2 } = e2;
        return "'".concat(t2, "' is not found in the document object when calling ").concat(i2, "().");
      }, INVALID_ELEMENT_ID_TYPE: (e2) => {
        let { key: t2, fnName: i2, type: r2 } = e2;
        return "the element corresponding to '".concat(t2, "' must be instanceof HTMLElement when calling ").concat(i2, "(), received: ").concat(r2, ".");
      }, PLAY_FAILED: (e2) => "".concat(e2.media, " play failedï¼browser exception: ").concat(e2.error.toString()), INVALID_USERID: "userId cannot be all spaces.", INVALID_CREATE_STREAM_SOURCE: "LocalStream must be created by createStream() with either audio/video or audioSource/videoSource, but can not be mixed with audio/video and audioSource/videoSource.", INVALID_CREATE_STREAM_SCREEN: "screen/video cannot be both true.", INVALID_CREATE_STREAM_AUDIO: "audio/screenAudio cannot be both true.", INVALID_CREATE_STREAM_SCREEN_AUDIO: "when screen is true, screenAudio can be configured.", NOT_SUPPORTED_HTTP: "http protocol does not support the ability to capture microphone, camera and screen. please use https to deploy your page.", NOT_SUPPORTED_WEBRTC: "your browser or environment does not support full WebRTC capabilities.", NOT_SUPPORTED_PROFILE: "your browser does not support setVideoProfile.", NOT_SUPPORTED_MEDIA: "your browser or environment does not support navigator.mediaDevices.", NOT_SUPPORTED_H264ENCODE: "your device does not support H.264 encoding.", NOT_SUPPORTED_H264DECODE: "your device does not support H.264 decoding.", NOT_SUPPORTED_TRACK: (e2) => "".concat(e2, "Track is not supported on your browser."), NOT_SUPPORTED_SWITCH_DEVICE: "switchDevice is not supported on your browser.", NOT_SUPPORTED_CAPTURE: "Your browser or environment does not support screen sharing, please check whether the browser version.", MICROPHONE_NOT_FOUND: "no microphone detected, please check your microphone.", CAMERA_NOT_FOUND: "no camera detected, please check your camera.", SIGNAL_RESPONSE_FAILED: (e2) => "".concat(e2.signalResponse, " failed, response code is ").concat(e2.code, " , errMsg: ").concat(e2.message, "."), CATCH_HANDLER_ERROR(e2) {
        let { name: t2, event: i2 } = e2;
        return "an error was caught on ".concat(t2, ".on('").concat(i2, "', handler), please check your code on 'handler'.");
      }, API_NOT_EXIST(e2) {
        let { name: t2 } = e2;
        return "experimental api ".concat(t2, " does not exist.");
      }, REPEAT_JOIN: (e2) => "[".concat(e2, "] is calling client.join api or has already joined room, please avoid repeated join."), CONNECTION_CLOSED: "remoteStream has been unsubscribed or unpublished by remote user.", SUBSCRIBE_ALL_FALSE: "cannot subscribe when both audio & video are false, use client.unsubscribe() instead", CLIENT_DESTROYED(e2) {
        let { funName: t2 } = e2;
        return "failed to call ".concat(t2, "() because client was destroyed.");
      }, SEI_NOT_SUPPORT: (e2) => "not support to sendSEIMessage".concat(false === e2 ? " without using h264 codec" : ""), SEI_DISABLED: "SEI is disabled", SEI_BEFORE_PUBLISH: "please call sendSEIMessage() after publish() success", SEI_NOT_VIDEO: "cannot send sei when localStream has not video.", CALL_FREQUENCY_LIMIT: (e2) => {
        let { isSize: t2, name: i2, timesInSecond: r2, maxSizeInSecond: n2 } = e2;
        return "api ".concat(i2, " call ").concat(t2 ? "size" : "times", " is over ").concat(t2 ? "".concat(n2, " bytes") : r2, " in a second.");
      }, CONNECTION_ABORTED: (e2) => "connection aborted due to: ".concat(e2), API_CALL_ABORTED(e2) {
        let t2;
        return t2 = e2.message.includes("REMOTE_STREAM_NOT_EXIST") ? "Subscribe ".concat(e2.userId, " ").concat(e2.streamType, " stream aborted, reason: remote user ").concat(e2.userId, " unpublished stream.") : "API aborted, reason: ".concat(e2.message), t2;
      }, DUPLICATE_AUX: "only one auxiliary stream can be published in a room.", NOT_SUPPORTED_AUX: "publish auxiliary stream is not supported on your browser.", INVALID_PARAMETER_STREAMTYPE: (e2) => "'streamType' is required when 'userId' is not '*', calling ".concat(e2, "()") }, pN = {};
      rb(pN, { ANDROID_VERSION: () => CN, CHROME_MAJOR_VERSION: () => bD, CHROME_VERSION: () => kD, EDGE_VERSION: () => PN, EDG_MAJOR_VERSION: () => xN, EDG_VERSION: () => LN, FIREFOX_MAJOR_VERSION: () => wN, FIREFOX_VERSION: () => DN, HUAWEI_VERSION: () => fD, IE_VERSION: () => zN, IOS_MAIN_VERSION: () => MD, IOS_VERSION: () => PD, IPADQQB_VERSION: () => nD, IS_ANDROID: () => RN, IS_ANDROID_WEBVIEW: () => OD, IS_ANY_SAFARI: () => DD, IS_CHROME: () => RD, IS_CHROME_OS: () => cD, IS_CHROMIUM_BASE: () => AD, IS_EDG: () => MN, IS_EDGE: () => ON, IS_ELECTRON: () => uD, IS_FIREFOX: () => NN, IS_HEADLESS_CHROME: () => CD, IS_HUAWEI: () => _D, IS_HUAWEIBROWSER: () => mD, IS_IE: () => KN, IS_IE8: () => JN, IS_IOS: () => AN, IS_IOS_13_OR_14: () => VD, IS_IOS_15_1: () => xD, IS_IPAD: () => SN, IS_IPADQQB: () => rD, IS_IPAD_PRO: () => IN, IS_IPHONE: () => vN, IS_IPOD: () => yN, IS_LINUX: () => aD, IS_LOCAL: () => UD, IS_MAC: () => sD, IS_MACQQB: () => tD, IS_MIBROWSER: () => hD, IS_MQQB: () => XN, IS_NATIVE_ANDROID: () => kN, IS_OLD_ANDROID: () => bN, IS_OPPOBROWSER: () => ED, IS_SAFARI: () => ND, IS_SAFARI_15_1: () => LD, IS_SAMSUNGBROWSER: () => gD, IS_SOGOU: () => FN, IS_SOGOUM: () => VN, IS_TBS: () => HN, IS_UCBROWSER: () => dD, IS_VIVOBROWSER: () => ID, IS_WECHAT: () => qN, IS_WIN: () => oD, IS_WQQB: () => ZN, IS_WX: () => lD, IS_X5MQQB: () => QN, IS_XWEB: () => GN, MACQQB_VERSION: () => iD, MI_VERSION: () => pD, MQQB_VERSION: () => $N, OPPO_VERSION: () => SD, SAFARI_VERSION: () => wD, SAMSUNG_VERSION: () => TD, SOGOUM_VERSION: () => UN, SOGOU_VERSION: () => BN, TBS_VERSION: () => jN, USER_AGENT: () => mN, VIVO_VERSION: () => vD, WECHAT_VERSION: () => YN, WQQB_VERSION: () => eD, XWEB_VERSION: () => WN, browserInfo: () => BD, getBrowserInfo: () => HD, getChromeMajorVersion: () => yD, getOSName: () => JD, getOSString: () => KD, getOSType: () => qD, getTerminalType: () => zD, getUserAgentData: () => GD, isLocalStorageEnabled: () => FD });
      var mN = "undefined" == typeof navigator ? "" : navigator.userAgent, _N = (e2) => new RegExp(e2, "i").test(mN), fN = (e2) => {
        if (_N(e2)) {
          let t2 = new RegExp("".concat(e2, "\\/([\\d.]+)")), i2 = mN.match(t2);
          if (i2 && i2[1])
            return i2[1];
        }
        return "";
      }, gN = (e2) => {
        if (_N(e2)) {
          let t2 = new RegExp("".concat(e2, "\\/(\\d+)")), i2 = mN.match(t2);
          if (i2 && i2[1])
            return parseFloat(i2[1]);
        }
        return NaN;
      }, TN = /AppleWebKit\/([\d.]+)/i.exec(mN), EN = TN ? parseFloat(TN[1]) : NaN, SN = _N("iPad"), IN = "undefined" != typeof navigator && navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && _N("Macintosh"), vN = _N("iPhone") && !SN, yN = _N("iPod"), AN = vN || SN || yN || IN, RN = _N("Android"), CN = function() {
        if (RN) {
          let e2 = mN.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
          if (e2) {
            let t2 = e2[1] && parseFloat(e2[1]), i2 = e2[2] && parseFloat(e2[2]);
            if (t2 && i2)
              return parseFloat("".concat(e2[1], ".").concat(e2[2]));
            if (t2)
              return t2;
          }
        }
        return NaN;
      }(), bN = RN && _N("webkit") && CN < 2.3, kN = RN && CN < 5 && EN < 537, NN = _N("Firefox"), DN = fN("Firefox"), wN = gN("Firefox"), ON = _N("Edge"), PN = fN("Edge"), MN = _N("Edg"), LN = fN("Edg"), xN = gN("Edg"), VN = _N("SogouMobileBrowser"), UN = fN("SogouMobileBrowser"), FN = _N("MetaSr\\s"), BN = fN("MetaSr\\s"), HN = _N("TBS"), jN = fN("TBS"), GN = _N("XWEB"), WN = fN("XWEB"), JN = _N("MSIE\\s8\\.0"), KN = _N("MSIE\\/\\d+"), zN = function() {
        if (KN) {
          let e2 = /MSIE\s(\d+)\.\d/.exec(mN), t2 = e2 && parseFloat(e2[1]);
          return !t2 && /Trident\/7.0/i.test(mN) && /rv:11.0/.test(mN) && (t2 = 11), t2;
        }
        return NaN;
      }(), qN = _N("(micromessenger|webbrowser)"), YN = fN("MicroMessenger"), QN = !HN && _N("MQQBrowser") && _N("COVC"), XN = !HN && _N("MQQBrowser") && !_N("COVC"), $N = XN || QN ? fN("MQQBrowser") : "", ZN = !HN && _N(" QQBrowser"), eD = fN(" QQBrowser"), tD = !HN && _N("QQBrowserLite"), iD = fN("QQBrowserLite"), rD = !HN && _N("MQBHD"), nD = fN("MQBHD"), oD = _N("Windows"), sD = !AN && _N("MAC OS X"), aD = !RN && _N("Linux"), cD = _N("CrOS"), lD = _N("MicroMessenger"), dD = _N("UCBrowser"), uD = _N("Electron"), hD = _N("MiuiBrowser"), pD = fN("MiuiBrowser"), mD = _N("HuaweiBrowser"), _D = _N("Huawei"), fD = fN("HuaweiBrowser"), gD = _N("SamsungBrowser"), TD = fN("SamsungBrowser"), ED = _N("HeyTapBrowser"), SD = fN("HeyTapBrowser"), ID = _N("VivoBrowser"), vD = fN("VivoBrowser"), yD = () => gN("Chrome"), AD = _N("Chrome"), RD = !ON && !FN && !VN && !HN && !GN && !MN && !ZN && !hD && !mD && !gD && !ED && !ID && AD, CD = _N("HeadlessChrome"), bD = yD(), kD = fN("Chrome"), ND = !AD && !XN && !QN && !tD && !rD && _N("Safari"), DD = ND || AN, wD = fN("Version"), OD = /Android.*(wv|.0.0.0)/.test(mN), PD = (() => {
        if (IN)
          return wD;
        if (AN) {
          let e2 = mN.match(/OS (\d+)_(\d+)/i);
          if (e2 && e2[1]) {
            let t2 = e2[1];
            return e2[2] && (t2 += ".".concat(e2[2])), t2;
          }
        }
        return "";
      })(), MD = Number(PD.split(".")[0]), LD = "15.1" === wD, xD = "15.1" === PD, VD = (() => {
        let e2 = Number(PD.split(".")[0]);
        return 14 === e2 || 13 === e2;
      })(), UD = "undefined" != typeof location && ("file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname), FD = /* @__PURE__ */ (() => {
        let e2;
        return () => {
          if (Mw(e2))
            try {
              e2 = !!window.localStorage;
            } catch (rM2) {
              e2 = false;
            }
          return e2;
        };
      })(), BD = HD();
      function HD() {
        let e2 = /* @__PURE__ */ new Map([[NN, ["Firefox", DN]], [MN, ["Edg", LN]], [RD, ["Chrome", kD]], [ND, ["Safari", wD]], [HN, ["TBS", jN]], [GN, ["XWEB", WN]], [qN && vN, ["WeChat", YN]], [ZN, ["QQ(Win)", eD]], [XN, ["QQ(Mobile)", $N]], [QN, ["QQ(Mobile X5)", $N]], [tD, ["QQ(Mac)", iD]], [rD, ["QQ(iPad)", nD]], [hD, ["MI", pD]], [mD, ["HW", fD]], [gD, ["Samsung", TD]], [ED, ["OPPO", SD]], [ID, ["VIVO", vD]], [ON, ["EDGE", PN]], [VN, ["SogouMobile", UN]], [FN, ["Sogou", BN]]]), t2 = "unknown", i2 = "unknown";
        return e2.has(true) && ([t2, i2] = e2.get(true)), { name: t2, version: i2 };
      }
      var jD = null;
      function GD() {
        return cb(this, null, function* () {
          if (jD)
            return jD;
          if (!navigator.userAgentData || !Pw(navigator.userAgentData.getHighEntropyValues))
            return null;
          try {
            return jD = yield navigator.userAgentData.getHighEntropyValues(["architecture", "bitness", "model", "platformVersion", "fullVersionList"]);
          } catch (pF2) {
            return null;
          }
        });
      }
      var WD = /* @__PURE__ */ new Map([[RN, "Android"], [AN, "iOS"], [oD, "Windows"], [sD, "MacOS"], [aD, "Linux"], [cD, "ChromeOS"]]), JD = function() {
        return WD.get(true) ? WD.get(true) : jD ? jD.platform : "unknown";
      }, KD = () => {
        let e2 = JD();
        return e2 += "/".concat(BD.name, "/").concat(ND ? BD.version : BD.version.split(".")[0]), null != jD && jD.platformVersion && (e2 += "/".concat(jD.platformVersion)), null != jD && jD.architecture && (e2 += "/".concat(jD.architecture)), e2;
      };
      function zD() {
        return RN ? 4 : vN ? 2 : SN ? 3 : sD ? 12 : oD ? 5 : aD ? 13 : 1;
      }
      function qD() {
        return RN ? "Android" : vN ? "iPhone" : SN ? "iPad" : sD ? "Mac" : oD ? "Windows" : aD ? "Linux" : "unknown";
      }
      var YD = (e2, t2) => t2 ? "".concat(Gb, "/").concat(e2, "/").concat(t2) : "".concat(Gb, "/").concat(e2, "/index.html"), QD = () => {
        if (window.TRTC_ERROR_INFO && window.TRTC_ERROR_LINK)
          return { TRTC_ERROR_INFO: window.TRTC_ERROR_INFO, TRTC_ERROR_LINK: window.TRTC_ERROR_LINK };
        let e2 = localStorage.getItem(zb);
        if (e2) {
          e2 = JSON.parse(e2);
          let t2 = document.createElement("script");
          t2.type = "text/javascript", t2.text = e2.message, document.body.appendChild(t2);
          let i2 = window.TRTC_ERROR_INFO, r2 = window.TRTC_ERROR_LINK;
          return document.body.removeChild(t2), { TRTC_ERROR_INFO: i2, TRTC_ERROR_LINK: r2 };
        }
        return {};
      };
      function XD(e2) {
        let { key: t2, data: i2, link: r2, addDocLink: n2 = true } = e2, o2 = "", s2 = "", a2 = "";
        Pw(hN[t2]) ? o2 = hN[t2](i2) : Lw(hN[t2]) && (o2 = hN[t2]);
        let { TRTC_ERROR_INFO: c2, TRTC_ERROR_LINK: l2 } = QD();
        r2 ? a2 = "".concat(r2.className, ".html#").concat(r2.fnName) : l2 && l2[t2] && (Pw(l2[t2]) ? a2 = l2[t2](i2) : Lw(l2[t2]) && (a2 = l2[t2]));
        let d2 = o2;
        return kw() && (c2 && c2[t2] && (Pw(c2[t2]) ? s2 = c2[t2](i2) : Lw(c2[t2]) && (s2 = c2[t2])), s2 && (d2 = n2 ? "".concat(s2, "\nè¯·æ¥çææ¡£: ").concat(YD("zh-cn", a2), "\n\n") : "".concat(s2, "\n\n"), d2 += o2)), n2 && (d2 += " \nRefer to: ".concat(YD("en", a2), "\n")), d2;
      }
      var $D, ZD = function(e2) {
        let { retryFunction: t2, settings: i2, onError: r2, onRetrying: n2, onRetryFailed: o2, onRetrySuccess: s2, context: a2 } = e2;
        return function() {
          for (var e3 = arguments.length, c2 = new Array(e3), l2 = 0; l2 < e3; l2++)
            c2[l2] = arguments[l2];
          let { retries: d2 = 5, timeout: u2 = 1e3 } = i2, h2 = 0, p2 = -1, m2 = 0, _2 = (e4, i3) => cb(this, null, function* () {
            let l3 = a2 || this;
            try {
              let i4 = yield t2.apply(l3, c2);
              h2 > 0 && s2 && s2.call(this, h2), h2 = 0, e4(i4);
            } catch (f2) {
              let t3 = () => {
                clearTimeout(p2), h2 = 0, m2 = 2, i3(f2);
              }, s3 = () => {
                2 !== m2 && h2 < (Pw(d2) ? d2() : d2) ? (h2++, m2 = 1, Pw(n2) && n2.call(this, h2, t3), p2 = window.setTimeout(() => {
                  p2 = -1, _2(e4, i3);
                }, Pw(u2) ? u2(h2) : u2)) : (t3(), Pw(o2) && o2.call(this, f2));
              };
              Pw(r2) ? r2.call(this, { error: f2, retry: s3, reject: i3, retryFuncArgs: c2, retriedCount: h2 }) : s3();
            }
          });
          return new Promise(_2);
        };
      }, ew = new (nb(lb(), 1)).default(), tw = (($D = tw || {}).ROOM_DESTROY = "1", $D.JOIN_START = "21", $D.JOIN_SCHEDULE_SUCCESS = "22", $D.JOIN_SIGNAL_CONNECTION_START = "23", $D.JOIN_SIGNAL_CONNECTION_END = "24", $D.JOIN_SEND_CMD = "25", $D.JOIN_RECEIVED_CMD_RES = "26", $D.JOIN_SUCCESS = "27", $D.JOIN_FAILED = "28", $D.LEAVE_START = "51", $D.LEAVE_SEND_CMD = "52", $D.LEAVE_SUCCESS = "53", $D.PUBLISH_START = "61", $D.SEND_FIRST_VIDEO_FRAME = "62", $D.PUBLISH_FAILED = "63", $D.SUBSCRIBE_START = "81", $D.SUBSCRIBE_SUCCESS = "82", $D.SUBSCRIBE_FAILED = "84", $D.UNSUBSCRIBE_SUCCESS = "83", $D.LOCAL_TRACK_CAPTURE_START = "101", $D.LOCAL_TRACK_CAPTURE_SUCCESS = "102", $D.LOCAL_TRACK_CAPTURE_FAILED = "103", $D.LOCAL_TRACK_PUBLISHED = "104", $D.LOCAL_TRACK_UNPUBLISHED = "105", $D.LOCAL_TRACK_REPLACED = "106", $D.SWITCH_DEVICE_SUCCESS = "107", $D.TRACK_MUTED = "108", $D.TRACK_UNMUTED = "109", $D.REMOTE_TRACK_SUBSCRIBED = "110", $D.REMOTE_TRACK_UNSUBSCRIBED = "111", $D.PLAY_TRACK_START = "151", $D.PLAYER_STATE_CHANGED = "152", $D.VIDEO_LOADED_DATA = "153", $D.AUTOPLAY_DIALOG_CLICK_CONFIRM = "154", $D.SIGNAL_CONNECTION_STATE_CHANGED = "201", $D.PEER_CONNECTION_STATE_CHANGED = "202", $D.SINGLE_CONNECTION_STAT = "203", $D.SPC_RECONNECTED = "204", $D.HEARTBEAT_REPORT = "251", $D.RECEIVED_PUBLISHED_USER_LIST = "252", $D.REMOTE_PUBLISH_STATE_CHANGED = "253", $D.AUDIO_LEVEL_INTERVAL = "260", $D.NETWORK_QUALITY = "261", $D), iw = new class {
        constructor() {
          this._roomIdMap = /* @__PURE__ */ new Map(), "undefined" == typeof registerProcessor && (this._configs = { sdkAppId: "", userId: "", version: Nb, env: Yb.QCLOUD, browserVersion: BD.name + BD.version, ua: navigator.userAgent });
        }
        setConfig(e2) {
          let { sdkAppId: t2, env: i2, userId: r2, roomId: n2 } = e2;
          t2 !== this._configs.sdkAppId && (this._configs.sdkAppId = String(t2)), this._configs.env = i2, this._configs.userId = r2, this._roomIdMap.set(r2, String(n2));
        }
        logSuccessEvent(e2) {
          UD || !EO.isAbleToUpload || this._configs.env === Yb.QCLOUD && this.uploadEventToKibana(tb(eb({}, e2), { result: "success" }));
        }
        logFailedEvent(e2) {
          if (UD || !EO.isAbleToUpload)
            return;
          let { eventType: t2, code: i2, error: r2, userId: n2 } = e2, o2 = { roomId: this._roomIdMap.get(n2 || this._configs.userId), userId: n2, eventType: t2, result: "failed", code: i2 || (null == r2 ? void 0 : r2.extraCode) || (null == r2 ? void 0 : r2.code) || Sb.UNKNOWN };
          this._configs.env === Yb.QCLOUD && this.uploadEventToKibana(tb(eb({}, o2), { error: r2 }));
        }
        uploadEventToKibana(e2) {
          let t2 = "stat-".concat(e2.eventType, "-").concat(e2.result);
          ("delta-join" === e2.eventType || "delta-leave" === e2.eventType || "delta-publish" === e2.eventType) && (t2 = "".concat(e2.eventType, ":").concat(e2.delta)), this.uploadEvent({ log: t2, userId: e2.userId }), "failed" === e2.result && (t2 = "stat-".concat(e2.eventType, "-").concat(e2.result, "-").concat(e2.code), this.uploadEvent({ log: t2, userId: e2.userId, error: e2.error }));
        }
        uploadEvent(e2) {
          let { log: t2, userId: i2, error: r2 } = e2, n2 = { timestamp: Rb(), sdkAppId: this._configs.sdkAppId, userId: i2 || this._configs.userId, version: Nb, log: t2 };
          r2 && (n2.errorInfo = r2.message), this.sendRequest(fw(this._configs.sdkAppId, qb.LOG), n2);
        }
        sendRequest(e2, t2) {
          EO.isAbleToUpload ? cN({ url: e2, body: JSON.stringify(t2) }).catch(() => {
          }) : setTimeout(() => {
            this.sendRequest(e2, t2);
          }, 1e3);
        }
      }(), rw = null, nw = true;
      function ow(e2) {
        Vw(e2) && e2 !== nw && (nw = e2, EO.info("setIsNeedToSchedule ".concat(e2)));
      }
      function sw(e2) {
        return cb(this, arguments, function(e3) {
          let { userId: t2, sdkAppId: i2, useStringRoomId: r2, roomId: n2, userSig: o2, version: s2, frameWorkType: a2 } = e3;
          return function* () {
            if (!nw && rw)
              return { isCached: true, result: rw };
            let e4 = { delta: 0, count: [1, 1], msg: [], detail: [] };
            try {
              let c2 = new FormData();
              c2.append("userId", String(t2)), c2.append("sdkAppId", String(i2)), c2.append("isStrGroupId", String(r2)), c2.append("groupId", String(n2)), c2.append("sdkVersion", s2), c2.append("userSig", String(o2)), a2 && c2.append("frameWorkType", String(a2));
              let l2 = zw(), d2 = yield function(e5, t3, i3) {
                return new Promise((r3, n3) => {
                  let o3 = null;
                  Kw([pw((e6) => t3.count[0] = e6 + 1, (e6) => {
                    let { error: r4, retry: n4, retriedCount: s3, retryFuncArgs: a3 } = e6;
                    t3.msg[0] = r4.message, o3 || (s3 >= 2 && (a3[0] = lw(i3, ok.MAIN, true)), n4());
                  })(lw(i3, ok.MAIN), e5, { get timeout() {
                    return 1e3 * Dw(2 + t3.count[0]);
                  } }), pw((e6) => t3.count[1] = e6 + 1, (e6) => {
                    let { error: r4, retry: n4, retriedCount: s3, retryFuncArgs: a3 } = e6;
                    t3.msg[1] = r4.message, o3 || (s3 >= 2 && (a3[0] = lw(i3, ok.BACKUP, true)), n4());
                  })(lw(i3, ok.BACKUP), e5, { get timeout() {
                    return 1e3 * Dw(2 + t3.count[1]);
                  } })]).then((e6) => {
                    o3 = e6, r3(o3);
                  }).catch(n3);
                });
              }(c2, e4, i2);
              d2.config && (d2.config.loggerDomain && Ub(d2.config.loggerDomain), Vw(d2.config.scheduleCache) && ow(!d2.config.scheduleCache)), e4.delta = zw() - l2;
              let u2 = function(e5, t3, i3) {
                let r3 = performance.getEntriesByType("resource"), n3 = lw(e5, ok.MAIN), o3 = lw(e5, ok.BACKUP), s3 = { totalCost: 0, local: 0, dns: 0, tcp: 0, tls: 0, request: 0, response: 0 };
                for (let a3 of r3)
                  if (a3.startTime >= i3 && (a3.name === n3 || a3.name === o3) && a3.transferSize > 0) {
                    let e6 = a3.name === n3 ? ok.MAIN : ok.BACKUP, i4 = Math.round(a3.duration), r4 = Math.round(a3.domainLookupStart - a3.startTime), o4 = Math.round(a3.domainLookupEnd - a3.domainLookupStart), c3 = Math.round(a3.requestStart - a3.secureConnectionStart), l3 = Math.round(a3.secureConnectionStart - a3.connectStart), d3 = Math.round(a3.responseStart - a3.requestStart), u3 = Math.round(a3.responseEnd - a3.responseStart), h2 = [r4, o4, c3, l3, d3, u3];
                    iw.uploadEvent({ log: "stat-schedule-net:".concat(i4, "(").concat(h2.join("->"), ") ").concat(e6), userId: t3 }), s3 = tb(eb({}, s3), { totalCost: i4, local: r4, dns: o4, tcp: l3, tls: c3, request: d3, response: u3 });
                    break;
                  }
                return s3;
              }(Number(i2), t2, l2);
              return rw = d2, { isCached: false, result: d2, detailCost: u2 };
            } catch (c2) {
              let e5 = Fw(c2) ? c2[0] : c2, t3 = xw(e5.code) ? e5.code : 0, i3 = "schedule failed".concat(e5.message ? ": ".concat(e5.message) : ""), r3 = new vb({ code: Sb.SCHEDULE_FAILED, extraCode: t3, message: XD({ key: uN.JOIN_ROOM_FAILED, data: { error: i3, code: t3 } }) });
              throw EO.error(i3, t3), r3;
            }
          }();
        });
      }
      document && document.head.insertAdjacentHTML("beforeend", Object.values(Kk).map((e2) => '<link rel="dns-prefetch" href="https://'.concat(e2, '">')).join("\r\n")), ew.on("28", () => ow(true)), ew.on("63", () => ow(true)), ew.on("84", () => ow(true)), ew.on("201", (e2) => {
        "RECONNECTING" === e2.state && ow(true);
      }), ew.on("202", (e2) => {
        "RECONNECTING" === e2.state && ow(true);
      });
      var aw = { main: "", backup: "" };
      function cw(e2) {
        Fw(e2) ? (aw.main = e2[0], aw.backup = e2[1]) : aw.main = e2;
      }
      function lw(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ok.MAIN, i2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return "https://".concat(aw[t2] || uw(e2, t2, i2), "/api/v1/config");
      }
      function dw(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ok.MAIN;
        return "https://".concat(aw[t2] || uw(e2, t2), "/api/v1/trtcAutoConf");
      }
      function uw(e2) {
        let t2, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ok.MAIN, r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return _w(e2) ? i2 === ok.MAIN ? Kk.MAIN_OVERSEA : Kk.BACKUP_OVERSEA : (t2 = _w(e2) ? r2 ? i2 === ok.MAIN ? Kk.MAIN_OVERSEA_OLD : Kk.BACKUP_OVERSEA_OLD : i2 === ok.MAIN ? Kk.MAIN_OVERSEA : Kk.BACKUP_OVERSEA : i2 === ok.MAIN ? Kk.MAIN : Kk.BACKUP, t2);
      }
      function hw(e2, t2, i2) {
        return new Promise((r2, n2) => {
          cN({ url: e2, body: t2, timeout: i2.timeout }).then((e3) => {
            0 === e3.data.code ? r2(e3.data.data) : n2({ code: e3.data.code, message: e3.data.msg });
          }).catch(n2);
        });
      }
      var pw = (e2, t2) => ZD({ retryFunction: hw, settings: { retries: 3, timeout: 0 }, onError: t2, onRetrying: e2 });
      var mw = function() {
        return new URLSearchParams(location.search).get("trtc_env") || "";
      }, _w = (e2) => Number(e2) < 14e8, fw = function(e2, t2) {
        let i2;
        i2 = Vb || (_w(e2) ? Kb : Jb);
        let r2 = Math.floor(Math.random() * $C(2, 31));
        return "".concat(i2, "/v5/AVQualityReportSvc/C2S?random=").concat(r2, "&sdkappid=").concat(e2, "&cmdtype=").concat(t2);
      }, gw = "unknown";
      function Tw() {
        if ("unknown" !== gw)
          return gw;
        let { userAgent: e2, connection: t2 } = navigator, i2 = (e2.match(/NetType\/\S+/) || [])[0] || "";
        i2 = i2.toLowerCase().replace("nettype/", ""), "3gnet" === i2 && (i2 = "3g");
        let r2 = t2 && t2.type && t2.type.toLowerCase(), n2 = t2 && t2.effectiveType && t2.effectiveType.toLowerCase();
        return "slow-2" === n2 && (n2 = "2g"), r2 && (gw = Ew(r2, n2)), gw;
      }
      function Ew(e2, t2) {
        if (Zb[e2])
          return e2;
        switch (e2) {
          case "cellular":
          case "wimax":
            return t2 || "unknown";
          case "ethernet":
            return "wired";
          default:
            return "unknown";
        }
      }
      function Sw(e2) {
        gw = Ew(e2);
      }
      function Iw() {
        return Zb[Tw()];
      }
      function vw(e2, t2) {
        for (let i2 of Reflect.ownKeys(t2))
          if ("constructor" !== i2 && "prototype" !== i2 && "name" !== i2) {
            let r2 = Object.getOwnPropertyDescriptor(t2, i2) || "";
            Object.defineProperty(e2, i2, r2);
          }
        return e2;
      }
      function yw(e2) {
        return Aw(e2 / 4, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48e3);
      }
      function Aw(e2) {
        return 1e3 * e2 / (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48e3);
      }
      function Rw(e2) {
        return 4 * Cw(e2, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48e3);
      }
      function Cw(e2) {
        return e2 * (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48e3) / 1e3;
      }
      var bw = "undefined" != typeof window && "function" == typeof window.glog ? window.glog : () => {
      }, kw = () => {
        let e2 = navigator.language;
        return e2 = e2.substring(0, 2), "zh" === e2;
      }, Nw = function(e2) {
        if (!e2 || "object" != typeof e2 || "[object Object]" != Object.prototype.toString.call(e2))
          return false;
        let t2 = Object.getPrototypeOf(e2);
        if (null === t2)
          return true;
        let i2 = Object.prototype.hasOwnProperty.call(t2, "constructor") && t2.constructor;
        return "function" == typeof i2 && i2 instanceof i2 && Function.prototype.toString.call(i2) === Function.prototype.toString.call(Object);
      };
      function Dw(e2) {
        let t2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        return e2 <= 1 ? t2 : Dw(e2 - 1, t2, (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1) + t2);
      }
      function ww(e2) {
        return e2 > 8 ? 3e4 : 1e3 * Dw(e2);
      }
      function Ow(e2) {
        return Reflect.apply(Object.prototype.toString, e2, []).replace(/^\[object\s(\w+)\]$/, "$1").toLowerCase();
      }
      var Pw = (e2) => "function" == typeof e2, Mw = (e2) => void 0 === e2, Lw = (e2) => "string" == typeof e2, xw = (e2) => "number" == typeof e2, Vw = (e2) => "boolean" == typeof e2, Uw = (e2) => "object" === Ow(e2), Fw = (e2) => "array" === Ow(e2), Bw = (e2) => Ow(e2) === "MediaStreamTrack".toLowerCase(), Hw = (e2) => e2.isRemote, jw = (e2) => "promise" === Ow(e2), Gw = (e2) => Pw(e2) && e2.prototype.constructor === e2, Ww = (e2) => Gw(e2) ? e2.prototype.constructor.name : "", Jw = "undefined" != typeof AudioWorkletNode;
      function Kw(e2) {
        return new Promise((t2, i2) => {
          let r2 = [];
          e2.forEach((n2) => {
            n2.then(t2).catch((t3) => {
              r2.push(t3), r2.length === e2.length && i2(r2);
            });
          });
        });
      }
      function zw() {
        return performance && performance.now ? Math.floor(performance.now()) : Date.now();
      }
      var qw = (e2) => +e2 < 10 ? "0".concat(e2) : e2, Yw = (e2) => {
        let t2 = e2.match(/^\d+\.\d+\.\d+/)[0];
        if (!t2)
          return e2;
        let i2 = t2.split("."), r2 = qw(i2[1]) + qw(i2[2]);
        return i2[1] - 15 > 0 && (i2[1] = "15"), i2[2] - 15 > 0 && (i2[2] = "15"), "".concat(i2.join("."), ".").concat(r2);
      }, Qw = Object.prototype.hasOwnProperty;
      function Xw(e2) {
        if (null == e2)
          return true;
        if ("boolean" == typeof e2)
          return false;
        if ("number" == typeof e2)
          return 0 === e2;
        if ("string" == typeof e2 || "function" == typeof e2 || Array.isArray(e2))
          return 0 === e2.length;
        if (e2 instanceof Error)
          return "" === e2.message;
        if (Nw(e2))
          switch (Object.prototype.toString.call(e2)) {
            case "[object File]":
            case "[object Map]":
            case "[object Set]":
              return 0 === e2.size;
            case "[object Object]":
              for (let t2 in e2)
                if (Qw.call(e2, t2))
                  return false;
              return true;
          }
        return false;
      }
      function $w(e2, t2) {
        return { userId: t2, hasAudio: !!(e2 & hk), hasVideo: !!(e2 & lk), hasAuxiliary: !!(e2 & uk), hasSmall: !!(e2 & dk), audioMuted: !!(e2 & pk), videoMuted: !!(e2 & mk), audioAvailable: !(!(e2 & hk) || e2 & pk), videoAvailable: !(!(e2 & lk) || e2 & mk) };
      }
      function Zw(e2) {
        let t2 = { urls: "turn:".concat(e2.url) };
        return !Mw(e2.username) && !Mw(e2.credential) && (t2.username = e2.username, t2.credential = e2.credential, t2.credentialType = "password", Mw(e2.credentialType) || (t2.credentialType = e2.credentialType)), t2;
      }
      function eO(e2) {
        let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        if (!Lw(e2))
          return 0;
        let i2 = e2.split(".");
        return t2 ? (Number(i2[0]) << 24 | Number(i2[1]) << 16 | Number(i2[2]) << 8 | Number(i2[3])) >>> 0 : (Number(i2[3]) << 24 | Number(i2[2]) << 16 | Number(i2[1]) << 8 | Number(i2[0])) >>> 0;
      }
      var tO = function(e2, t2, i2, r2) {
        if (!Uw(e2) || !Uw(t2))
          return 0;
        let n2, o2 = 0, s2 = Object.keys(t2);
        for (let a2 = 0, c2 = s2.length; a2 < c2; a2++)
          if (n2 = s2[a2], !(Mw(t2[n2]) || i2 && i2.includes(n2)))
            if (Uw(e2[n2]) && Uw(t2[n2]))
              o2 += tO(e2[n2], t2[n2], i2, r2);
            else {
              if (r2 && r2.includes(t2[n2]))
                continue;
              e2[n2] !== t2[n2] && (e2[n2] = iO(t2[n2]), o2 += 1);
            }
        return o2;
      };
      function iO(e2) {
        if (Fw(e2)) {
          let t2 = [];
          return e2.forEach((e3, i2) => {
            t2[i2] = iO(e3);
          }), t2;
        }
        if (Uw(e2)) {
          let t2 = {};
          return Object.keys(e2).forEach((i2) => {
            t2[i2] = iO(e2[i2]);
          }), t2;
        }
        return e2;
      }
      var rO = (e2) => {
        let t2 = [];
        if (Fw(e2))
          t2 = [...e2];
        else if (Lw(e2)) {
          let i2 = document.getElementById(e2);
          i2 && t2.push(i2);
        } else
          e2 && t2.push(e2);
        return t2;
      }, nO = (e2) => Lw(e2) ? document.getElementById(e2) : e2, oO = new Intl.DateTimeFormat("zh-CN", { dateStyle: "short", timeStyle: "medium" }), sO = () => oO.format(/* @__PURE__ */ new Date());
      function aO(e2, t2) {
        let { keysToInclude: i2, keysToExclude: r2 } = t2;
        try {
          if (Fw(e2))
            return "[".concat(e2.map((e3) => aO(e3, { keysToInclude: i2, keysToExclude: r2 })).join(","), "]");
          if (!Nw(e2) || !Fw(i2) && !Fw(r2))
            return JSON.stringify(e2);
          let t3 = {}, n2 = new Set(i2), o2 = new Set(r2);
          return Object.keys(e2).forEach((s2) => {
            (0 === o2.size && n2.has(s2) || 0 === n2.size && !o2.has(s2)) && (t3[s2] = Nw(e2[s2]) || Fw(e2[s2]) ? JSON.parse(aO(e2[s2], { keysToExclude: r2, keysToInclude: i2 })) : e2[s2]);
          }), JSON.stringify(t3);
        } catch (wk2) {
          return "{}";
        }
      }
      function cO(e2) {
        let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = [];
        return Object.keys(e2).forEach((r2) => {
          t2 === e2[r2] && i2.push(r2);
        }), aO(e2, { keysToInclude: i2 });
      }
      function lO(e2) {
        return e2.replace(/[\u4e00-\u9fa5]/g, "aa").length;
      }
      var dO = () => {
        var e2, t2, i2, r2;
        return null != (e2 = window.screen) && e2.orientation ? !(null == (r2 = null == (i2 = null == (t2 = window.screen) ? void 0 : t2.orientation) ? void 0 : i2.type) || !r2.includes("portrait")) : 0 === window.orientation || 180 === window.orientation;
      }, uO = (e2) => cb(void 0, null, function* () {
        return new Promise((t2, i2) => {
          let r2;
          if (Lw(e2))
            r2 = new Image(), r2.crossOrigin = "anonymous", r2.src = e2;
          else if (r2 = e2, r2.complete)
            return void t2(r2);
          r2.onload = () => t2(r2), r2.onerror = i2;
        });
      }), hO = (e2) => {
        let t2 = e2.split(".");
        return +t2[0] << 24 | +t2[1] << 16 | +t2[2] << 8 | +t2[3];
      }, pO = (e2) => (Object.keys(e2).forEach((t2) => {
        xw(e2[t2]) && (t2.startsWith("uint") || t2.startsWith("int")) ? e2[t2] = Math.floor(e2[t2]) : (Nw(e2[t2]) || Fw(e2[t2])) && pO(e2[t2]);
      }), e2), mO = Object.prototype.hasOwnProperty;
      function _O(e2) {
        if (null == e2)
          return true;
        if ("boolean" == typeof e2)
          return false;
        if ("number" == typeof e2)
          return 0 === e2;
        if ("string" == typeof e2 || "function" == typeof e2 || Array.isArray(e2))
          return 0 === e2.length;
        if (e2 instanceof Error)
          return "" === e2.message;
        if (function(e3) {
          if (!e3 || "object" != typeof e3 || "[object Object]" != Object.prototype.toString.call(e3))
            return false;
          let t2 = Object.getPrototypeOf(e3);
          if (null === t2)
            return true;
          let i2 = Object.prototype.hasOwnProperty.call(t2, "constructor") && t2.constructor;
          return "function" == typeof i2 && i2 instanceof i2 && Function.prototype.toString.call(i2) === Function.prototype.toString.call(Object);
        }(e2))
          switch (Object.prototype.toString.call(e2)) {
            case "[object File]":
            case "[object Map]":
            case "[object Set]":
              return 0 === e2.size;
            case "[object Object]":
              for (let t2 in e2)
                if (mO.call(e2, t2))
                  return false;
              return true;
          }
        return false;
      }
      var fO = class {
        constructor(e2) {
          sb(this, "userId"), sb(this, "remoteUserId"), sb(this, "id"), sb(this, "sdkAppId"), sb(this, "type"), sb(this, "isLocal"), this.id = e2.id, this.userId = e2.userId, this.sdkAppId = e2.sdkAppId, this.remoteUserId = e2.remoteUserId, this.isLocal = "boolean" != typeof e2.isLocal || e2.isLocal, this.type = this.isLocal ? "" : e2.type;
        }
        createChild(e2) {
          return Object.setPrototypeOf(e2, this);
        }
        setUserId(e2) {
          this.userId = e2;
        }
        setSdkAppId(e2) {
          this.sdkAppId = e2;
        }
        log(e2, t2) {
          let i2 = this.isLocal ? this.userId : this.remoteUserId;
          t2.unshift("[".concat(this.isLocal ? "â" : "â").concat(this.type && "main" !== this.type ? "*" : "").concat(this.id).concat(i2 ? "|".concat(i2) : "", "]")), EO.log(e2, t2, void 0 === this.userId || _O(this.userId), this.userId, this.sdkAppId);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(2, t2);
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(1, t2);
        }
        warn() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(3, t2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(4, t2);
        }
      }, gO = tw, TO = !(AN || RN || CD), EO = new class {
        constructor() {
          sb(this, "_isEnableUploadLog", true), sb(this, "_localJoinedUser", /* @__PURE__ */ new Map()), sb(this, "_queue", []), sb(this, "_timeoutId", -1), sb(this, "_logLevel", 1), sb(this, "_logLevelToUpload", 2), !Mb && !Lb && (this.checkURLParam(), this.installEvents());
        }
        get isAbleToUpload() {
          return this._isEnableUploadLog && -1 !== this._timeoutId;
        }
        installEvents() {
          ew.on(gO.JOIN_SCHEDULE_SUCCESS, (e2) => {
            let { schedule: t2 } = e2;
            var i2;
            (null == (i2 = null == t2 ? void 0 : t2.config) ? void 0 : i2.logLevelToUpload) && Qb[t2.config.logLevelToUpload] && (this._logLevelToUpload = t2.config.logLevelToUpload);
          }), ew.on(gO.JOIN_SUCCESS, (e2) => {
            let { room: t2 } = e2;
            this.addJoinedUser({ userId: t2.userId, sdkAppId: t2.sdkAppId }), this.startUpload();
          }), ew.once(gO.JOIN_FAILED, () => {
            this.startUpload();
          }), ew.on(gO.LEAVE_SUCCESS, (e2) => {
            let { room: t2 } = e2;
            this.deleteJoinedUser(t2.userId);
          });
        }
        startUpload() {
          -1 === this._timeoutId && this.uploadInterval();
        }
        addJoinedUser(e2) {
          this._localJoinedUser.set(e2.userId, e2), this.startUpload();
        }
        deleteJoinedUser(e2) {
          this._localJoinedUser.delete(e2);
        }
        uploadInterval() {
          this.upload().catch(() => {
          }), this._timeoutId = window.setTimeout(() => this.uploadInterval(), 2e3);
        }
        getLogsToUpload() {
          let e2 = { map: /* @__PURE__ */ new Map(), splicedQueue: [] };
          if (this._queue[0].forAllJoinedClients && 0 === this._localJoinedUser.size)
            return e2;
          let t2 = 0;
          for (; t2 < this._queue.length && 50 !== t2; t2++) {
            let i2 = this._queue[t2];
            if (i2.forAllJoinedClients)
              this._localJoinedUser.forEach((t3) => {
                let { userId: r2, sdkAppId: n2 } = t3;
                e2.map.has(r2) ? e2.map.get(r2).logs.push(i2) : e2.map.set(r2, { userId: r2, sdkAppId: n2, logs: [i2] });
              });
            else if (Lw(i2.userId) && xw(i2.sdkAppId)) {
              let { userId: t3, sdkAppId: r2 } = i2;
              e2.map.has(t3) ? e2.map.get(t3).logs.push(i2) : e2.map.set(t3, { userId: t3, sdkAppId: r2, logs: [i2] });
            }
          }
          return e2.map.size > 0 && (e2.splicedQueue = this._queue.splice(0, t2)), e2;
        }
        upload() {
          return cb(this, null, function* () {
            if (0 === this._queue.length || !this._isEnableUploadLog)
              return;
            let { map: e2, splicedQueue: t2 } = this.getLogsToUpload();
            if (0 === e2.size)
              return;
            try {
              let t3 = [...e2.values()];
              for (let e3 = 0; e3 < t3.length; e3++) {
                let { userId: i3, sdkAppId: r2, logs: n2 } = t3[e3];
                yield this.uploadLogWithRetry(JSON.stringify({ timestamp: Rb(), sdkAppId: String(r2), userId: i3, version: Nb, log: n2.map((e4) => e4.log).join("\n") }), r2), n2.forEach((e4) => e4.uploaded = true);
              }
            } catch (Ob2) {
            }
            let i2 = t2.filter((e3) => !e3.uploaded);
            i2.length > 0 && (this._queue = i2.concat(this._queue));
          });
        }
        uploadLogWithRetry(e2, t2) {
          return ZD({ retryFunction: () => cN({ url: fw(t2, qb.LOG), body: e2, timeout: 5e3 }), settings: { retries: 3, timeout: 1e3 }, onError: (e3) => {
            let { retry: t3 } = e3;
            t3();
          } })();
        }
        getPrefix(e2) {
          let t2 = /* @__PURE__ */ new Date();
          t2.setTime(Ab());
          let i2 = String(t2.getMilliseconds());
          return "padStart" in String.prototype && (i2 = i2.toString().padStart(3, "0")), "[".concat(t2.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1"), ":").concat(i2, "] <").concat(Qb[e2], ">");
        }
        getLogLevel() {
          return this._logLevel;
        }
        setLogLevel(e2) {
          Mw(Qb[e2]) || (this._logLevel !== e2 && this.info("setLogLevel", e2), this._logLevel = e2);
        }
        enableUploadLog() {
          this._isEnableUploadLog = true;
        }
        disableUploadLog() {
          this.warn("disableUploadLog"), this._isEnableUploadLog = false;
        }
        logChunkToString(e2) {
          if (Lw(e2))
            return e2;
          try {
            return e2 instanceof Error ? e2.toString() : JSON.stringify(e2);
          } catch (wb2) {
            return "";
          }
        }
        log(e2, t2) {
          let i2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r2 = arguments.length > 3 ? arguments[3] : void 0, n2 = arguments.length > 4 ? arguments[4] : void 0;
          var o2;
          if (t2.unshift(this.getPrefix(e2)), this._isEnableUploadLog && e2 >= this._logLevelToUpload && this._queue.push({ log: t2.reduce((e3, t3) => "".concat(e3, " ").concat(this.logChunkToString(t3)).trim(), ""), level: e2, userId: r2, sdkAppId: n2, forAllJoinedClients: i2 }), e2 < this._logLevel)
            return;
          let s2 = (null == (o2 = Qb[e2]) ? void 0 : o2.toLowerCase()) || "info";
          TO ? console[s2]("%cTRTC%c%s", "padding: 1px 4px;border-radius: 3px;color: #fff;background: #1E88E5;", "display: inline", ...t2) : console[s2](...t2);
        }
        debug() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(1, t2);
        }
        info() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(2, t2);
        }
        warn() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(3, t2);
        }
        error() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          this.log(4, t2);
        }
        createLogger(e2) {
          return new fO(e2);
        }
        checkURLParam() {
          let e2 = new URLSearchParams(location.search).get("logLevelToUpload"), t2 = e2 ? Number(e2) : -1;
          Qb[t2] && (this._logLevelToUpload = t2);
        }
      }(), SO = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e2) => {
          let t2 = 16 * Math.random() | 0;
          return ("x" == e2 ? t2 : 3 & t2 | 8).toString(16);
        });
      }, IO = new class {
        constructor() {
          sb(this, "_prefix", "TRTC"), sb(this, "_queue", /* @__PURE__ */ new Map()), this.checkStorage();
        }
        getRealKey(e2) {
          return "".concat(this._prefix, "_").concat(e2);
        }
        checkStorage() {
          FD() && (setInterval(this.doFlush.bind(this), 2e4), Object.keys(localStorage).filter((e2) => {
            if (e2.startsWith(this._prefix)) {
              let t2 = localStorage.getItem(e2);
              if (!t2)
                return false;
              let i2 = JSON.parse(t2);
              if (i2 && i2.expiresIn < Date.now())
                return true;
            }
            return false;
          }).forEach((e2) => localStorage.removeItem(e2)));
        }
        doFlush() {
          if (FD())
            try {
              for (let [e2, t2] of this._queue)
                localStorage.setItem(e2, JSON.stringify(t2));
            } catch (rM2) {
              EO.warn(rM2);
            }
        }
        getItem(e2) {
          if (!FD())
            return null;
          try {
            let t2 = localStorage.getItem(this.getRealKey(e2));
            if (!t2)
              return null;
            let i2 = JSON.parse(t2);
            return i2 && i2.expiresIn >= Date.now() ? i2.value : null;
          } catch (wb2) {
            EO.warn(wb2);
          }
        }
        setItem(e2, t2) {
          if (FD())
            try {
              let i2 = { expiresIn: Date.now() + ek, value: t2 };
              this._queue.set(this.getRealKey(e2), i2);
            } catch (wk2) {
              EO.warn(wk2);
            }
        }
        deleteItem(e2) {
          if (!FD())
            return false;
          try {
            return e2 = this.getRealKey(e2), this._queue.delete(e2), localStorage.removeItem(e2), true;
          } catch (wb2) {
            return EO.warn(wb2), false;
          }
        }
        clear() {
          if (FD())
            try {
              localStorage.clear();
            } catch (rM2) {
              EO.warn(rM2);
            }
        }
      }(), vO = {};
      rb(vO, { HTTPS_API: () => UO, IS_GET_CAPABILITIES_SUPPORTED: () => tP, IS_GET_SETTINGS_SUPPORTED: () => eP, IS_SEI_SUPPORTED: () => iP, IS_SPC_SUPPORTED: () => QO, basis: () => aP, checkSystemRequirementsInternal: () => LO, decodeSupportStatus: () => MO, encodeSupportStatus: () => PO, getBrowserInfo: () => CO, getDisplayResolution: () => BO, isAddTransceiverSupported: () => YO, isBrowserSupported: () => bO, isGetReceiversSupported: () => KO, isGetSendersSupported: () => zO, isGetTransceiversSupported: () => qO, isGetUserMediaSupported: () => HO, isMediaDevicesSupported: () => NO, isMediaSessionSupported: () => oP, isMediaStreamTrackProcessorSupported: () => OO, isReplaceTrackSupported: () => $O, isScreenCaptureApiAvailable: () => VO, isSelectedCandidatePair: () => FO, isSetParametersSupported: () => ZO, isSmallStreamAPISupported: () => GO, isSmallStreamSupported: () => WO, isStopTransceiverSupported: () => XO, isTRTCSupported: () => xO, isUnifiedPlanDefault: () => JO, isUsedInHttpProtocol: () => wO, isWebAudioSupported: () => jO, isWebCodecSupported: () => nP, isWebCodecsSupported: () => kO, isWebRTCSupported: () => rP, isWebTransportSupported: () => sP });
      var yO = nb(pb(), 1), AO = { result: false, detail: { isBrowserSupported: false, isWebRTCSupported: false, isWebCodecsSupported: false, isMediaDevicesSupported: false, isScreenShareSupported: false, isSmallStreamSupported: false, isH264EncodeSupported: false, isVp8EncodeSupported: false, isH264DecodeSupported: false, isVp8DecodeSupported: false } }, RO = /* @__PURE__ */ new Map([[NN, ["Firefox", DN]], [MN, ["Edg", LN]], [RD, ["Chrome", kD]], [ND, ["Safari", wD]], [HN, ["TBS", jN]], [GN, ["XWEB", WN]], [qN && vN, ["WeChat", YN]], [ZN, ["QQ(Win)", eD]], [XN, ["QQ(Mobile)", $N]], [QN, ["QQ(Mobile X5)", $N]], [tD, ["QQ(Mac)", iD]], [rD, ["QQ(iPad)", nD]], [hD, ["MI", pD]], [mD, ["HW", fD]], [gD, ["Samsung", TD]], [ED, ["OPPO", SD]], [ID, ["VIVO", vD]], [ON, ["EDGE", PN]], [VN, ["SogouMobile", UN]], [FN, ["Sogou", BN]]]);
      function CO() {
        let e2 = RO.get(true);
        return { browserName: e2 ? e2[0] : "unknown", browserVersion: e2 ? e2[1] : "unknown" };
      }
      var bO = function() {
        return !(dD || ON || MN && xN < 80 || NN && wN < 56);
      }, kO = function() {
        return ["VideoDecoder", "VideoEncoder", "AudioEncoder", "AudioDecoder", "MediaStreamTrackGenerator"].every((e2) => e2 in window);
      }, NO = function() {
        if (!navigator.mediaDevices)
          return wO() || EO.error(hN.NOT_SUPPORTED_MEDIA), false;
        let e2 = ["getUserMedia", "enumerateDevices"];
        return e2.filter((e3) => e3 in navigator.mediaDevices).length === e2.length;
      }, DO = false;
      function wO() {
        return "http:" === location.protocol && !UD && (DO || EO.error(XD({ key: uN.NOT_SUPPORTED_HTTP })), DO = true, true);
      }
      var OO = function() {
        return (null == window ? void 0 : window.OffscreenCanvas) && (null == window ? void 0 : window.MediaStreamTrackProcessor) && (null == window ? void 0 : window.MediaStreamTrackGenerator);
      }, PO = function() {
        return cb(this, null, function* () {
          if (AO.detail.isH264EncodeSupported && AO.detail.isVp8EncodeSupported)
            return { isH264EncodeSupported: AO.detail.isH264EncodeSupported, isVp8EncodeSupported: AO.detail.isVp8EncodeSupported };
          let e2, t2 = false, i2 = false;
          try {
            let r2 = new RTCPeerConnection(), n2 = document.createElement(ok.CANVAS);
            n2.getContext("2d");
            let o2 = n2.captureStream(0);
            return r2.addTrack(o2.getVideoTracks()[0], o2), e2 = yield r2.createOffer(), -1 !== e2.sdp.toLowerCase().indexOf("h264") && (t2 = true), -1 !== e2.sdp.toLowerCase().indexOf("vp8") && (i2 = true), r2.close(), AO.detail.isH264EncodeSupported = t2, AO.detail.isVp8EncodeSupported = i2, { isH264EncodeSupported: AO.detail.isH264EncodeSupported, isVp8EncodeSupported: AO.detail.isVp8EncodeSupported };
          } catch (wk2) {
            return { isH264EncodeSupported: false, isVp8EncodeSupported: false };
          }
        });
      }, MO = function() {
        return cb(this, null, function* () {
          if (AO.detail.isH264DecodeSupported && AO.detail.isVp8DecodeSupported)
            return { isH264DecodeSupported: AO.detail.isH264DecodeSupported, isVp8DecodeSupported: AO.detail.isVp8DecodeSupported };
          let e2, t2 = false, i2 = false;
          try {
            let r2 = new RTCPeerConnection();
            return e2 = yield r2.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }), -1 !== e2.sdp.toLowerCase().indexOf("h264") && (t2 = true), -1 !== e2.sdp.toLowerCase().indexOf("vp8") && (i2 = true), r2.close(), { isH264DecodeSupported: t2, isVp8DecodeSupported: i2 };
          } catch (wk2) {
            return { isH264DecodeSupported: false, isVp8DecodeSupported: false };
          }
        });
      }, LO = function() {
        return cb(this, null, function* () {
          if (AO.result && AO.detail.isH264EncodeSupported && AO.detail.isVp8EncodeSupported && AO.detail.isH264DecodeSupported && AO.detail.isVp8DecodeSupported)
            return AO;
          let e2 = bO(), t2 = rP(), i2 = kO(), r2 = NO(), { isH264EncodeSupported: n2, isVp8EncodeSupported: o2 } = yield PO(), { isH264DecodeSupported: s2, isVp8DecodeSupported: a2 } = yield MO();
          if (!n2 || !o2) {
            let e3 = yield PO();
            EO.warn("detect encode again h264:".concat(n2, " vp8:").concat(o2, " result: ").concat(JSON.stringify(e3))), n2 = e3.isH264EncodeSupported, o2 = e3.isVp8EncodeSupported;
          }
          if (n2 && s2 && (ED || ID || OD) && !HN && yD() < 79) {
            let { encode: e3, decode: t3 } = yield function() {
              return cb(this, null, function* () {
                return new Promise((e4) => cb(this, null, function* () {
                  let t4 = { encode: false, decode: false }, i3 = () => {
                  };
                  try {
                    EO.warn("start detect h264 supported by encoding and decoding canvas stream");
                    let r3 = document.createElement("canvas"), n3 = r3.getContext("2d");
                    r3.width = 640, r3.height = 480;
                    let o3 = setInterval(() => {
                      n3.fillText("test", Math.floor(640 * Math.random()), Math.floor(480 * Math.random()));
                    }, 33), s3 = -1, a3 = -1;
                    i3 = () => {
                      clearInterval(s3), clearInterval(o3), clearTimeout(a3), l2.close(), d2.close(), c2.getTracks().forEach((e5) => e5.stop());
                    }, a3 = setTimeout(() => {
                      i3(), e4(t4);
                    }, 3e3);
                    let c2 = r3.captureStream(), l2 = new RTCPeerConnection({}), d2 = new RTCPeerConnection({ offerToReceiveAudio: true, offerToReceiveVideo: true });
                    l2.addEventListener("icecandidate", (e5) => d2.addIceCandidate(e5.candidate)), d2.addEventListener("icecandidate", (e5) => l2.addIceCandidate(e5.candidate)), l2.addTrack(c2.getVideoTracks()[0], c2);
                    let u2 = yield l2.createOffer();
                    yield l2.setLocalDescription(u2), yield d2.setRemoteDescription(u2);
                    let h2 = yield d2.createAnswer(), p2 = yO.default.parse(h2.sdp), m2 = p2.media[0].rtp.findIndex((e5) => "H264" === e5.codec);
                    p2.media[0].rtp = [p2.media[0].rtp[m2]], p2.media[0].fmtp = p2.media[0].fmtp.filter((e5) => e5.payload === p2.media[0].rtp[0].payload), p2.media[0].rtcpFb && (p2.media[0].rtcpFb = p2.media[0].rtcpFb.filter((e5) => e5.payload === p2.media[0].rtp[0].payload)), h2.sdp = yO.default.write(p2), yield d2.setLocalDescription(h2), yield l2.setRemoteDescription(h2), s3 = setInterval(() => cb(this, null, function* () {
                      t4.encode && t4.decode && (i3(), e4(t4));
                      let r4 = yield l2.getStats(), n4 = yield d2.getStats();
                      t4.encode || r4.forEach((e5) => {
                        "outbound-rtp" === e5.type && e5.mediaType === ok.VIDEO && e5.framesEncoded > 0 && (t4.encode = true);
                      }), t4.decode || n4.forEach((e5) => {
                        "inbound-rtp" === e5.type && e5.mediaType === ok.VIDEO && e5.framesDecoded > 0 && (t4.decode = true);
                      });
                    }), 500);
                  } catch (r3) {
                    i3(), EO.warn(r3), e4(t4);
                  }
                }));
              });
            }();
            n2 = e3, s2 = t3;
          }
          return AO.result = e2 && t2 && r2 && (n2 || o2) && (s2 || a2), AO.detail.isBrowserSupported = e2, AO.detail.isWebRTCSupported = t2, AO.detail.isWebCodecsSupported = i2, AO.detail.isMediaDevicesSupported = r2, AO.detail.isScreenShareSupported = VO(), AO.detail.isSmallStreamSupported = WO(), AO.detail.isH264EncodeSupported = n2, AO.detail.isVp8EncodeSupported = o2, AO.detail.isH264DecodeSupported = s2, AO.detail.isVp8DecodeSupported = a2, AO.result || EO.error("".concat(navigator.userAgent, " ").concat(cO(AO.detail, false))), IO.setItem(cP, { ua: navigator.userAgent, checkResult: AO }), AO;
        });
      }, xO = function() {
        return AO.result;
      }, VO = function() {
        return !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia);
      };
      var UO = (e2, t2, i2) => {
        "http:" === location.protocol && !UD && (e2[t2] = () => {
          throw new vb({ code: Sb.INVALID_OPERATION, message: hN.NOT_SUPPORTED_HTTP });
        });
      }, FO = function(e2) {
        return !("candidate-pair" !== e2.type || !e2.nominated || "in-progress" !== e2.state && "succeeded" !== e2.state) && !(Vw(e2.selected) && !e2.selected);
      };
      function BO() {
        let e2 = "";
        if (screen.width) {
          let t2 = screen.width ? screen.width * window.devicePixelRatio : "", i2 = screen.height ? screen.height * window.devicePixelRatio : "";
          e2 += "".concat(t2, " * ").concat(i2);
        }
        return e2;
      }
      function HO() {
        return navigator.getUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
      }
      function jO() {
        let e2 = { isSupported: false }, t2 = ["AudioContext", "webkitAudioContext", "mozAudioContext", "msAudioContext"];
        for (let i2 = 0; i2 < t2.length; i2++)
          if (t2[i2] in window) {
            e2.isSupported = true;
            break;
          }
        return e2.isSupported;
      }
      function GO() {
        return "captureStream" in HTMLCanvasElement.prototype;
      }
      function WO() {
        return !(qN || AN || bD && bD < 63) && !(!bO() || !GO());
      }
      var JO = function() {
        if (Mw(window.RTCRtpTransceiver) || !("currentDirection" in RTCRtpTransceiver.prototype))
          return false;
        let e2 = null, t2 = false;
        try {
          e2 = new RTCPeerConnection({ sdpSemantics: Vk }), e2.addTransceiver(ok.AUDIO), t2 = true;
        } catch (wb2) {
        }
        return null == e2 || e2.close(), t2;
      };
      function KO() {
        return "RTCPeerConnection" in window && "getReceivers" in window.RTCPeerConnection.prototype;
      }
      function zO() {
        return "RTCPeerConnection" in window && "getSenders" in window.RTCPeerConnection.prototype;
      }
      function qO() {
        return "RTCPeerConnection" in window && "getTransceivers" in window.RTCPeerConnection.prototype;
      }
      function YO() {
        return 11 !== MD && ("RTCPeerConnection" in window && "addTransceiver" in window.RTCPeerConnection.prototype);
      }
      var QO = !(!YO() || AD && bD < 74);
      function XO() {
        return "RTCRtpTransceiver" in window && "stop" in window.RTCRtpTransceiver.prototype;
      }
      function $O() {
        return "RTCRtpSender" in window && "replaceTrack" in window.RTCRtpSender.prototype;
      }
      function ZO() {
        return "RTCRtpSender" in window && "setParameters" in window.RTCRtpSender.prototype && zO();
      }
      var eP = window.MediaStreamTrack && "getSettings" in MediaStreamTrack.prototype, tP = window.MediaStreamTrack && "getCapabilities" in MediaStreamTrack.prototype, iP = "RTCRtpSender" in window && "createEncodedStreams" in window.RTCRtpSender.prototype && yD() >= 86, rP = function() {
        return ["RTCPeerConnection", "webkitRTCPeerConnection", "RTCIceGatherer"].filter((e2) => e2 in window).length > 0;
      };
      function nP() {
        let e2 = { AudioDecoder: false, AudioEncoder: false, VideoDecoder: false, VideoEncoder: false, ImageDecoder: false };
        return Mw(window.AudioDecoder) || (e2.AudioDecoder = true), Mw(window.AudioEncoder) || (e2.AudioEncoder = true), Mw(window.VideoDecoder) || (e2.VideoDecoder = true), Mw(window.VideoEncoder) || (e2.VideoEncoder = true), Mw(window.ImageDecoder) || (e2.ImageDecoder = true), e2;
      }
      function oP() {
        return "mediaSession" in navigator && !Mw(navigator.mediaSession.setActionHandler);
      }
      function sP() {
        return !Mw(window.WebTransport);
      }
      function aP() {
        let e2 = { browser: "".concat(BD.name, "/").concat(BD.version), os: JD(), displayResolution: BO(), isScreenShareSupported: VO(), isWebRTCSupported: rP(), isGetUserMediaSupported: HO(), isWebAudioSupported: jO(), isWebSocketsSupported: "WebSocket" in window && 2 === window.WebSocket.CLOSING, isWebCodecSupported: nP(), isMediaSessionSupported: oP(), isWebTransportSupported: sP() };
        return navigator.userAgent.includes("miniProgram") && (e2.browser = "mini/".concat(e2.browser)), e2;
      }
      var cP = "checkResult";
      !function() {
        wO();
        let e2 = IO.getItem(cP);
        e2 && e2.ua === navigator.userAgent && (AO = e2.checkResult), LO();
      }();
      var lP = nb(lb(), 1), dP = Symbol("instance"), uP = Symbol("cacheResult"), hP = class {
        constructor(e2, t2, i2) {
          this.oldState = e2, this.newState = t2, this.action = i2, this.aborted = false;
        }
        abort(e2) {
          this.aborted = true, gP.call(e2, this.oldState, new Error("action '".concat(this.action, "' aborted")));
        }
        toString() {
          return "".concat(this.action, "ing");
        }
      }, pP = class extends Error {
        constructor(e2, t2, i2) {
          super(t2), this.state = e2, this.message = t2, this.cause = i2;
        }
      };
      var mP = /* @__PURE__ */ new Map();
      function _P(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return (r2, n2, o2) => {
          let s2 = i2.action || n2;
          if (!i2.context) {
            let i3 = mP.get(r2) || [];
            mP.has(r2) || mP.set(r2, i3), i3.push({ from: e2, to: t2, action: s2 });
          }
          let a2 = o2.value;
          o2.value = function() {
            let r3 = this;
            for (var n3 = arguments.length, o3 = new Array(n3), c2 = 0; c2 < n3; c2++)
              o3[c2] = arguments[c2];
            if (i2.context && (r3 = TP.get("function" == typeof i2.context ? i2.context.call(this, ...o3) : i2.context)), r3.state === t2)
              return i2.sync ? r3[uP] : Promise.resolve(r3[uP]);
            r3.state instanceof hP && r3.state.action == i2.abortAction && r3.state.abort(r3);
            let l2 = null;
            Array.isArray(e2) ? 0 == e2.length ? r3.state instanceof hP && r3.state.abort(r3) : ("string" != typeof r3.state || !e2.includes(r3.state)) && (l2 = new pP(r3._state, "".concat(r3.name, " ").concat(s2, " to ").concat(t2, " failed: current state ").concat(r3._state, " not from ").concat(e2.join("|")))) : e2 !== r3.state && (l2 = new pP(r3._state, "".concat(r3.name, " ").concat(s2, " to ").concat(t2, " failed: current state ").concat(r3._state, " not from ").concat(e2)));
            let d2 = (e3) => {
              if (i2.fail && i2.fail.call(this, e3), i2.sync) {
                if (i2.ignoreError)
                  return e3;
                throw e3;
              }
              return i2.ignoreError ? Promise.resolve(e3) : Promise.reject(e3);
            };
            if (l2)
              return d2(l2);
            let u2 = r3.state, h2 = new hP(u2, t2, s2);
            gP.call(r3, h2);
            let p2 = (e3) => {
              var n4;
              return r3[uP] = e3, h2.aborted || (gP.call(r3, t2), null === (n4 = i2.success) || void 0 === n4 || n4.call(this, r3[uP])), e3;
            }, m2 = (e3) => {
              let t3 = e3 instanceof Error ? e3.message : String(e3);
              return gP.call(r3, u2, e3), d2(new pP(r3._state, "action '".concat(s2, "' failed :").concat(t3), e3 instanceof Error ? e3 : new Error(t3)));
            };
            try {
              let e3 = a2.apply(this, o3);
              return function(e4) {
                return "object" == typeof e4 && e4 && "then" in e4;
              }(e3) ? e3.then(p2).catch(m2) : i2.sync ? p2(e3) : Promise.resolve(p2(e3));
            } catch (_2) {
              return m2(_2);
            }
          };
        };
      }
      var fP = "undefined" != typeof window && window.__AFSM__ ? (e2, t2) => {
        window.dispatchEvent(new CustomEvent(e2, { detail: t2 }));
      } : "undefined" != typeof importScripts ? (e2, t2) => {
        postMessage({ type: e2, payload: t2 });
      } : () => {
      };
      function gP(e2, t2) {
        let i2 = this._state;
        this._state = e2;
        let r2 = e2.toString();
        e2 && this.emit(r2, i2), this.emit(TP.STATECHANGED, e2, i2, t2), this.updateDevTools({ value: e2, old: i2, err: t2 instanceof Error ? t2.message : String(t2) });
      }
      var TP = class extends lP.default {
        constructor(e2, t2, i2) {
          super(), this.name = e2, this.groupName = t2, this._state = TP.INIT, e2 || (e2 = Date.now().toString(36)), i2 ? Object.setPrototypeOf(this, i2) : i2 = Object.getPrototypeOf(this), t2 || (this.groupName = this.constructor.name);
          let r2 = i2[dP];
          r2 ? this.name = r2.name + "-" + r2.count++ : i2[dP] = { name: this.name, count: 0 }, this.updateDevTools({ diagram: this.stateDiagram });
        }
        get stateDiagram() {
          let e2 = Object.getPrototypeOf(this), t2 = mP.get(e2) || [], i2 = /* @__PURE__ */ new Set(), r2 = [], n2 = [], o2 = /* @__PURE__ */ new Set(), s2 = Object.getPrototypeOf(e2);
          mP.has(s2) && (s2.stateDiagram.forEach((e3) => i2.add(e3)), s2.allStates.forEach((e3) => o2.add(e3))), t2.forEach((e3) => {
            let { from: t3, to: i3, action: o3 } = e3;
            "string" == typeof t3 ? r2.push({ from: t3, to: i3, action: o3 }) : t3.length ? t3.forEach((e4) => {
              r2.push({ from: e4, to: i3, action: o3 });
            }) : n2.push({ to: i3, action: o3 });
          }), r2.forEach((e3) => {
            let { from: t3, to: r3, action: n3 } = e3;
            o2.add(t3), o2.add(r3), o2.add(n3 + "ing"), i2.add("".concat(t3, " --> ").concat(n3, "ing : ").concat(n3)), i2.add("".concat(n3, "ing --> ").concat(r3, " : ").concat(n3, " ð¢")), i2.add("".concat(n3, "ing --> ").concat(t3, " : ").concat(n3, " ð´"));
          }), n2.forEach((e3) => {
            let { to: t3, action: r3 } = e3;
            i2.add("".concat(r3, "ing --> ").concat(t3, " : ").concat(r3, " ð¢")), o2.forEach((e4) => {
              e4 !== t3 && i2.add("".concat(e4, " --> ").concat(r3, "ing : ").concat(r3));
            });
          });
          let a2 = [...i2];
          return Object.defineProperties(e2, { stateDiagram: { value: a2 }, allStates: { value: o2 } }), a2;
        }
        static get(e2) {
          let t2;
          return "string" == typeof e2 ? (t2 = TP.instances.get(e2), t2 || TP.instances.set(e2, t2 = new TP(e2, void 0, Object.create(TP.prototype)))) : (t2 = TP.instances2.get(e2), t2 || TP.instances2.set(e2, t2 = new TP(e2.constructor.name, void 0, Object.create(TP.prototype)))), t2;
        }
        static getState(e2) {
          var t2;
          return null === (t2 = TP.get(e2)) || void 0 === t2 ? void 0 : t2.state;
        }
        updateDevTools() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          fP(TP.UPDATEAFSM, Object.assign({ name: this.name, group: this.groupName }, e2));
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          gP.call(this, e2);
        }
      };
      TP.STATECHANGED = "stateChanged", TP.UPDATEAFSM = "updateAFSM", TP.INIT = "[*]", TP.ON = "on", TP.OFF = "off", TP.instances = /* @__PURE__ */ new Map(), TP.instances2 = /* @__PURE__ */ new WeakMap();
      var EP = (null == window ? void 0 : window.requestIdleCallback) || function(e2) {
        let t2 = Date.now();
        return setTimeout(() => {
          e2({ didTimeout: false, timeRemaining: () => Math.max(0, 50 - (Date.now() - t2)) });
        }, 1e3);
      }, SP = (null == window ? void 0 : window.cancelIdleCallback) || function(e2) {
        clearTimeout(e2);
      }, IP = (null == window ? void 0 : window.cancelAnimationFrame) || (null == window ? void 0 : window.mozCancelAnimationFrame), vP = class {
        static generateTaskID() {
          return this.currentTaskID++;
        }
        static run() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : sN, t2 = arguments.length > 1 ? arguments[1] : void 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
          i2 = eb(e2 === oN ? { delay: 2e3, count: 0, backgroundTask: true } : e2 === rN ? { delay: 1e4, count: 0 } : e2 === nN ? { fps: 60, delay: 16.6, count: 0, backgroundTask: true } : { delay: 2e3, count: 0, backgroundTask: true }, i2), Uw(t2) && (i2 = eb(eb({}, i2), t2)), Pw(e2) && (t2 = e2, e2 = sN);
          let r2 = eb({ taskID: this.generateTaskID(), loopCount: 0, intervalID: null, timeoutID: null, rafID: null, ricID: null, taskName: e2, callback: t2 }, i2);
          return this.taskMap.set(r2.taskID, r2), this[e2](r2), r2.taskID;
        }
        static interval(e2) {
          return e2.intervalID = setInterval(() => {
            e2.callback(), e2.loopCount += 1, this.isBreakLoop(e2);
          }, e2.delay);
        }
        static intervalInWorker(e2) {
          e2.delay = (1e3 / e2.fps).toFixed(2);
          let t2 = new Worker(URL.createObjectURL(new Blob(["\n        let timerID = null;\n        self.onmessage = function (e) {\n          if (e.data === 'start') {\n            timerID = setInterval(() => {\n              self.postMessage('tick');\n            }, ".concat(e2.delay, ");\n          } else if (e.data === 'stop') {\n            clearInterval(timerID);\n          }\n        };\n      ")], { type: "application/javascript" })));
          t2.onmessage = (i2) => {
            "tick" === i2.data && (e2.callback(), e2.loopCount += 1, this.isBreakLoop(e2) && t2.postMessage("stop"));
          }, e2.worker = t2, t2.postMessage("start");
        }
        static timeout(e2) {
          let t2 = () => {
            if (e2.callback(), e2.loopCount += 1, !this.isBreakLoop(e2))
              return e2.timeoutID = setTimeout(t2, e2.delay);
          };
          return e2.timeoutID = setTimeout(t2, e2.delay);
        }
        static ric(e2) {
          let t2, i2 = zw(), r2 = () => {
            if (t2 = zw() - i2, t2 >= e2.delay && (i2 = zw() - Math.floor(t2 % e2.delay), e2.callback(), e2.loopCount += 1), !this.isBreakLoop(e2))
              return e2.ricID = EP(r2, { timeout: e2.delay });
          };
          return e2.ricID = EP(r2, { timeout: e2.delay });
        }
        static raf(e2) {
          e2.delay = (1e3 / e2.fps).toFixed(2);
          let t2, i2 = zw(), r2 = () => document.hidden && e2.backgroundTask ? (t2 = zw() - i2, i2 = zw(), e2.callback(), e2.loopCount += 1, this.isBreakLoop(e2) ? void 0 : e2.timeoutID = setTimeout(r2, e2.delay - Math.floor(t2 % e2.delay))) : (t2 = zw() - i2, t2 >= e2.delay && (i2 = zw() - Math.floor(t2 % e2.delay), e2.callback(), e2.loopCount += 1), this.isBreakLoop(e2) ? void 0 : e2.rafID = requestAnimationFrame(r2));
          if (e2.rafID = requestAnimationFrame(r2), e2.backgroundTask) {
            let t3 = () => {
              if (document.hidden) {
                let t4 = zw() - i2;
                t4 >= e2.delay ? r2() : e2.timeoutID = setTimeout(r2, e2.delay - t4);
              }
            };
            document.addEventListener("visibilitychange", t3), e2.onVisibilitychange = t3, document.hidden && t3();
          }
          return e2.taskID;
        }
        static hasTask(e2) {
          return this.taskMap.has(e2);
        }
        static clearTask(e2) {
          if (!this.taskMap.has(e2))
            return true;
          let { intervalID: t2, timeoutID: i2, rafID: r2, ricID: n2, onVisibilitychange: o2, worker: s2 } = this.taskMap.get(e2);
          return s2 && s2.terminate(), t2 && clearInterval(t2), i2 && clearTimeout(i2), r2 && IP(r2), n2 && SP(n2), o2 && document.removeEventListener("visibilitychange", o2), this.taskMap.delete(e2), true;
        }
        static isBreakLoop(e2) {
          return !this.taskMap.has(e2.taskID) || 0 !== e2.count && e2.loopCount >= e2.count && (this.clearTask(e2.taskID), true);
        }
      };
      vP.taskMap = /* @__PURE__ */ new Map(), vP.currentTaskID = 1;
      var yP = vP;
      ok.SEI_MESSAGE;
      var AP = { LOADED_DATA: ok.LOADEDDATA, MEDIA_TRACK_CHANGED: "media-track-changed", PLAYER_STATE_CHANGED: "player-state-changed" }, RP = {};
      rb(RP, { create: () => bP, remove: () => kP });
      var CP = /* @__PURE__ */ new WeakMap();
      function bP(e2, t2) {
        CP.has(e2) || CP.set(e2, []);
        let i2 = CP.get(e2), r2 = { add: (e3, n2) => ("addEventListener" in t2 ? (i2.push(t2.removeEventListener.bind(t2, e3, n2)), t2.addEventListener(e3, n2)) : (i2.push(t2.off.bind(t2, e3, n2)), t2.on(e3, n2)), r2) };
        return r2;
      }
      function kP(e2) {
        let t2 = CP.get(e2);
        t2 && (t2.forEach((e3) => e3()), CP.delete(e2));
      }
      var NP = class extends TP {
        constructor(e2, t2) {
          super(e2.id, "".concat(t2, "-player")), this.kind = t2, sb(this, "id"), sb(this, "element", null), sb(this, "track"), sb(this, "url"), sb(this, "attr"), sb(this, "muted"), sb(this, "_log"), sb(this, "_pausedRetryCount"), sb(this, "_isElementPlayingFired", false), sb(this, "_interval"), this.id = e2.id, this._log = e2.log, this.track = e2.track, this.muted = e2.muted, this._pausedRetryCount = Yk, this._state = "STOPPED", this.bindTrackEvents(), this._log.info("create ".concat(t2, "-player ").concat(this.id));
        }
        get isPlaying() {
          return "PLAYING" === this._state;
        }
        get isStopped() {
          return "STOPPED" === this._state;
        }
        setAttr(e2) {
          this.attr = e2;
        }
        setUrl(e2) {
          this.track && (this.unbindTrackEvents(), this.element && (this.element.srcObject = null), this.track = null), e2 !== this.url && (this.url = e2, null !== e2 && this.element && (this.element.crossOrigin = "anonymous", this.element.src = e2));
        }
        play() {
          return cb(this, null, function* () {
            if (!this.isPlaying)
              try {
                this.bindAutoPlayEvent(), yield this.element.play();
              } catch (wb2) {
                let t2 = XD({ key: uN.PLAY_FAILED, data: { media: this.kind, error: wb2 } });
                if (this.track && !this.track.muted && this._log.warn(wb2), t2.includes("NotAllowedError"))
                  throw new vb({ code: Sb.PLAY_NOT_ALLOWED, message: t2 });
              }
          });
        }
        stop() {
          this.unbindEvents(), this._isElementPlayingFired = false, this.element && (this.element.remove(), this.element.srcObject = null, this.element = null), this.handleStopped(ok.ENDED), this._interval > 0 && yP.clearTask(this._interval);
        }
        pause() {
          var e2;
          this.isPlaying && (null == (e2 = this.element) || e2.pause());
        }
        resume() {
          return this.isPlaying ? Promise.resolve() : xD ? this.replay() : this.play().catch(() => {
          });
        }
        setMuted(e2) {
          this.element && (this.element.muted = e2), this.muted = e2;
        }
        replay() {
          return this.stop(), this.play().catch(() => {
          });
        }
        bindElementEvents() {
          if (this.element) {
            let e2 = this.handleElementEvent.bind(this);
            return bP(this.element, this.element).add(ok.PLAYING, e2).add(ok.ENDED, e2).add(ok.PAUSE, e2).add(ok.ERROR, e2).add(ok.LOADEDDATA, e2);
          }
        }
        bindTrackEvents() {
          if (this.track) {
            let e2 = this.handleTrackEvent.bind(this);
            null == RP || RP.create(this.track, this.track).add(ok.ENDED, e2).add(ok.MUTE, e2).add(ok.UNMUTE, e2), this.track.readyState === ok.ENDED && this.handleTrackEvent({ type: ok.ENDED }), this.track.muted && this.handleTrackEvent({ type: ok.MUTE });
          }
        }
        bindAutoPlayEvent() {
          ew.on(gO.AUTOPLAY_DIALOG_CLICK_CONFIRM, this.resume, this);
        }
        unbindTrackEvents() {
          this.track && kP(this.track);
        }
        unbindEvents() {
          this.element && kP(this.element), this.unbindTrackEvents(), ew.off(gO.AUTOPLAY_DIALOG_CLICK_CONFIRM, this.resume, this);
        }
        handleElementEvent(e2) {
          switch (e2.type) {
            case ok.PLAYING:
              this._isElementPlayingFired = true, this._log.info("".concat(this.kind, " player is playing")), this.handlePlaying(ok.PLAYING), this._interval && (yP.clearTask(this._interval), this._interval = -1);
              break;
            case ok.ENDED:
              this._log.info("".concat(this.kind, " player is ended")), this.handleStopped(ok.ENDED);
              break;
            case ok.PAUSE:
              this._log.info("".concat(this.kind, " player is paused")), this.handlePaused(ok.PAUSE), AN && (this._interval = yP.run(sN, () => {
                this.element && "PAUSED" === this._state && this.resume();
              }, { delay: 3e3 }));
              break;
            case ok.ERROR:
              if (this.element && this.element.error) {
                let { code: e3, message: t2 } = this.element.error;
                this._log.error("".concat(this.kind, " player error observed. code: ").concat(e3, " message: ").concat(t2, " userAgent: ").concat(navigator.userAgent)), iw.uploadEvent({ log: "stat-".concat(this.kind, "-").concat(Pk.PLAYER_ERROR, "-").concat(e3, "-").concat(navigator.userAgent), error: this.element.error });
              }
              break;
            case ok.LOADEDDATA:
              this.kind === ok.VIDEO && this.emit(AP.LOADED_DATA);
          }
        }
        handleTrackEvent(e2) {
          switch (e2.type) {
            case ok.ENDED:
              this._log.info("".concat(this.kind, " track is ended")), this.handleStopped(ok.ENDED);
              break;
            case ok.MUTE:
              this._log.info("".concat(this.kind, " track is unable to provide media output")), this.handlePaused(ok.MUTE);
              break;
            case ok.UNMUTE:
              this._log.info("".concat(this.kind, " track is able to provide media output")), this._isElementPlayingFired && this.handlePlaying(ok.UNMUTE);
          }
        }
        handlePlaying(e2) {
          this.emit(AP.PLAYER_STATE_CHANGED, { type: this.kind, state: "PLAYING", reason: e2 });
        }
        handlePaused(e2) {
          this.emit(AP.PLAYER_STATE_CHANGED, { type: this.kind, state: "PAUSED", reason: e2 });
        }
        handleStopped(e2) {
          this.emit(AP.PLAYER_STATE_CHANGED, { type: this.kind, state: "STOPPED", reason: e2 });
        }
        getElement() {
          return this.element;
        }
      };
      ob([_P([], "PLAYING", { sync: true })], NP.prototype, "handlePlaying", 1), ob([_P("PLAYING", "PAUSED", { ignoreError: true, sync: true })], NP.prototype, "handlePaused", 1), ob([_P([], "STOPPED", { sync: true })], NP.prototype, "handleStopped", 1);
      var DP = "trtc_autoplay", wP = "".concat(DP, "_mask"), OP = "".concat(DP, "_wrapper"), PP = "".concat(DP, "_header"), MP = "".concat(DP, "_content"), LP = "".concat(DP, "_action_wrapper"), xP = "".concat(DP, "_question"), VP = "".concat(DP, "_collapse"), UP = "".concat(DP, "_action_confirm"), FP = "".concat(DP, "_detail"), BP = "#2473E8", HP = "dialog", jP = "".concat(HP, "-show"), GP = "".concat(HP, "-1"), WP = "".concat(HP, "-2"), JP = false, KP = () => !!document.querySelector(".".concat(OP)), zP = "".concat(Gb, "/").concat(kw() ? "zh-cn" : "en", "/tutorial-21-advanced-auto-play-policy.html"), qP = "<br><a href='".concat(zP, "' target='_blank'>").concat(kw() ? "å¶ä»æ¹æ¡ï¼" : "Any other solution?", "</a>"), YP = "".concat(kw() ? "æµè§å¨èªå¨æ­æ¾ç­ç¥ï¼å¨ç¨æ·ä¸é¡µé¢äº§çäº¤äºï¼ç¹å»ãè§¦æ¸ï¼ä¹åï¼æµè§å¨ç¦æ­¢æ­æ¾æå£°åªä½ãè¯¥å¼¹çªç¨äºå¸®å©ç¨æ·æ¢å¤é³è§é¢æ­æ¾ã".concat(qP) : "Autoplay Policy: Before user interacts with the web page (clicking, touching), page will not be allowed to play media with sound. This Dialog is used to help users resume playback. ".concat(qP)), QP = class {
        constructor() {
          if (sb(this, "content", "é³è§é¢æ­æ¾è¢«æµè§å¨æ¦æªï¼è¯·ç¹å»âæ¢å¤æ­æ¾âã"), sb(this, "_dialogNode", null), sb(this, "_bodyPosition", ""), sb(this, "_showDetail", false), sb(this, "_isCollapseClicked", false), sb(this, "_isQuestionClicked", false), kw() || (this.content = 'Media playback failed. Click the "Resume" to resume playback.'), !JP) {
            let e2 = document.createElement("style");
            e2.innerHTML = ".".concat(wP, "{position:fixed;top:0;left:0;right:0;bottom:0;width:100vw;height:100vh;display:flex;justify-content:center;align-items:center;background:rgba(0,0,0,0.5);z-index:1500;}.").concat(wP, " div:not(.").concat(LP, "){display:block !important;}.").concat(OP, "{padding:14px;background:#fff;border-radius:3px;box-shadow:0px 3px 15px #434343;border:1px solid #d1cfcf;max-width:500px;}.").concat(OP, " a{color:").concat(BP, ";}.").concat(PP, "{overflow:hidden;text-overflow:ellipsis;font-size:16px;font-weight:600;}.").concat(MP, "{margin:8px 0;}.").concat(LP, "{width:100%;display:flex !important;align-items:center;justify-content:right;float:right;}.").concat(VP, "{margin-right:auto;cursor:pointer}.").concat(xP, "{height:100%;line-height:16px;cursor:pointer;}.").concat(UP, "{margin-left:8px;color:#fff;background:").concat(BP, ";padding:4px 12px;outline:none;border:1px solid;border-radius:3px;font-weight:bold;}.").concat(UP, ":hover{opacity:0.9;}.").concat(VP, ",.").concat(UP, ",.").concat(MP, ",.").concat(xP, "{font-size:14px;}@media screen and (max-width:750px){.").concat(OP, "{width:80vw;}}"), document.head.appendChild(e2), JP = true;
          }
          this.addDiaLog();
        }
        createDiaLog() {
          let e2 = document.createElement("template");
          e2.innerHTML = '<div class="'.concat(wP, `"><div class='`).concat(OP, "'><div class='").concat(PP, "'>").concat(location.host, "</div><div class='").concat(MP, "'>").concat(this.content, "</div><div class='").concat(FP, `' style="visibility:hidden;width:100%;height:0;font-size:12px;color:gray;">`).concat(YP, "</div><div class='").concat(LP, "'></div></div></div>").trim();
          let t2 = document.createElement("button");
          t2.className = UP, t2.innerText = kw() ? "æ¢å¤æ­æ¾" : "Resume", t2.onclick = this.onConfirm.bind(this);
          let i2 = document.createElement("div");
          i2.className = xP, i2.innerHTML = '<?xml version="1.0" encoding="UTF-8"?>\n    <svg class="icon" width="18" height="18" p-id="2030" t="1639646523624" version="1.1" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">\n    <path d="m464 784.35c0 26.51 21.49 48 48 48s48-21.49 48-48-21.49-48-48-48-48 21.49-48 48z" p-id="2031"/>\n    <path d="m512 960c-247.04 0-448-200.96-448-448s200.96-448 448-448 448 200.96 448 448-200.96 448-448 448zm0-831.71c-211.58 0-383.71 172.13-383.71 383.71 0 211.55 172.13 383.71 383.71 383.71 211.55 0 383.71-172.16 383.71-383.71 0-211.58-172.16-383.71-383.71-383.71z" p-id="2032"/>\n    <path d="m512 673.7c-17.665 0-32.001-14.336-32.001-31.999v-54.112c0-52.353 40-92.352 75.328-127.65 25.887-25.92 52.672-52.672 52.672-74.017 0-53.343-43.072-96.735-95.999-96.735-53.823 0-95.999 41.536-95.999 94.559 0 17.665-14.336 31.999-32.001 31.999s-32.001-14.336-32.001-31.999c0-87.424 71.775-158.56 160-158.56s160 72.095 160 160.74c0 47.904-36.32 84.192-71.424 119.3-27.84 27.776-56.576 56.512-56.576 82.336v54.112c0 17.665-14.336 32.032-32.001 32.032z" p-id="2033"/>\n    </svg>\n    ', i2.onclick = this.onQuestionClick.bind(this);
          let r2 = document.createElement("div");
          r2.className = VP, r2.innerText = "".concat(kw() ? "è¯¦æ >" : "Detail >"), r2.onclick = this.onCollapseClick.bind(this);
          let n2 = e2.content.firstChild, o2 = n2.querySelector(".".concat(LP));
          return o2.appendChild(r2), o2.appendChild(i2), o2.appendChild(t2), n2;
        }
        addDiaLog() {
          KP() || (this._dialogNode = this.createDiaLog(), document.body.appendChild(this._dialogNode), this._dialogNode.onclick = this.onConfirm.bind(this), this._dialogNode.querySelector(".".concat(OP)).onclick = (e2) => e2.stopPropagation(), this._bodyPosition = document.body.style.position, document.body.style.position = "fixed", EO.info("show autoplay dialog"), iw.uploadEvent({ log: jP }));
        }
        deleteDiaLog() {
          this._dialogNode && (document.body.removeChild(this._dialogNode), document.body.style.position = this._bodyPosition, this._dialogNode = null);
        }
        onConfirm() {
          EO.warn("confirm clicked, try resume stream"), ew.emit(gO.AUTOPLAY_DIALOG_CLICK_CONFIRM), this.deleteDiaLog();
        }
        onCollapseClick() {
          let e2 = this._dialogNode.querySelector(".".concat(FP));
          e2.style.visibility = "".concat(this._showDetail ? "hidden" : "visible"), e2.style.height = "".concat(this._showDetail ? 0 : "fit-content"), this._showDetail = !this._showDetail, this._isCollapseClicked || iw.uploadEvent({ log: GP }), this._isCollapseClicked = true;
        }
        onQuestionClick() {
          window.open(zP, "_blank"), this._isQuestionClicked || iw.uploadEvent({ log: WP }), this._isQuestionClicked = true;
        }
      }, XP = class extends NP {
        constructor(e2) {
          super(e2, ok.VIDEO), sb(this, "viewMirror", false), sb(this, "objectFit"), sb(this, "container"), sb(this, "canvas"), this.container = e2.container, this.canvas = e2.canvas, Mw(e2.viewMirror) || (this.viewMirror = e2.viewMirror), Mw(e2.objectFit) || (this.objectFit = e2.objectFit), this.initializeElement();
        }
        initializeElement() {
          var e2;
          let t2 = document.createElement(ok.VIDEO);
          this.track && (t2.srcObject = new MediaStream([this.track])), t2.muted = true, t2.setAttribute("id", "video_".concat(this.id)), t2.setAttribute("style", this.styleAttribute), this.canvas && this.canvas.setAttribute("style", this.styleAttribute), t2.setAttribute("autoplay", "autoplay"), t2.setAttribute("playsinline", "playsinline"), this.element = t2, null == (e2 = this.container) || e2.appendChild(this.elementToRender), this.bindElementEvents();
        }
        get styleAttribute() {
          let e2 = "width: 100%; height: 100%; object-fit: ".concat(this.objectFit, ";background-color: black;");
          return this.viewMirror && (e2 += "transform: scaleX(-1);"), e2;
        }
        setContainer(e2) {
          var t2;
          this.container = e2, this.track && this.elementToRender && (null == (t2 = this.container) || t2.appendChild(this.elementToRender));
        }
        bindElementEvents() {
          let e2 = super.bindElementEvents();
          this.handleElementEvent = this.handleElementEvent.bind(this), e2 && e2.add(ok.ENTER_PICTURE_IN_PICTURE, this.handleElementEvent).add(ok.LEAVE_PICTURE_IN_PICTURE, this.handleElementEvent);
        }
        handleElementEvent(e2) {
          var t2;
          super.handleElementEvent(e2);
          let i2 = e2.type;
          if (i2 === ok.PAUSE && (this.container && document.getElementById(this.container.id) || this._log.warn("".concat(this.kind, " player has been remove, element ID: ").concat(null == (t2 = this.container) ? void 0 : t2.id)), this._pausedRetryCount > 0 && !KP() && (this._log.info("".concat(this.kind, " player auto resume when paused")), this.resume(), this._pausedRetryCount--)), this.viewMirror && this.element) {
            let e3 = this.element.style.transform;
            i2 === ok.ENTER_PICTURE_IN_PICTURE ? this.element.style.transform = e3.replace("scaleX(-1)", "") : i2 === ok.LEAVE_PICTURE_IN_PICTURE && !e3.includes("scaleX") && (this.element.style.transform = "".concat(e3, " scaleX(-1)"));
          }
        }
        setCanvas(e2) {
          var t2, i2;
          this.canvas !== e2 && (null == (t2 = this.canvas) || t2.remove(), null == e2 || e2.setAttribute("style", this.styleAttribute), this.canvas = e2, e2 && (null == (i2 = this.container) || i2.appendChild(e2)));
        }
        setAttr(e2) {
          let t2 = Object.assign({ autoplay: "autoplay", playsinline: "playsinline", muted: true }, e2);
          t2.style = Object.assign({ width: "100%", height: "100%" }, t2.style), super.setAttr(t2);
        }
        get mirror() {
          return this.viewMirror;
        }
        setRect(e2, t2) {
          this.elementToRender && (this.elementToRender.style.width = "".concat(e2, "px"), this.elementToRender.style.height = "".concat(t2, "px"));
        }
        setViewMirror(e2) {
          this.elementToRender && (this.elementToRender.style.transform = e2 ? "scaleX(-1)" : ""), this.viewMirror = e2;
        }
        setObjectFit(e2) {
          this.elementToRender && (this.elementToRender.style.objectFit = "".concat(e2)), this.objectFit = e2;
        }
        stop() {
          var e2;
          super.stop(), null == (e2 = this.canvas) || e2.remove();
        }
        play() {
          return this.element ? this.elementToRender && this.elementToRender.parentElement !== this.container && this.container && this.container.append(this.elementToRender) : this.initializeElement(), super.play();
        }
        get elementToRender() {
          return this.canvas || this.element;
        }
        setTrack(e2) {
          e2 !== this.track && (this.unbindTrackEvents(), this.track = e2, this.emit(AP.MEDIA_TRACK_CHANGED, e2), null !== e2 && (this.bindTrackEvents(), this.element && (this.element.srcObject = new MediaStream([e2]), this.element.remove()), this.elementToRender && this.elementToRender.parentElement !== this.container && this.container && this.container.append(this.elementToRender)));
        }
        getVideoFrame() {
          if (this.canvas)
            return this.canvas.toDataURL("image/png");
          if (!this.element)
            return "";
          let e2 = document.createElement("canvas");
          return e2.width = this.element.videoWidth, e2.height = this.element.videoHeight, e2.getContext("2d").drawImage(this.element, 0, 0), e2.toDataURL("image/png");
        }
        getElement() {
          return this.element;
        }
      };
      function $P(e2, t2) {
        return cb(this, null, function* () {
          if (!e2.audioWorklet)
            return Promise.reject("audioWorklet is not supported");
          try {
            yield e2.audioWorklet.addModule(t2), EO.info("worklet addModule success");
          } catch (wb2) {
            throw EO.info("worklet addModule catch error. ".concat(wb2.message)), wb2;
          }
        });
      }
      "undefined" != typeof window && (window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
      var ZP = new window.AudioContext({ sampleRate: 48e3 }), eM = () => {
        "suspended" === ZP.state ? (ZP.resume(), document.addEventListener("click", eM)) : "interrupted" === ZP.state ? ZP.resume() : document.removeEventListener("click", eM);
      };
      document.addEventListener("click", eM), ZP.onstatechange = () => {
        EO.info("context state: ".concat(ZP.state)), eM();
      };
      var tM, iM, rM, nM = (e2) => ZP, oM = class {
        constructor() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          this.countMap = /* @__PURE__ */ new Map(), this.distributionMap = /* @__PURE__ */ new Map(), this.log = EO.createLogger({ id: "kv" }), e2 && (ew.on("102", (e3) => {
            let { track: t2, cost: i2 } = e3;
            this.addSuccessEvent({ key: t2.kind === ok.AUDIO ? dM.START_MICROPHONE : uM.START_CAMERA, cost: i2 });
          }), ew.on("103", (e3) => {
            let { track: t2, error: i2 } = e3;
            this.addFailedEvent({ key: t2.kind === ok.AUDIO ? dM.START_MICROPHONE : uM.START_CAMERA, error: i2 });
          }));
        }
        getReportData() {
          let e2 = { msg_sdk_basic_info: { uint32_sdk_version: hO(this.version || Nb), uint32_terminal_type: 15, bytes_device_name: "", bytes_os_version: "", uint32_framework: 30, uint32_network_type: 0 }, stats_count: [...this.countMap.entries()].map((e3) => {
            let [t2, i2] = e3;
            return { uint32_key: t2, uint32_count: i2 };
          }), stats_distribution: [...this.distributionMap.entries()].map((e3) => {
            let [t2, i2] = e3;
            return { uint32_key: t2, distribution_items: [...i2.entries()].map((e4) => {
              let [t3, i3] = e4;
              return { uint32_item_key: t3, uint32_item_value: i3 };
            }) };
          }) };
          return this.countMap.clear(), this.distributionMap.clear(), e2;
        }
        clear() {
          this.countMap.clear(), this.distributionMap.clear();
        }
        isEnumKey(e2) {
          let t2 = +String(e2).slice(-3);
          return t2 >= 700 && t2 < 799;
        }
        isErrorCodeKey(e2) {
          let t2 = +String(e2).slice(-3);
          return t2 >= 600 && t2 < 699;
        }
        isCountKey(e2) {
          let t2 = +String(e2).slice(-3);
          return t2 >= 0 && t2 < 599;
        }
        isNumberKey(e2) {
          let t2 = +String(e2).slice(-3);
          return t2 >= 800 && t2 < 899;
        }
        addCount(e2) {
          let { key: t2, useUV: i2 = false } = e2;
          this.isCountKey(t2) ? i2 && this.countMap.has(t2) || this.countMap.set(t2, (this.countMap.get(t2) || 0) + 1) : this.log.debug("".concat(t2, " is not count key, last 3 number should be 0~599"));
        }
        addEnum(e2) {
          let { key: t2, value: i2, useUV: r2 = true } = e2;
          var n2;
          if (!this.isEnumKey(t2))
            return this.log.debug("".concat(t2, " is not enum key, last 3 number should be 700~799"));
          if (r2 && this.countMap.has(t2))
            return;
          this.countMap.set(t2, (this.countMap.get(t2) || 0) + 1);
          let o2 = (null == (n2 = this.distributionMap) ? void 0 : n2.get(t2)) || /* @__PURE__ */ new Map();
          o2.set(i2, (o2.get(i2) || 0) + 1), this.distributionMap.set(t2, o2);
        }
        addNumber(e2) {
          let { key: t2, value: i2, split: r2 = 100, useUV: n2 = false } = e2;
          var o2;
          if (!this.isNumberKey(t2))
            return this.log.debug("".concat(t2, " is not number key, last 3 number should be 800~899"));
          if (n2 && this.countMap.has(t2))
            return;
          this.countMap.set(t2, (this.countMap.get(t2) || 0) + 1);
          let s2 = (null == (o2 = this.distributionMap) ? void 0 : o2.get(t2)) || /* @__PURE__ */ new Map(), a2 = 0;
          if (xw(r2))
            a2 = Math.floor(i2 / r2);
          else
            for (let c2 = r2.length - 1; c2 > 0; c2--)
              if (i2 > r2[c2]) {
                a2 = c2;
                break;
              }
          s2.set(a2, (s2.get(a2) || 0) + 1), this.distributionMap.set(t2, s2);
        }
        addSuccessEvent(e2) {
          let { key: t2, cost: i2, timeKey: r2, split: n2 } = e2;
          if (t2 && (this.addEnum({ key: t2, value: 1, useUV: false }), i2)) {
            let e3 = +String(t2).slice(-3);
            e3 < 800 && e3 >= 700 ? this.addNumber({ key: r2 || t2 + 100, value: i2, split: n2 }) : r2 || this.log.debug("time stat ignored, ".concat(t2));
          }
        }
        addFailedEvent(e2) {
          let { key: t2, error: i2 } = e2;
          if (!t2)
            return;
          let r2 = Sb.UNKNOWN;
          xw(i2) ? r2 = i2 : (!Mw(i2.extraCode) || !Mw(i2.code)) && (r2 = i2.extraCode || i2.code), this.addEnum({ key: t2, value: 0, useUV: false }), this.addEnum({ key: t2, value: r2, useUV: false });
        }
      }, sM = ((iM = sM || {})[iM.enterRoom = 500700] = "enterRoom", iM[iM.exitRoom = 500701] = "exitRoom", iM[iM.switchRole = 500702] = "switchRole", iM[iM.destroy = 500703] = "destroy", iM[iM.startLocalAudio = 500704] = "startLocalAudio", iM[iM.updateLocalAudio = 500705] = "updateLocalAudio", iM[iM.stopLocalAudio = 500706] = "stopLocalAudio", iM[iM.startLocalVideo = 500707] = "startLocalVideo", iM[iM.updateLocalVideo = 500708] = "updateLocalVideo", iM[iM.stopLocalVideo = 500709] = "stopLocalVideo", iM[iM.startScreenShare = 500710] = "startScreenShare", iM[iM.updateScreenShare = 500711] = "updateScreenShare", iM[iM.stopScreenShare = 500712] = "stopScreenShare", iM[iM.startRemoteVideo = 500713] = "startRemoteVideo", iM[iM.updateRemoteVideo = 500714] = "updateRemoteVideo", iM[iM.stopRemoteVideo = 500715] = "stopRemoteVideo", iM[iM.muteRemoteAudio = 500716] = "muteRemoteAudio", iM[iM.setRemoteAudioVolume = 500717] = "setRemoteAudioVolume", iM), aM = ((tM = aM || {})[tM.AudioMixer = 550700] = "AudioMixer", tM[tM.AIDenoiser = 551700] = "AIDenoiser", tM[tM.VirtualBackground = 570700] = "VirtualBackground", tM[tM.Beauty = 571700] = "Beauty", tM[tM.Watermark = 572700] = "Watermark", tM), cM = ((e2) => (e2[e2.AudioMixer = 550701] = "AudioMixer", e2[e2.AIDenoiser = 551701] = "AIDenoiser", e2[e2.VirtualBackground = 570701] = "VirtualBackground", e2[e2.Beauty = 571701] = "Beauty", e2[e2.Watermark = 572701] = "Watermark", e2))(cM || {}), lM = ((e2) => (e2[e2.AudioMixer = 550702] = "AudioMixer", e2[e2.AIDenoiser = 551702] = "AIDenoiser", e2[e2.VirtualBackground = 570702] = "VirtualBackground", e2[e2.Beauty = 571702] = "Beauty", e2[e2.Watermark = 572702] = "Watermark", e2))(lM || {}), dM = ((e2) => (e2[e2.START_MICROPHONE = 501700] = "START_MICROPHONE", e2[e2.MICROPHONE_CAHNNELS = 501701] = "MICROPHONE_CAHNNELS", e2[e2.MICROPHONE_SAMPLERATE = 501702] = "MICROPHONE_SAMPLERATE", e2))(dM || {}), uM = ((rM = uM || {})[rM.START_CAMERA = 511700] = "START_CAMERA", rM), hM = new oM(true), pM = new oM(false), mM = hM, _M = class {
        constructor() {
          this.pre = /* @__PURE__ */ new Set(), this.next = /* @__PURE__ */ new Set(), this.connectedNodes = /* @__PURE__ */ new Set();
        }
        setContext(e2) {
          this.context = e2, this.node && e2.addMixWeight();
        }
        removeContext() {
          var e2;
          this.node && (null == (e2 = this.context) || e2.reduceMixWeight()), delete this.context;
        }
        setNode(e2) {
          var t2;
          if (!this.node)
            try {
              null == (t2 = this.context) || t2.addMixWeight(), this.node = e2, this.preNodeReconnect(), this.reconnect(), mM.addSuccessEvent({ key: 502701 });
            } catch (wk2) {
              EO.error(wk2), mM.addFailedEvent({ key: 502701, error: wk2 });
            }
        }
        deleteNode() {
          var e2;
          if (this.node)
            try {
              this._disconnect(), delete this.node, null == (e2 = this.context) || e2.reduceMixWeight(), this.preNodeReconnect(), mM.addSuccessEvent({ key: 502702 });
            } catch (wb2) {
              EO.error(wb2), mM.addFailedEvent({ key: 502702, error: wb2 });
            }
        }
        preNodeReconnect() {
          this.pre.forEach((e2) => {
            e2.node ? e2.reconnect() : e2.preNodeReconnect();
          });
        }
        connectNext(e2) {
          this.next.forEach((t2) => e2._connect(t2.node) || t2.connectNext(e2));
        }
        _connect(e2) {
          return !(!this.node || !e2) && (this.node.connect(e2), this.connectedNodes.add(e2), true);
        }
        _disconnect() {
          this.connectedNodes.forEach((e2) => {
            var t2;
            return null == (t2 = this.node) ? void 0 : t2.disconnect(e2);
          }), this.connectedNodes.clear();
        }
        reconnect() {
          this._disconnect(), this.connectNext(this);
        }
        pipeTo() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          return t2.forEach((e3) => {
            this.next.add(e3), e3.pre.add(this);
          }), this;
        }
      }, fM = class extends _M {
        constructor() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 256;
          super(), this.fftSize = e2, this.dataArray = new Uint8Array(0);
        }
        setNode(e2) {
          e2.fftSize = this.fftSize, this.dataArray = new Uint8Array(e2.frequencyBinCount), super.setNode(e2);
        }
        getByteTimeDomainData() {
          var e2;
          return null == (e2 = this.node) || e2.getByteTimeDomainData(this.dataArray), this.dataArray;
        }
        get level() {
          var e2;
          return null == (e2 = this.node) || e2.getByteTimeDomainData(this.dataArray), Math.max(...this.dataArray) / 128 - 1;
        }
        get timeDomainPathData() {
          let e2 = this.getByteTimeDomainData(), t2 = 0, i2 = 0, r2 = "M".concat(t2, ",").concat(i2);
          for (let n2 = 0; n2 < e2.length; n2++)
            i2 = e2[n2] / 128 * 100 / 2, r2 += "L".concat(t2, ",").concat(i2), t2 += 1;
          return r2;
        }
      }, gM = class {
        constructor() {
          this.source = new _M(), this.gain = new _M(), this.destination = new _M();
        }
        get volume() {
          var e2;
          return (null == (e2 = this.gain.node) ? void 0 : e2.gain.value) || 1;
        }
        setVolume(e2) {
          1 !== e2 ? (this.gain.node || this.gain.setNode(this.source.node.context.createGain()), this.gain.node.gain.value = e2) : this.gain.node && this.gain.deleteNode();
        }
        replaceSource(e2) {
          this.source.deleteNode(), this.source.setNode(function(e3) {
            let t2 = SM.get(e3);
            if (t2)
              return t2;
            let i2 = nM();
            if (e3 instanceof HTMLAudioElement)
              t2 = i2.createMediaElementSource(e3);
            else {
              if (!(e3 instanceof MediaStreamTrack))
                return e3;
              t2 = i2.createMediaStreamSource(new MediaStream([e3]));
            }
            return SM.set(e3, t2), t2;
          }(e2));
        }
        get track() {
          var e2;
          return null == (e2 = this.stream) ? void 0 : e2.getAudioTracks()[0];
        }
        get stream() {
          var e2;
          return null == (e2 = this.destination.node) ? void 0 : e2.stream;
        }
      }, TM = class extends gM {
        constructor(e2) {
          super(), this.context = e2, this.denoiser = new _M(), this.source.pipeTo(this.denoiser.pipeTo(this.gain.pipeTo(this.destination)));
        }
        connect() {
          this.context.inputs.has(this) || (this.destination.setNode(this.context.destination), this.source.setContext(this.context), this.denoiser.setContext(this.context), this.gain.setContext(this.context), this.context.inputs.add(this));
        }
        disconnect() {
          !this.context.inputs.has(this) || (this.destination.deleteNode(), this.source.removeContext(), this.denoiser.removeContext(), this.gain.removeContext(), this.context.inputs.delete(this));
        }
        remove() {
          this.gain.deleteNode(), this.denoiser.deleteNode(), this.source.deleteNode(), this.disconnect();
        }
        setVolume(e2) {
          1 !== e2 ? (this.gain.node || this.gain.setNode(this.context.audioContext.createGain()), this.gain.node.gain.value = e2) : this.gain.node && this.gain.deleteNode();
        }
      }, EM = class {
        constructor() {
          this.audioContext = nM(), this.destination = this.audioContext.createMediaStreamDestination(), this.inputs = /* @__PURE__ */ new Set(), this.mixWeight = 0, this.destination.channelCount = 1;
        }
        addMixWeight() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          this.mixWeight += e2, this.mixWeight - 1 == e2 + 1 >> 1 && this.mixOnChange();
        }
        reduceMixWeight() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
          this.addMixWeight(-e2);
        }
        close() {
          this.inputs.forEach((e2) => e2.remove());
        }
        get mixTrack() {
          return this.destination.stream.getAudioTracks()[0];
        }
      }, SM = /* @__PURE__ */ new WeakMap();
      var IM = class {
        constructor(e2) {
          sb(this, "_volume", 0), sb(this, "_log"), sb(this, "_scriptProcessorNode", null), sb(this, "_audioWorkletNode", null), sb(this, "_interval", 200), sb(this, "ready", this.preload());
          let { log: t2 } = e2;
          this._log = t2, ew.on(gO.AUDIO_LEVEL_INTERVAL, this.handleAudioLevelInterval, this);
        }
        get node() {
          return this._audioWorkletNode || this._scriptProcessorNode;
        }
        preload() {
          return IM.workletReady || (IM.workletReady = $P(IM.audioContext, URL.createObjectURL(new Blob(['class VolumeMeter extends AudioWorkletProcessor{constructor(){super(),this.volume=0,this.intervalTime=200,this.tick=this.intervalTime,this.isStop=!1,this.port.onmessage=t=>{let{data:e}=t;switch(e.name){case"setIntervalTime":this.intervalTime=e.intervalTime;break;case"stop":this.isStop=!0}}}process(t){let e=t[0];if(this.isStop)return!1;if(e.length>0){let i=e[0],s=0;for(let l=0;l<i.length;++l)s=Math.max(Math.abs(i[l]),s);this.volume=s,this.tick-=i.length,this.tick<0&&(this.tick+=this.intervalTime/1e3*sampleRate,this.port.postMessage({volume:this.volume}))}return!0}}registerProcessor("volume-meter",VolumeMeter);'], { type: "application/javascript" })))), IM.workletReady.then(() => this.initAudioWorklet()).catch(() => this.initScriptProcessor());
        }
        initAudioWorklet() {
          if (!this._audioWorkletNode)
            try {
              this._audioWorkletNode = new AudioWorkletNode(IM.audioContext, "volume-meter"), this._audioWorkletNode.port.onmessage = (e2) => {
                this._volume = e2.data.volume || 0;
              }, this.handleAudioLevelInterval({ interval: this._interval });
            } catch (rM2) {
              iw.logFailedEvent({ userId: this._log.userId, eventType: Pk.LOAD_WORKLET, error: rM2 }), this.initScriptProcessor();
            }
        }
        initScriptProcessor() {
          if (!this._scriptProcessorNode)
            try {
              this._scriptProcessorNode = nM().createScriptProcessor(2048, 1, 1), this._scriptProcessorNode.onaudioprocess = (e2) => {
                let t2 = e2.inputBuffer.getChannelData(0), i2 = 0;
                for (let r2 = 0; r2 < t2.length; ++r2)
                  i2 += t2[r2] * t2[r2];
                this._volume = Math.sqrt(i2 / t2.length) || 0;
              };
            } catch (rM2) {
              this._log.error("volumeMeter init script processor error: ".concat(rM2));
            }
        }
        destroy() {
          this._scriptProcessorNode && (this._scriptProcessorNode.onaudioprocess = null), this._audioWorkletNode && (this._audioWorkletNode.port.postMessage({ name: "stop" }), this._audioWorkletNode.port.onmessage = null), this._audioWorkletNode = null, this._scriptProcessorNode = null, ew.off(gO.AUDIO_LEVEL_INTERVAL, this.handleAudioLevelInterval, this);
        }
        getInternalAudioLevel() {
          return this._volume;
        }
        getCalculatedVolume() {
          return parseFloat(this._volume.toFixed(2));
        }
        handleAudioLevelInterval(e2) {
          var t2;
          let { interval: i2 } = e2;
          this._interval = i2, null == (t2 = this._audioWorkletNode) || t2.port.postMessage({ name: "setIntervalTime", intervalTime: i2 });
        }
      }, vM = IM;
      sb(vM, "audioContext", nM()), sb(vM, "workletReady");
      var yM = class extends _M {
        constructor(e2) {
          super(), sb(this, "_volumeMeter"), this._volumeMeter = new vM(e2);
        }
        deleteNode() {
          this._volumeMeter.destroy(), super.deleteNode();
        }
        init() {
          return cb(this, null, function* () {
            yield this._volumeMeter.preload(), this.setNode(this._volumeMeter.node);
          });
        }
        getCalculatedVolume() {
          return this._volumeMeter.getCalculatedVolume();
        }
        getInternalAudioLevel() {
          return this._volumeMeter.getInternalAudioLevel();
        }
      }, AM = nb(lb(), 1), RM = (e2) => (t2) => t2.deviceId === e2, CM = class {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Input";
          sb(this, "kind"), sb(this, "type"), sb(this, "devices", []), this.kind = e2, this.type = t2;
        }
        update(e2, t2) {
          let i2 = e2.filter((e3) => e3.kind === "".concat(this.kind).concat(this.type.toLocaleLowerCase()));
          1 === this.devices.length && NM(this.devices[0]) || t2 && (i2.forEach((e3) => {
            if (e3.deviceId && !this.devices.find(RM(e3.deviceId))) {
              let i3 = "".concat(this.kind).concat(this.type, "Added");
              EO.warn("".concat(i3, ": ").concat(JSON.stringify(e3))), t2.emit(i3, e3);
            }
          }), this.devices.forEach((e3) => {
            if (e3.deviceId && !i2.find(RM(e3.deviceId))) {
              let i3 = "".concat(this.kind).concat(this.type, "Removed");
              EO.warn("".concat(i3, ": ").concat(JSON.stringify(e3))), t2.emit(i3, e3);
            }
          })), this.devices = i2;
        }
        hasDevice(e2) {
          return !!this.devices.find((t2) => t2.deviceId === e2);
        }
      }, bM = class extends AM.EventEmitter {
        constructor() {
          super(), sb(this, "audioInputs", new CM(ok.AUDIO)), sb(this, "videoInputs", new CM(ok.VIDEO)), sb(this, "audioOutputs", new CM(ok.AUDIO, "Output")), this.init(), navigator.mediaDevices && (navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", () => this.update()), "ondevicechange" in navigator.mediaDevices || yP.run(oN, () => {
            this.update();
          }, { delay: 1e4 }));
        }
        init() {
          DM().then((e2) => {
            this.audioInputs.update(e2), this.videoInputs.update(e2), this.audioOutputs.update(e2);
          });
        }
        update() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return function* () {
              let i2 = yield DM(t2);
              return e2.audioInputs.update(i2, e2), e2.videoInputs.update(i2, e2), e2.audioOutputs.update(i2, e2), e2;
            }();
          });
        }
      }, kM = Lb || Mb ? null : new bM();
      function NM(e2) {
        return e2.deviceId === e2.groupId && "" === e2.groupId;
      }
      function DM() {
        return cb(this, arguments, function() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          return function* () {
            if (wO() || !NO())
              return [];
            let t2 = yield navigator.mediaDevices.enumerateDevices();
            if (0 !== e2) {
              let i2 = { audio: false, video: false };
              if (t2.forEach((e3) => {
                NM(e3) && (e3.kind === ok.AUDIO_INPUT ? i2.audio = true : e3.kind === ok.VIDEO_INPUT && (i2.video = true));
              }), 2 === e2 && (i2.audio = false), 1 === e2 && (i2.video = false), i2.audio || i2.video) {
                let e3;
                try {
                  e3 = yield navigator.mediaDevices.getUserMedia(i2);
                } catch (Ob2) {
                  EO.debug("capture before getDevices failed: ", Ob2);
                }
                t2 = yield navigator.mediaDevices.enumerateDevices(), null == e3 || e3.getTracks().forEach((e4) => e4.stop());
              }
            }
            return t2.map((e3, t3) => {
              let i2 = { kind: e3.kind, deviceId: e3.deviceId, groupId: e3.groupId, label: e3.label || "".concat(e3.kind, "_").concat(t3) };
              return e3.deviceId.length > 0 && LM.add("".concat(e3.deviceId, "_").concat(e3.kind)), e3.getCapabilities && (i2.getCapabilities = () => e3.getCapabilities()), i2;
            });
          }();
        });
      }
      function wM() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return kM.update(e2 ? 1 : 0).then((e3) => e3.audioInputs.devices);
      }
      function OM() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return kM.update(e2 ? 2 : 0).then((e3) => e3.videoInputs.devices);
      }
      var PM = false;
      function MM() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return cb(this, null, function* () {
          return kM.update(e2 ? 1 : 0).then((e3) => e3.audioOutputs.devices);
        });
      }
      var LM = /* @__PURE__ */ new Set();
      function xM(e2, t2) {
        return cb(this, null, function* () {
          let i2 = (yield wM()).find((e3) => e3.deviceId === Qk);
          return (null == i2 ? void 0 : i2.groupId) === e2 && i2.label === t2;
        });
      }
      var VM = class extends gM {
        constructor(e2) {
          super(), this.log = e2, sb(this, "volumeMeter"), sb(this, "analyser", new fM()), this.volumeMeter = new yM({ log: this.log });
        }
        destory() {
          this.gain.deleteNode(), this.volumeMeter.deleteNode(), this.analyser.deleteNode(), this.source.deleteNode(), this.destination.deleteNode();
        }
      }, UM = class extends NP {
        constructor(e2) {
          super(e2, ok.AUDIO), sb(this, "_outputDeviceId"), sb(this, "_volume", 1), sb(this, "_destination", nM().createMediaStreamDestination()), sb(this, "pipeline"), sb(this, "volumeMeterMode", "worklet"), this.pipeline = new VM(this._log);
        }
        getMediaStream() {
          return this.pipeline.stream || (this.track ? new MediaStream([this.track]) : null);
        }
        initializeElement() {
          if (("15.2" === PD || "15.3" === PD || "15.4" === PD) && this.muted)
            return void this._log.info("audioElement is muted.");
          let e2 = new Audio();
          e2.setAttribute("autoplay", "autoplay"), e2.srcObject = this.getMediaStream(), e2.muted = this.muted, this.element = e2, this.bindElementEvents();
        }
        play() {
          return cb(this, null, function* () {
            if (this.track)
              return this.pipeline.source.node || this.pipeline.replaceSource(this.track), this.element || this.initializeElement(), this._outputDeviceId && (yield this.setSinkId(this._outputDeviceId)), "worklet" === this.volumeMeterMode ? this.pipeline.volumeMeter.init() : "analyser" === this.volumeMeterMode && this.pipeline.analyser.setNode(nM().createAnalyser()), this.setVolume(this._volume), function() {
                cb(this, null, function* () {
                  try {
                    PM || (PM = true, EO.info("speakers:".concat((yield MM()).map((e2) => " ".concat(e2.deviceId.slice(0, 8), ": ").concat(e2.label)))));
                  } catch (pF2) {
                  }
                });
              }(), ab(UM.prototype, this, "play").call(this);
          });
        }
        stop() {
          this.pipeline.destory(), super.stop();
        }
        setSinkId(e2) {
          return cb(this, null, function* () {
            var t2, i2;
            this._outputDeviceId !== e2 && (this._outputDeviceId = e2), this.element && this.element.sinkId !== e2 && (yield null == (i2 = (t2 = this.element).setSinkId) ? void 0 : i2.call(t2, e2));
          });
        }
        get useDestination() {
          return !!this.pipeline.stream;
        }
        setLoop(e2) {
          !this.element || (this.element.loop = e2);
        }
        getAudioLevel() {
          return this.pipeline.volumeMeter.getCalculatedVolume();
        }
        getInternalAudioLevel() {
          return this.pipeline.volumeMeter.getInternalAudioLevel();
        }
      }, FM = class extends UM {
        constructor(e2) {
          super(e2), this.pipeline.source.pipeTo(this.pipeline.volumeMeter, this.pipeline.destination);
        }
        setTrack(e2) {
          this.track !== e2 && (this.unbindTrackEvents(), this.track = e2, this.emit(AP.MEDIA_TRACK_CHANGED, e2), e2 ? (this.bindTrackEvents(), this.pipeline.replaceSource(e2), !this.useDestination && this.element && (this.element.srcObject = new MediaStream([e2]))) : this.pipeline.source.deleteNode());
        }
        setSourceNode(e2) {
          !e2 || this.pipeline.source.node === e2 || (this.pipeline.replaceSource(e2), e2 instanceof MediaStreamAudioSourceNode ? this.pipeline.destination.setNode(this._destination) : this.pipeline.destination.deleteNode(), this.element && (this.element.srcObject = this.getMediaStream(), this.element.play().catch(() => {
          }), this.setVolume(this._volume)));
        }
        setVolume(e2) {
          this._volume = e2, this.element && (this.element.volume = e2);
        }
      }, BM = class extends UM {
        constructor(e2) {
          super(e2), sb(this, "_sourceElement"), this.pipeline.source.pipeTo(this.pipeline.gain.pipeTo(this.pipeline.volumeMeter, this.pipeline.destination));
        }
        setTrack(e2) {
          this.track !== e2 && (this.unbindTrackEvents(), this.track = e2, this.emit(AP.MEDIA_TRACK_CHANGED, e2), e2 ? (this.bindTrackEvents(), this._sourceElement ? this._sourceElement.srcObject = new MediaStream([e2]) : !this.useDestination && this.element && (this.element.srcObject = new MediaStream([e2])), this.pipeline.replaceSource(e2)) : this.pipeline.source.deleteNode());
        }
        setVolume(e2) {
          this._volume = e2, this.useDestination ? (this.pipeline.setVolume(e2), this._log.info("set pipeline volume: ".concat(e2))) : e2 <= 1 ? (this.element ? this._log.info("set element volume: ".concat(e2)) : this._log.info("set element volume: no element"), this.element && (this.element.volume = e2)) : (this._log.info("start set pipeline volume: ".concat(e2)), this.pipeline.setVolume(e2), this.element && !this._sourceElement && (this.pipeline.destination.setNode(this._destination), kP(this.element), this._sourceElement = this.element, this._sourceElement.muted = true, this.element = null, this.play()));
        }
        stop() {
          this.pipeline.destory(), this._sourceElement && (this._sourceElement.srcObject = null, delete this._sourceElement), super.stop();
        }
      }, HM = class extends TP {
        constructor(e2) {
          let { userId: t2, sdkAppId: i2, mediaType: r2, room: n2, PlayerClass: o2 = 1 === r2 ? BM : XP } = e2;
          var s2;
          super(), sb(this, "id", SO()), sb(this, "userId", ""), sb(this, "isRemote"), sb(this, "mediaType"), sb(this, "room"), sb(this, "user"), sb(this, "_log"), sb(this, "_inputTrack"), sb(this, "_outputTrack"), sb(this, "isPlayCalled"), sb(this, "container", null), sb(this, "player"), sb(this, "subVideoPlayerMap"), sb(this, "muted", false), sb(this, "abortCtrl"), sb(this, "objectFit", "cover"), sb(this, "mirror"), sb(this, "isScreen", false), sb(this, "manager"), sb(this, "trackSettings"), this.userId = t2 || "", this.mediaType = r2, this._log = EO.createLogger({ id: "".concat(this.kind[0], "t"), userId: null == (s2 = n2 || this.room) ? void 0 : s2.userId, remoteUserId: this instanceof sL ? void 0 : this.userId, sdkAppId: i2, type: 2 === this.mediaType ? "auxiliary" : "main", isLocal: this instanceof sL }), this.player = new o2({ id: this.userId || this.id, track: null, muted: false, container: null, log: this.log }), this.player.on(AP.PLAYER_STATE_CHANGED, (e3) => {
            ew.emit(gO.PLAYER_STATE_CHANGED, eb({ track: this }, e3)), this.emit("player-state-changed", e3);
          }), this.kind === ok.VIDEO && (this.player.on(AP.LOADED_DATA, () => {
            ew.emit(gO.VIDEO_LOADED_DATA, { track: this });
          }), this.player.on(AP.MEDIA_TRACK_CHANGED, (e3) => {
            var t3;
            null == (t3 = this.subVideoPlayerMap) || t3.forEach((t4) => t4.setTrack(e3));
          }));
        }
        get log() {
          return this._log || EO;
        }
        get kind() {
          return 1 === this.mediaType ? ok.AUDIO : ok.VIDEO;
        }
        get strMediaType() {
          return 4 === this.mediaType ? ok.VIDEO : 2 === this.mediaType ? ok.SCREEN : ok.AUDIO;
        }
        get streamType() {
          return 2 & this.mediaType ? "auxiliary" : "main";
        }
        play(e2, t2) {
          return cb(this, null, function* () {
            let i2 = Fw(e2) ? e2[0] : e2;
            if (this.isPlayCalled)
              return this.log.info("play update options: ".concat(JSON.stringify(t2))), t2 && !Mw(t2.muted) && this.setPlayerMute(t2.muted), t2 && !Mw(t2.objectFit) && (this.objectFit = t2.objectFit), void (this.player instanceof XP && (this.player.setObjectFit(this.objectFit), this.container !== i2 && i2 && (this.container = i2, this.player.setContainer(i2)), Fw(e2) && e2.length >= 1 && (yield this.playSubContainer(e2.slice(1), t2))));
            if (t2 && !Mw(t2.muted) ? this.setPlayerMute(t2.muted) : (!this.isRemote || this.kind === ok.VIDEO) && this.setPlayerMute(true), t2 && !Mw(t2.objectFit) && (this.objectFit = t2.objectFit), this.player instanceof XP && this.player.setObjectFit(this.objectFit), this.isPlayCalled = true, i2 && (this.container = i2, this.player instanceof XP && this.player.setContainer(i2)), ew.emit(gO.PLAY_TRACK_START, { track: this }), this._outputTrack) {
              this._log.info("play with options: ".concat(JSON.stringify(t2)));
              try {
                this.player.setTrack(this.playerMediaTrack), yield this.player.play(), Fw(e2) && e2.length > 1 && (yield this.playSubContainer(e2.slice(1), t2));
              } catch (tM2) {
                throw this.handleAutoPlayFailed(), this.emit("error", tM2), tM2;
              }
            } else
              this.log.info("play has not mediaTrack, abort");
          });
        }
        setMirror(e2, t2) {
          if (this.isScreen || this.kind !== ok.VIDEO || Mw(e2) || e2 === this.mirror)
            return;
          this.mirror = e2;
          let i2 = this.player;
          t2 && (i2 = t2);
          let r2 = this.manager;
          if (Vw(this.mirror))
            return i2.setViewMirror(this.mirror), void (r2 && (r2.mirror = false));
          switch (this.mirror) {
            case "view":
              r2 && (r2.mirror = false), i2.setViewMirror(true);
              break;
            case "publish":
              r2 && (r2.mirror = true), i2.setViewMirror(true);
              break;
            case "both":
              r2 && (r2.mirror = true), i2.setViewMirror(false);
          }
        }
        playSubContainer(e2, t2) {
          return cb(this, null, function* () {
            if (!this._outputTrack || this.kind === ok.AUDIO)
              return;
            this.subVideoPlayerMap || (this.subVideoPlayerMap = /* @__PURE__ */ new Map()), this.subVideoPlayerMap.forEach((t3, i3) => {
              var r2;
              e2.find((e3) => i3 === e3) || (t3.stop(), null == (r2 = this.subVideoPlayerMap) || r2.delete(i3));
            });
            for (let [r2, n2] of e2.entries()) {
              let e3 = this.subVideoPlayerMap.get(n2);
              e3 ? t2 && (Mw(t2.objectFit) || e3.setObjectFit(t2.objectFit)) : this.subVideoPlayerMap.set(n2, new XP({ id: this.userId || this.id, track: this.playerMediaTrack, container: n2, muted: this.player.muted, objectFit: this.objectFit, log: this.log.createChild({ id: "vp-sub".concat(r2 + 1) }) }));
            }
            let i2 = [...this.subVideoPlayerMap.values()];
            for (let e3 of i2)
              e3.setViewMirror(this.player.mirror), yield e3.play();
          });
        }
        setAudioOutput(e2) {
          return this.player.setSinkId(e2);
        }
        setAudioVolume(e2) {
          this.player.setVolume(e2);
        }
        getAudioLevel() {
          return this.player.getAudioLevel() || 0;
        }
        getInternalAudioLevel() {
          var e2;
          return (null == (e2 = this.player) ? void 0 : e2.getInternalAudioLevel()) || 0;
        }
        stop() {
          !this.isPlayCalled || (this.isPlayCalled = false, this.player && (this.log.info("stop ".concat(this.kind, " player")), this.player.stop()), this.subVideoPlayerMap && this.subVideoPlayerMap.size > 0 && this.subVideoPlayerMap.forEach((e2) => {
            e2.stop();
          }), this.container = null);
        }
        resume() {
          return cb(this, null, function* () {
            var e2;
            !this.isPlayCalled || (yield null == (e2 = this.player) ? void 0 : e2.resume());
          });
        }
        close() {
          this.log.info("close"), this.isPlayCalled && this.stop();
        }
        setMute(e2) {
          this.muted = e2, this._inputTrack && (this._inputTrack.enabled = !e2), this._outputTrack && (this._outputTrack.enabled = !e2), this.emit(e2 ? "mute" : "unmute", this), ew.emit(e2 ? gO.TRACK_MUTED : gO.TRACK_UNMUTED, { track: this });
        }
        setPlayerMute(e2) {
          this.player.setMuted(e2);
        }
        get mediaTrack() {
          return this._inputTrack || null;
        }
        get outMediaTrack() {
          return this._outputTrack || null;
        }
        get playerMediaTrack() {
          return this.outMediaTrack;
        }
        setInputMediaStreamTrack(e2) {
          var t2;
          let i2 = this._inputTrack;
          if (e2 !== i2)
            return this._inputTrack = e2, this.trackSettings = null == (t2 = e2.getSettings) ? void 0 : t2.call(e2), e2.enabled = !this.muted, this.emit("input-media-track-changed", e2 || null, i2 || null), this.manager ? this.manager.changeInput(this) : this.setOutputMediaStreamTrack(e2);
        }
        setOutputMediaStreamTrack(e2) {
          var t2;
          e2 !== this._outputTrack && (this.isRemote ? this.log.debug("setOutputMediaStreamTrack", e2.label) : this.log.info("setOutputMediaStreamTrack", null == (t2 = e2.getSettings) ? void 0 : t2.call(e2).deviceId, e2.label), this._outputTrack = e2, this.updatePlayingState(!!e2), this.emit("output-media-track-changed", e2));
        }
        setMediaType(e2) {
          this.mediaType = e2;
        }
        updatePlayingState(e2) {
          if (this.isPlayCalled) {
            if (e2) {
              if (this.player.setTrack(this.playerMediaTrack), this.player.isStopped)
                return this.player.play().catch(() => this.handleAutoPlayFailed()), void this.log.info("playing state updated, play ".concat(this.kind));
            } else if (!this.player.isStopped)
              return this.player.stop(), void this.log.info("playing state updated, stop ".concat(this.kind));
          }
          this.log.debug("updatePlayingState abort ".concat(this.isPlayCalled, " ").concat(e2, " ").concat(this.player.isStopped));
        }
        handleAutoPlayFailed() {
          if (this.room && this.room.enableAutoPlayDialog)
            new QP();
          else {
            let e2 = () => {
              this.resume().then(() => {
                document.removeEventListener("click", e2, true), document.removeEventListener("touchstart", e2, true);
              });
            };
            document.addEventListener("click", e2, true), document.addEventListener("touchstart", e2, true);
          }
        }
        getVideoFrame() {
          return this.player instanceof XP ? this.player.getVideoFrame() : "";
        }
      };
      ob([_P([], TP.INIT, { sync: true })], HM.prototype, "close", 1);
      var jM = Object.prototype.hasOwnProperty;
      var GM = function(e2) {
        if (null == e2)
          return true;
        if ("boolean" == typeof e2)
          return false;
        if ("number" == typeof e2)
          return 0 === e2;
        if ("string" == typeof e2 || "function" == typeof e2 || Array.isArray(e2))
          return 0 === e2.length;
        if (e2 instanceof Error)
          return "" === e2.message;
        if (Nw(e2))
          switch (Object.prototype.toString.call(e2)) {
            case "[object File]":
            case "[object Map]":
            case "[object Set]":
              return 0 === e2.size;
            case "[object Object]":
              for (let t2 in e2)
                if (jM.call(e2, t2))
                  return false;
              return true;
          }
        return false;
      }, WM = ZD({ retryFunction: function(e2) {
        return cb(this, null, function* () {
          let t2 = function(e3) {
            return { audio: KM(e3), video: zM(e3) };
          }(e2);
          EO.info("getUserMedia with constraints: ".concat(JSON.stringify(t2)));
          let i2 = [], r2 = [], n2 = ["label", "deviceId"];
          t2.audio && (i2 = yield wM(), EO.info("microphones: ".concat(aO(i2, { keysToInclude: n2 })))), t2.video && (r2 = yield OM(), EO.info("cameras: ".concat(aO(r2, { keysToInclude: n2 }))));
          try {
            let e3 = yield navigator.mediaDevices.getUserMedia(t2);
            return tP && e3.getTracks().forEach((e4) => {
              EO.info("".concat(e4.kind, " capabilities: ").concat(aO(e4.getCapabilities(), { keysToInclude: aN })));
            }), e3;
          } catch (tM2) {
            let { message: n3 } = tM2;
            throw "NotFoundError" === tM2.name && (e2.video && r2 && 0 === r2.length && (n3 = XD({ key: uN.CAMERA_NOT_FOUND })), e2.audio && i2 && 0 === i2.length && (n3 = XD({ key: uN.MICROPHONE_NOT_FOUND }))), new vb({ code: Sb.INITIALIZE_FAILED, name: tM2.name, message: n3, constraint: tM2.constraint });
          }
        });
      }, settings: { retries: 3, timeout: 500 }, onError: (e2) => {
        let { error: t2, retry: i2, reject: r2, retryFuncArgs: n2, retriedCount: o2 } = e2, s2 = o2 + 1;
        "NotReadableError" === t2.name || "OverconstrainedError" === t2.name ? (1 === s2 ? n2[0].video && (n2[0].maxResolution = false, n2[0].frameRate && (n2[0].frameRate = n2[0].frameRate > 10 ? 10 : 5)) : 2 === s2 ? n2[0].useDeviceIdOnly = true : 3 === s2 && !n2[0].useExactDeviceId && (n2[0].useTrueAsConstraint = true), i2()) : r2(t2), n2[0].microphoneId && JM(n2[0].microphoneId, false), n2[0].cameraId && JM(n2[0].cameraId, true);
      }, onRetrying: (e2) => {
        EO.warn("getUserMedia NotReadableError observed, retrying [".concat(e2, "/3]"));
      }, onRetryFailed: (e2) => {
        iw.logFailedEvent({ eventType: Pk.GET_USER_MEDIA_RETRY, error: e2 });
      }, onRetrySuccess: (e2) => {
        iw.logSuccessEvent({ eventType: Pk.GET_USER_MEDIA_RETRY }), iw.uploadEvent({ log: "stat-".concat(Pk.GET_USER_MEDIA_RETRY, "-success-").concat(e2) });
      } });
      function JM(e2, t2) {
        return cb(this, null, function* () {
          let i2 = (t2 ? yield OM() : yield wM()).find((t3) => t3.deviceId === e2);
          i2 && Pw(i2.getCapabilities) && EO.warn(aO(i2.getCapabilities(), { keysToInclude: aN }));
        });
      }
      function KM(e2) {
        if (!e2.audio)
          return false;
        if (e2.useTrueAsConstraint)
          return true;
        let t2 = { echoCancellation: true, noiseSuppression: true, autoGainControl: true, sampleRate: e2.sampleRate };
        return !GM(e2.microphoneId) && (t2.deviceId = e2.useExactDeviceId ? { exact: e2.microphoneId } : e2.microphoneId, e2.useDeviceIdOnly) ? t2 : (xw(e2.channelCount) && (t2.channelCount = e2.channelCount), Vw(e2.echoCancellation) && !e2.echoCancellation && (t2.echoCancellation = false), Vw(e2.noiseSuppression) && !e2.noiseSuppression && (t2.noiseSuppression = false), Vw(e2.autoGainControl) && !e2.autoGainControl && (t2.autoGainControl = false), !!GM(t2) || t2);
      }
      function zM(e2) {
        if (!e2.video)
          return false;
        if (e2.useTrueAsConstraint)
          return true;
        let { maxResolution: t2 = true } = e2, i2 = {};
        return e2.cameraId ? i2.deviceId = e2.useExactDeviceId ? { exact: e2.cameraId } : e2.cameraId : e2.facingMode && (i2.facingMode = e2.facingMode), e2.useDeviceIdOnly && !GM(i2) ? i2 : (e2.width && (i2.width = { ideal: e2.width }, t2 && !NN && (i2.width.max = e2.width)), e2.height && (i2.height = { ideal: e2.height }, t2 && !NN && (i2.height.max = e2.height)), NN && sD && e2.width && e2.height && e2.width * e2.height < 101376 && (i2.width = e2.width, i2.height = e2.height), e2.frameRate && (i2.frameRate = e2.frameRate), !!GM(i2) || i2);
      }
      var qM = WM;
      function YM(e2) {
        return XM((t2, i2) => function() {
          for (var i3 = arguments.length, r2 = new Array(i3), n2 = 0; n2 < i3; n2++)
            r2[n2] = arguments[n2];
          return cb(this, null, function* () {
            return yield e2.apply(this, r2), t2.apply(this, r2);
          });
        });
      }
      function QM(e2) {
        return XM((t2, i2) => function() {
          for (var i3 = arguments.length, r2 = new Array(i3), n2 = 0; n2 < i3; n2++)
            r2[n2] = arguments[n2];
          return cb(this, null, function* () {
            return e2.call(this, t2.apply(this, r2));
          });
        });
      }
      function XM(e2) {
        return function(t2, i2, r2) {
          return r2.value = e2(r2.value, i2), r2;
        };
      }
      var $M = (() => {
        let e2 = false, t2 = document.visibilityState;
        return () => {
          document.visibilityState !== t2 && EO.info("visibility change: ".concat(document.visibilityState)), !e2 && (document.addEventListener("visibilitychange", () => {
            EO.info("visibility change: ".concat(document.visibilityState)), t2 = document.visibilityState;
          }), e2 = true);
        };
      })(), ZM = 0, eL = class {
        constructor() {
          this.log = EO.createLogger({ id: "fq".concat(++ZM) }), this.isRunning = false, this.queue = [];
        }
        get length() {
          return this.queue.length;
        }
        get lastQueueItem() {
          return 0 === this.length ? null : this.queue[this.length - 1];
        }
        push(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          var i2, r2;
          let n2 = eb({}, e2), o2 = new Promise((e3, t3) => {
            n2.resolve = e3, n2.reject = t3;
          });
          return n2.promise = o2, t2 ? this.length <= 1 ? this.queue.push(n2) : null == (r2 = null == (i2 = this.lastQueueItem) ? void 0 : i2.promise) || r2.then(n2.resolve, n2.reject) : this.queue.push(n2), this.log.debug("push ".concat(this.length)), this.isRunning || this.callNext(), o2;
        }
        shift() {
          let e2 = this.queue.shift();
          return this.log.debug("shift ".concat(this.length)), e2;
        }
        callNext() {
          if (this.isRunning || 0 === this.length)
            return;
          this.log.debug("callNext ", this.length);
          let { fn: e2, args: t2, context: i2, resolve: r2, reject: n2 } = this.queue[0];
          this.isRunning = true, e2.apply(i2, t2).then(r2, n2).finally(() => {
            this.isRunning = false, this.shift(), this.callNext();
          });
        }
      }, tL = /* @__PURE__ */ new WeakMap(), iL = /* @__PURE__ */ new WeakMap();
      function rL() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return function(t2, i2, r2) {
          let n2 = r2.value;
          return r2.value = function() {
            let t3 = tL.get(this) || new eL();
            for (var i3 = arguments.length, r3 = new Array(i3), o2 = 0; o2 < i3; o2++)
              r3[o2] = arguments[o2];
            return tL.set(this, t3), t3.push({ fn: n2, args: r3, context: this }, e2);
          }, r2;
        };
      }
      function nL(e2) {
        return function(t2, i2, r2) {
          let n2 = r2.value;
          return r2.value = function() {
            var t3, i3, r3;
            let o2 = [];
            for (var s2 = arguments.length, a2 = new Array(s2), c2 = 0; c2 < s2; c2++)
              a2[c2] = arguments[c2];
            return null == (i3 = null == (t3 = tL.get(this)) ? void 0 : t3.queue) || i3.forEach((e3) => o2.push(e3)), null == (r3 = iL.get(this)) || r3.forEach((e3) => null == e3 ? void 0 : e3.queue.forEach((e4) => o2.push(e4))), o2.forEach((t4) => {
              t4.reject(new vb({ code: Sb.API_CALL_ABORTED, message: e2 }));
            }), tL.delete(this), iL.delete(this), n2.apply(this, a2);
          }, r2;
        };
      }
      function oL(e2) {
        return function(t2, i2, r2) {
          let n2 = r2.value, o2 = (t3) => e2(...t3);
          return r2.value = function() {
            for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
              t3[i3] = arguments[i3];
            let r3 = iL.get(this) || /* @__PURE__ */ new Map(), s2 = r3.get(o2(t3)) || new eL();
            return r3.set(o2(t3), s2), iL.set(this, r3), s2.push({ fn: n2, args: t3, context: this });
          }, r2;
        };
      }
      var sL = class extends HM {
        constructor(e2, t2) {
          super({ mediaType: e2, PlayerClass: t2 }), sb(this, "isRemote", false), sb(this, "deviceId"), sb(this, "groupId", ""), sb(this, "label", ""), sb(this, "_isRecapturing", false), sb(this, "_lastRecaptureTime", 0), sb(this, "_onMuteTimeoutId", -1), sb(this, "profile"), this.onTrackMuted = this.onTrackMuted.bind(this), this.onTrackUnmuted = this.onTrackUnmuted.bind(this), this.onTrackEnded = this.onTrackEnded.bind(this);
        }
        get isPublished() {
          return "publish" === this.state;
        }
        installTrackEvent(e2) {
          bP(e2, e2).add(ok.MUTE, this.onTrackMuted).add(ok.UNMUTE, this.onTrackUnmuted).add(ok.ENDED, this.onTrackEnded), e2.muted && this.onTrackMuted(), e2.readyState === ok.ENDED && this.onTrackEnded();
        }
        uninstallTrackEvent(e2) {
          kP(e2);
        }
        setStateToCapture() {
        }
        capture(e2) {
          return cb(this, null, function* () {
            var t2;
            try {
              let i2, r2 = zw();
              ew.emit(gO.LOCAL_TRACK_CAPTURE_START, { track: this }), e2.customSource ? (i2 = new MediaStream(), i2.addTrack(e2.customSource)) : (null == (t2 = this.mediaTrack) || t2.stop(), i2 = yield qM(e2));
              let n2 = i2.getTracks()[0];
              return yield this.setInputMediaStreamTrack(n2), e2.customSource || (this.updateDeviceIdInUse(), this.listenDeviceChange()), ew.emit(gO.LOCAL_TRACK_CAPTURE_SUCCESS, { track: this, cost: zw() - r2 }), i2;
            } catch (Ob2) {
              throw ew.emit(gO.LOCAL_TRACK_CAPTURE_FAILED, { track: this, error: Ob2 }), this.log.error("getUserMedia error observed ".concat(Ob2)), Ob2;
            }
          });
        }
        setInputMediaStreamTrack(e2) {
          this.state === TP.INIT && this.setStateToCapture(), this._inputTrack && this.uninstallTrackEvent(this._inputTrack);
          let t2 = super.setInputMediaStreamTrack(e2);
          return this.installTrackEvent(e2), t2;
        }
        setOutputMediaStreamTrack(e2) {
          var t2;
          return super.setOutputMediaStreamTrack(e2), null == (t2 = this.room) ? void 0 : t2.replaceTrack(this);
        }
        publish(e2, t2) {
          return this.room = e2, this.emit("4", { mediaType: this.strMediaType, state: "starting", prevState: "stopped" }), this.userId = e2.userId, this._log.setUserId(e2.userId), this._log.setSdkAppId(e2.sdkAppId), t2;
        }
        unpublish() {
          this.room && this.room.localTracks.delete(this), ew.emit(gO.LOCAL_TRACK_UNPUBLISHED, { track: this });
        }
        updateDeviceIdInUse() {
          return cb(this, null, function* () {
            if (this.mediaTrack && eP) {
              let { deviceId: e2, groupId: t2 } = this.mediaTrack.getSettings(), { label: i2 } = this.mediaTrack;
              (yield function(e3) {
                return cb(this, arguments, function(e4) {
                  let { newDeviceId: t3, oldDeviceId: i3, oldGroupId: r2, oldLabel: n2, kind: o2 } = e4;
                  return function* () {
                    return t3 === i3 && (o2 !== ok.AUDIO || t3 !== Qk || (yield xM(r2, n2)));
                  }();
                });
              }({ newDeviceId: e2, oldDeviceId: this.deviceId, oldGroupId: this.groupId, oldLabel: this.label, kind: this.kind })) || (this.deviceId = e2, this.label = i2, t2 && (this.groupId = t2), DM().then((t3) => {
                let i3 = t3.find((t4) => t4.deviceId === e2);
                i3 && this.emit("2", i3);
              }));
            }
          });
        }
        setProfile(e2) {
          this.log.info("setProfile", e2), Object.assign(this.profile, e2);
        }
        isNeedToRecapture() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return !(!this.deviceId || !this.mediaTrack || this.kind === ok.AUDIO && !function(e3) {
            if (e3 instanceof CanvasCaptureMediaStreamTrack || !(e3 instanceof MediaStreamTrack))
              return false;
            let t2 = e3.label.toLocaleLowerCase();
            if (t2.includes("mic") || t2.includes("éº¦åé£"))
              return true;
            let i2 = "".concat(((null == e3 ? void 0 : e3.getSettings()) || {}).deviceId, "_").concat(ok.AUDIO_INPUT);
            return !!LM.has(i2);
          }(this.mediaTrack) || this.kind === ok.VIDEO && !function(e3) {
            if (e3 instanceof CanvasCaptureMediaStreamTrack || !(e3 instanceof MediaStreamTrack))
              return false;
            let t2 = e3.label.toLocaleLowerCase();
            if (t2.includes("camera") || t2.includes("webcam"))
              return true;
            let i2 = "".concat(((null == e3 ? void 0 : e3.getSettings()) || {}).deviceId, "_").concat(ok.VIDEO_INPUT);
            return !!LM.has(i2);
          }(this.mediaTrack) || this._isRecapturing || e2 && sD && ND);
        }
        onTrackMuted() {
          if ($M(), this.isNeedToRecapture(true)) {
            if (Date.now() - this._lastRecaptureTime < iN)
              return void setTimeout(() => this.onTrackMuted(), iN);
            this._onMuteTimeoutId = setTimeout(() => cb(this, null, function* () {
              var e2;
              if (null != (e2 = this.mediaTrack) && e2.muted) {
                if ((AN || RN) && "visible" !== document.visibilityState)
                  return;
                this.recapture(yield this.getRecoverCaptureDeviceId());
              }
            }), 5e3);
          }
        }
        onTrackUnmuted() {
          this._onMuteTimeoutId > 0 && clearTimeout(this._onMuteTimeoutId);
        }
        onTrackEnded() {
          return cb(this, null, function* () {
            if (this.isNeedToRecapture()) {
              if (Date.now() - this._lastRecaptureTime < iN)
                return void setTimeout(() => this.onTrackEnded(), iN);
              this.recapture(yield this.getRecoverCaptureDeviceId());
            }
          });
        }
        recapture(e2) {
          return cb(this, null, function* () {
            var t2;
            if (this._isRecapturing || !this._inputTrack)
              return;
            this.log.warn("recapture trying"), null == (t2 = this._inputTrack) || t2.stop(), this._isRecapturing = true, this._lastRecaptureTime = Date.now();
            let i2 = { useExactDeviceId: true };
            if ("user" === e2 || "environment" === e2)
              i2.facingMode = e2;
            else {
              let t3;
              ("audio" === this.kind ? yield wM() : yield OM()).find((t4) => t4.deviceId === e2) && (t3 = e2), i2.deviceId = t3;
            }
            return this.capture(i2).then(() => {
              this._isRecapturing = false, this.log.warn("recapture success"), this.emit("1", { deviceId: this.deviceId });
            }).catch((e3) => {
              this._isRecapturing = false, this.log.warn("recapture failed ".concat(e3.message)), this.emit("5", e3);
            });
          });
        }
        getRecoverCaptureDeviceId() {
          return cb(this, null, function* () {
            let e2 = this instanceof lL;
            if (e2 && this.facingMode)
              return this.facingMode;
            let { deviceId: t2 } = this;
            if (t2) {
              let i2 = (aL.get(t2) || 0) + 1;
              if (aL.set(t2, i2), i2 >= 3) {
                let r2 = e2 ? (yield OM()).find((e3) => !aL.has(e3.deviceId)) : (yield wM()).find((e3) => !aL.has(e3.deviceId));
                r2 && (this.log.warn("".concat(t2, " capture fail ").concat(i2, " times, change new ").concat(r2.deviceId)), t2 = r2.deviceId);
              }
            }
            return t2;
          });
        }
        close() {
          var e2;
          super.close(), this._inputTrack && (this._inputTrack.stop(), this.uninstallTrackEvent(this._inputTrack)), null == (e2 = this.manager) || e2.removeInput(this);
        }
      };
      ob([_P(TP.INIT, "capture", { ignoreError: true, sync: true })], sL.prototype, "setStateToCapture", 1), ob([rL()], sL.prototype, "capture", 1), ob([_P("capture", "publish", { ignoreError: true, success() {
        this.room.localTracks.add(this), ew.emit(gO.LOCAL_TRACK_PUBLISHED, { track: this }), this.emit("4", { mediaType: this.strMediaType, state: "started", prevState: "starting" });
      }, fail(e2) {
        let t2 = "error", i2 = e2.cause;
        i2.message.includes("timeout") ? t2 = "timeout" : i2.code === Sb.API_CALL_ABORTED && (t2 = "api-call"), this.emit("4", { mediaType: this.strMediaType, state: "stopped", prevState: "starting", reason: t2, error: i2 });
      } })], sL.prototype, "publish", 1), ob([XM((e2) => function() {
        return cb(this, null, function* () {
          let t2 = "publish" === this.state ? "started" : "starting";
          e2.call(this), this.emit("4", { mediaType: this.strMediaType, state: "stopped", prevState: t2, reason: "api-call" });
        });
      }), _P([], "capture", { sync: true })], sL.prototype, "unpublish", 1);
      var aL = /* @__PURE__ */ new Map();
      ew.on(gO.SWITCH_DEVICE_SUCCESS, (e2) => {
        e2.track.deviceId && aL.delete(e2.track.deviceId);
      });
      var cL = class extends sL {
        constructor(e2) {
          super(1, FM), sb(this, "mediaType", 1), sb(this, "volume", 0), sb(this, "profile", { echoCancellation: true, autoGainControl: true, noiseSuppression: true, sampleRate: 48e3, channelCount: 1, bitrate: 40 }), sb(this, "playerMuted", true), sb(this, "pipeline"), this.manager = e2, this.pipeline = new TM(e2), this.handleMicrophoneAdded = this.handleMicrophoneAdded.bind(this), this.handleMicrophoneRemoved = this.handleMicrophoneRemoved.bind(this);
        }
        getAudioLevel() {
          let e2 = (this.volume || super.getAudioLevel()) * this.captureVolume;
          return e2 > 1 ? 1 : e2;
        }
        get playerMediaTrack() {
          return this.mediaTrack;
        }
        setInputMediaStreamTrack(e2) {
          return cb(this, null, function* () {
            yield ab(cL.prototype, this, "setInputMediaStreamTrack").call(this, e2);
            let t2 = this.trackSettings || {};
            mM.addEnum({ key: 501701, value: t2.channelCount || 0, useUV: false }), mM.addEnum({ key: 501702, value: t2.sampleRate || 0, useUV: false }), mM.addEnum({ key: 502700, value: 0 });
            let { sampleRate: i2, channelCount: r2 } = t2;
            this._log.info("local audio track input ".concat(JSON.stringify({ sampleRate: i2, channelCount: r2 }))), this.pipeline.replaceSource(e2), this.updatePlayingState(!!e2);
          });
        }
        capture(e2) {
          let { deviceId: t2, customSource: i2, useExactDeviceId: r2 = false } = e2;
          return super.capture({ video: false, audio: true, microphoneId: t2, echoCancellation: this.profile.echoCancellation, autoGainControl: this.profile.autoGainControl, noiseSuppression: this.profile.noiseSuppression, sampleRate: this.profile.sampleRate, channelCount: this.profile.channelCount, useExactDeviceId: r2, customSource: i2 });
        }
        switchDevice(e2) {
          return cb(this, null, function* () {
            if (this.mediaTrack) {
              if (this.deviceId === e2) {
                if (e2 !== Qk)
                  return;
                if (yield xM(this.groupId, this.label))
                  return;
              }
              try {
                this.log.info("switchDevice audio to: ".concat(e2)), this.mediaTrack && this.mediaTrack.stop(), yield this.capture({ deviceId: e2, useExactDeviceId: true }), this.room && (yield this.room.replaceTrack(this)), ew.emit(gO.SWITCH_DEVICE_SUCCESS, { track: this }), this.log.info("switch microphone success");
              } catch (wk2) {
                throw this.log.error("switch microphone failed ".concat(wk2)), this.deviceId && this.recapture(this.deviceId), wk2;
              }
            }
          });
        }
        listenDeviceChange() {
          kM && !kM.listeners("audioInputRemoved").includes(this.handleMicrophoneRemoved) && kM.on("audioInputRemoved", this.handleMicrophoneRemoved, this);
        }
        handleMicrophoneRemoved(e2) {
          return cb(this, null, function* () {
            if (e2.deviceId === this.deviceId) {
              this.log.warn("current microphone is lost: ".concat(JSON.stringify(e2)));
              let t2 = yield wM();
              t2[0] ? this.recapture(t2[0].deviceId) : kM.on("audioInputAdded", this.handleMicrophoneAdded, this);
            }
          });
        }
        handleMicrophoneAdded(e2) {
          this.log.warn("microphone added: ".concat(JSON.stringify(e2))), this.recapture(e2.deviceId);
        }
        update3A(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { echoCancellation: i2, noiseSuppression: r2, autoGainControl: n2 } = e3;
            return function* () {
              let e4 = false;
              !Mw(i2) && i2 !== t2.profile.echoCancellation && (t2.profile.echoCancellation = i2, e4 = true), !Mw(r2) && r2 !== t2.profile.noiseSuppression && (t2.profile.noiseSuppression = r2, e4 = true), !Mw(n2) && n2 !== t2.profile.autoGainControl && (t2.profile.autoGainControl = n2, e4 = true), e4 && t2.deviceId && (yield t2.recapture(t2.deviceId));
            }();
          });
        }
        get captureVolume() {
          return this.pipeline.volume;
        }
        setCaptureVolume(e2) {
          this.pipeline.setVolume(e2 / 100), this.pipeline.gain.node && mM.addEnum({ key: 502700, value: 2 }), this.resetPlayerSource();
        }
        enableTrackANS(e2) {
          if (!this._inputTrack)
            return;
          let t2 = this._inputTrack.getConstraints();
          return t2.noiseSuppression = e2, this._inputTrack.applyConstraints(t2).catch((t3) => this._log.warn("".concat(e2 ? "enable" : "disable", " ANS failed "), t3));
        }
        addDenoiser(e2) {
          var t2;
          bD <= 92 && 48e3 !== (null == (t2 = this.trackSettings) ? void 0 : t2.sampleRate) ? this._log.warn("denoiser only support sampleRate 48000 before chrome 93") : (mM.addEnum({ key: 502700, value: 1 }), this.pipeline.denoiser.setNode(e2), this.resetPlayerSource(), this.enableTrackANS(false));
        }
        removeDenoiser(e2) {
          this.pipeline.denoiser.node === e2 && (this.pipeline.denoiser.deleteNode(), this.resetPlayerSource(), this.enableTrackANS(true));
        }
        resetPlayerSource() {
          this.player.setSourceNode(this.pipeline.gain.node || this.pipeline.denoiser.node || this.pipeline.source.node);
        }
        close() {
          this.pipeline.remove(), kM.off("audioInputAdded", this.handleMicrophoneAdded, this), kM.off("audioInputRemoved", this.handleMicrophoneRemoved, this), super.close();
        }
        recapture(e2) {
          return cb(this, null, function* () {
            try {
              yield ab(cL.prototype, this, "recapture").call(this, e2);
            } catch (wk2) {
              let i2 = (yield wM()).find((t2) => t2.deviceId !== e2);
              if (!i2)
                throw wk2;
              yield ab(cL.prototype, this, "recapture").call(this, i2.deviceId);
            }
          });
        }
      }, lL = class extends sL {
        constructor(e2) {
          super(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4, XP), sb(this, "profile", { width: 640, height: 480, frameRate: 15, bitrate: 500 }), sb(this, "states", { bytesSent: 0, packetsSent: 0, framesEncoded: 0, framesSent: 0, frameWidth: 0, frameHeight: 0 }), sb(this, "small"), sb(this, "isNeedToSetBandwidth"), sb(this, "muteImage"), sb(this, "manager"), this.manager = e2;
          let t2 = () => {
            this.isAllowed2k4k(this.profile) ? this.room && this.settings.height >= 1440 && "publish" === this.state && this.room.sendAbilityStatus({ "2k4k": 1 }) : (this.log.warn("Resolution is reset to 1080p, need to upgrade ability here https://cloud.tencent.com/document/product/647/85386"), this.setProfile(tb(eb({}, this.profile), { width: 1920, height: 1080 })), this.applyProfile());
          };
          this.on("input-media-track-changed", t2), this.on("publish", t2), this.handleCameraAdded = this.handleCameraAdded.bind(this), this.handleCameraRemoved = this.handleCameraRemoved.bind(this);
        }
        get facingMode() {
          if (eP && this.mediaTrack)
            return this.mediaTrack.getSettings().facingMode;
        }
        setMute(e2) {
          return cb(this, null, function* () {
            var t2, i2, r2;
            if (Lw(e2)) {
              if (this.muteImage === e2)
                return;
              yield null == (t2 = this.manager) ? void 0 : t2.deleteWatermark("mute"), yield null == (i2 = this.manager) ? void 0 : i2.setWatermark({ x: 0, y: 0, width: this.settings.width, height: this.settings.height, type: "mute", zIndex: 999, imageUrl: e2 }), this.muteImage = e2, ab(lL.prototype, this, "setMute").call(this, false);
            } else
              yield null == (r2 = this.manager) ? void 0 : r2.deleteWatermark("mute"), this.muteImage = void 0, ab(lL.prototype, this, "setMute").call(this, e2);
          });
        }
        capture(e2) {
          let { deviceId: t2, facingMode: i2, useExactDeviceId: r2 = false, customSource: n2 } = e2;
          return super.capture({ audio: false, video: true, facingMode: i2 || this.facingMode, cameraId: t2, width: this.profile.width, height: this.profile.height, frameRate: this.profile.frameRate, useExactDeviceId: r2, customSource: n2 });
        }
        setProfile(e2) {
          let t2 = eb({}, e2), i2 = t2.width > t2.height;
          t2.width * t2.height <= 19200 && RN && AD && (this.log.warn("resolution is ".concat(t2.width, "*").concat(t2.height, ", fallback to 240*180")), t2.width = i2 ? 240 : 180, t2.height = i2 ? 180 : 240, t2.bitrate = Math.max(t2.bitrate, 150)), t2.width * t2.height > 921600 && VD && (t2.width = i2 ? 1280 : 720, t2.height = i2 ? 720 : 1280, this.log.warn("reset to 1280 * 720 on iOS 13~14")), t2.bitrate && (this.isNeedToSetBandwidth = t2.bitrate !== this.profile.bitrate), this.isAllowed2k4k(this.profile) ? super.setProfile(t2) : (this.log.warn("Resolution is reset to 1080p, need to upgrade ability here https://cloud.tencent.com/document/product/647/85386"), super.setProfile(tb(eb({}, this.profile), { width: 1920, height: 1080 })));
        }
        applyProfile() {
          var e2;
          if (!this.mediaTrack)
            return;
          let t2 = this.settings;
          return t2.height !== this.profile.height || t2.width !== this.profile.width || t2.frameRate !== this.profile.frameRate ? null == (e2 = this.mediaTrack) ? void 0 : e2.applyConstraints({ width: this.profile.width, height: this.profile.height, frameRate: this.profile.frameRate }).then(() => {
            if (this.manager && this.manager.changeInput(this), this.room && this.settings.height >= 1440 && "publish" === this.state && this.room.sendAbilityStatus({ "2k4k": 1 }), this.isNeedToSetBandwidth && this.room && this.room.setBandWidth)
              return this.isNeedToSetBandwidth = false, this.room.setBandWidth({ bandwidth: this.profile.bitrate, type: ok.VIDEO, videoType: ok.BIG });
          }) : void 0;
        }
        get settings() {
          let e2 = { width: this.profile.width, height: this.profile.height, frameRate: this.profile.frameRate };
          return eP && this.mediaTrack && Object.assign(e2, this.mediaTrack.getSettings()), e2;
        }
        get scaleResolutionDownBy() {
          let { settings: e2 } = this;
          return e2.width === this.profile.width && e2.height === this.profile.height ? 1 : dO() && this.profile.width > this.profile.height && e2.height > e2.width ? Math.max(e2.width / this.profile.height, e2.height / this.profile.width, 1) : Math.max(e2.width / this.profile.width, e2.height / this.profile.height, 1);
        }
        isAllowed2k4k(e2) {
          var t2;
          return !(this.room && this.room.scheduleResult && !this.isScreen && !(e2.height * e2.width < 3686400)) || 1 === (null == (t2 = this.room.scheduleResult.trtcAutoConf) ? void 0 : t2["2k4k"]);
        }
        isNeedToSwitchDevice(e2) {
          return !(!this.mediaTrack || this.deviceId === e2 || this.facingMode === e2);
        }
        switchDevice(e2) {
          return cb(this, null, function* () {
            try {
              if (!this.isNeedToSwitchDevice(e2))
                return;
              let t2 = { useExactDeviceId: true };
              "user" === e2 || "environment" === e2 ? t2.facingMode = e2 : t2.deviceId = e2, this.mediaTrack.stop(), yield this.capture(t2), ew.emit(gO.SWITCH_DEVICE_SUCCESS, { track: this }), this.log.info("switch camera success");
            } catch (wk2) {
              throw this.log.error("switch camera failed ".concat(wk2)), this.deviceId && this.recapture(this.deviceId), wk2;
            }
          });
        }
        listenDeviceChange() {
          kM && !kM.listeners("videoInputRemoved").includes(this.handleCameraRemoved) && kM.on("videoInputRemoved", this.handleCameraRemoved, this);
        }
        handleCameraRemoved(e2) {
          return cb(this, null, function* () {
            if (e2.deviceId === this.deviceId) {
              this.log.warn("current camera is lost: ".concat(JSON.stringify(e2)));
              let t2 = yield OM();
              t2[0] ? this.recapture(t2[0].deviceId) : kM.on("videoInputAdded", this.handleCameraAdded, this);
            }
          });
        }
        handleCameraAdded(e2) {
          return cb(this, null, function* () {
            this.log.warn("camera added: ".concat(JSON.stringify(e2))), this.recapture(e2.deviceId);
          });
        }
        play(e2, t2) {
          return cb(this, null, function* () {
            return Mw(this.mirror) && !this.isScreen && this.setMirror("view"), ab(lL.prototype, this, "play").call(this, e2, t2);
          });
        }
        close() {
          kM.off("videoInputAdded", this.handleCameraAdded, this), kM.off("videoInputRemoved", this.handleCameraRemoved, this), super.close();
        }
        recapture(e2) {
          return cb(this, null, function* () {
            try {
              yield ab(lL.prototype, this, "recapture").call(this, e2);
            } catch (wk2) {
              let i2 = (yield OM()).find((t2) => t2.deviceId !== e2);
              if (!i2)
                throw wk2;
              yield ab(lL.prototype, this, "recapture").call(this, i2.deviceId);
            }
          });
        }
      }, dL = SO();
      if (navigator.mediaDevices && "setCaptureHandleConfig" in navigator.mediaDevices)
        try {
          navigator.mediaDevices.setCaptureHandleConfig({ handle: dL, exposeOrigin: true, permittedOrigins: ["*"] });
        } catch (pF2) {
        }
      var uL, hL = function(e2) {
        return cb(this, null, function* () {
          let t2 = null, i2 = function(e3) {
            let t3 = { preferCurrentTab: "current-tab" === e3.preferDisplaySurface, systemAudio: "include", selfBrowserSurface: "include", surfaceSwitching: "include" }, i3 = { width: ND ? { max: e3.width } : { ideal: e3.width, max: e3.width }, height: ND ? { max: e3.height } : { ideal: e3.height, max: e3.height }, frameRate: e3.frameRate, displaySurface: e3.preferDisplaySurface || "monitor" };
            if (t3.video = i3, e3.systemAudio) {
              let { echoCancellation: i4 = true, noiseSuppression: r3 = false, autoGainControl: n3 = false } = e3;
              t3.audio = { echoCancellation: i4, noiseSuppression: r3, autoGainControl: n3, sampleRate: 48e3 };
            }
            return t3;
          }(e2);
          EO.info("getDisplayMedia with constraints: ".concat(JSON.stringify(i2)));
          let r2 = yield navigator.mediaDevices.getDisplayMedia(i2);
          e2.systemAudio && 0 === r2.getAudioTracks().length && (RD && bD < 74 || ND || NN) && EO.warn("Your browser not support capture system audio");
          let n2 = r2.getVideoTracks()[0];
          if (n2) {
            if (e2.frameRate)
              try {
                yield n2.applyConstraints({ frameRate: { min: e2.frameRate, ideal: e2.frameRate }, width: e2.width, height: e2.height });
              } catch (tM2) {
                EO.warn("screen applyConstraints failed: ".concat(tM2));
              }
            e2.captureElement && (yield function(e3, t3) {
              return cb(this, null, function* () {
                var i3;
                if ("CropTarget" in window && "fromElement" in CropTarget && Pw(e3.cropTo))
                  try {
                    if ((null == (i3 = e3.getCaptureHandle()) ? void 0 : i3.handle) !== dL)
                      return;
                    let r3 = yield CropTarget.fromElement(t3);
                    yield e3.cropTo(r3);
                  } catch (r3) {
                    EO.warn("cropTo target failed ".concat(r3));
                  }
              });
            }(n2, e2.captureElement));
          }
          if (e2.audio) {
            let i3 = function(e3) {
              let t3 = { echoCancellation: e3.echoCancellation, autoGainControl: e3.autoGainControl, noiseSuppression: e3.noiseSuppression, sampleRate: e3.sampleRate, channelCount: e3.channelCount };
              return Mw(e3.microphoneId) || (t3.deviceId = e3.microphoneId), { audio: t3, video: false };
            }(e2);
            EO.info("getUserMedia with constraints: ".concat(JSON.stringify(i3))), t2 = yield navigator.mediaDevices.getUserMedia(i3), r2.addTrack(t2.getAudioTracks()[0]);
          }
          return r2;
        });
      }, pL = class extends lL {
        constructor(e2) {
          super(e2, 2), sb(this, "profile", { width: 1920, height: 1080, frameRate: 5, bitrate: 1600 }), sb(this, "objectFit", "contain"), sb(this, "isScreen", true), this._log.id = "s-".concat(this._log.id);
        }
        capture(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { systemAudio: i2 = false, autoGainControl: r2, echoCancellation: n2, noiseSuppression: o2, audioTrack: s2, videoTrack: a2, captureElement: c2, preferDisplaySurface: l2 } = e3;
            return function* () {
              try {
                let e4;
                return a2 || s2 ? (e4 = new MediaStream(), a2 && e4.addTrack(a2), s2 && e4.addTrack(s2)) : e4 = yield hL({ audio: false, systemAudio: i2, width: t2.profile.width, height: t2.profile.height, frameRate: t2.profile.frameRate, autoGainControl: r2, echoCancellation: n2, noiseSuppression: o2, captureElement: c2, preferDisplaySurface: l2 }), yield t2.setInputMediaStreamTrack(e4.getVideoTracks()[0]), e4;
              } catch (e4) {
                throw t2.log.error("getDisplayMedia error observed ".concat(e4)), e4 instanceof vb ? e4 : new vb({ code: Sb.INITIALIZE_FAILED, name: e4.name, message: e4.message });
              }
            }();
          });
        }
        switchDevice(e2) {
          return cb(this, null, function* () {
            throw new Error("Method not implemented.");
          });
        }
      }, mL = class extends cL {
        constructor(e2) {
          super(e2), this._log.id = "s-".concat(this._log.id);
        }
      };
      var _L = class extends EM {
        constructor(e2) {
          super(), this.room = e2, sb(this, "_localAudioTrack"), sb(this, "_localScreenAudioTrack"), sb(this, "log", EO.createLogger({ id: "am" })), sb(this, "denoiser"), e2 && (this.log.setUserId(e2.userId), this.log.setSdkAppId(e2.sdkAppId));
        }
        get _localAudioPipline() {
          var e2;
          return null == (e2 = this._localAudioTrack) ? void 0 : e2.pipeline;
        }
        dump(e2) {
          var t2, i2;
          if (!this._localAudioTrack)
            return;
          let r2 = [], n2 = [];
          null != (t2 = this._localAudioPipline) && t2.source.node && (r2.push(this._localAudioPipline.source.node), n2.push("mic")), null != (i2 = this._localAudioPipline) && i2.denoiser.node && (r2.push(this._localAudioPipline.denoiser.node), n2.push("mic-processed")), this.mixWeight > 1 && (r2.push(this.audioContext.createMediaStreamSource(this._localAudioPipline.stream)), n2.push("mix")), this.log.info("dump audio track ".concat(n2, ", duration: ").concat(e2));
          let o2 = new AbortController(), s2 = [], a2 = setTimeout(() => {
            this.log.info('dump audio track complete please input "download()" to download.'), o2.abort("timeout");
          }, 1e3 * e2), c2 = () => {
            for (let e3 = 0; e3 < n2.length; e3++) {
              let t3 = URL.createObjectURL(new Blob(s2[e3])), i3 = document.createElement("a");
              i3.href = t3, i3.download = "".concat(n2[e3], ".pcm"), i3.style.display = "none", document.body.appendChild(i3), i3.click(), URL.revokeObjectURL(t3), i3.remove();
            }
            clearTimeout(a2), o2.abort("download");
          }, l2 = function(e3) {
            return cb(this, null, function* () {
              let t3 = nM();
              uL || (uL = $P(t3, URL.createObjectURL(new Blob(["registerProcessor('dumper', class extends AudioWorkletProcessor {process(inputs) {this.port.postMessage(inputs);return true;}});"], { type: "application/javascript" })))), yield uL;
              let i3 = new AudioWorkletNode(t3, "dumper", { numberOfInputs: e3.length, numberOfOutputs: 0 });
              return e3.forEach((e4, t4) => e4.connect(i3, 0, t4)), new ReadableStream({ start(e4) {
                i3.port.onmessage = (t4) => {
                  e4.enqueue(t4.data);
                };
              }, cancel() {
                e3.forEach((e4) => e4.disconnect(i3)), i3.port.close();
              } });
            });
          }(r2).then((e3) => e3.pipeTo(new WritableStream({ write(e4) {
            e4.forEach((e5, t3) => s2[t3] = s2[t3] ? s2[t3].concat(e5[0]) : [e5[0]]);
          } }), o2).catch((e4) => c2));
          return { then: l2.then.bind(l2), download: c2 };
        }
        get hasScreenAudioTrack() {
          return null !== this._localScreenAudioTrack;
        }
        get hasAudioTrack() {
          return null !== this._localAudioTrack;
        }
        changeInput(e2) {
          var t2;
          if (e2 instanceof mL)
            this._localScreenAudioTrack = e2, e2.pipeline.connect(), this.mixOnChange();
          else if (e2 instanceof cL)
            this._localAudioTrack = e2, this.destination.channelCount = (null == (t2 = e2.trackSettings) ? void 0 : t2.channelCount) || 1, this.denoiser && e2.addDenoiser(this.denoiser), e2.pipeline.connect(), this.mixOnChange();
          else if (e2 instanceof EL)
            return e2.setOutputMediaStreamTrack(e2.mediaTrack);
        }
        mixOnChange() {
          var e2, t2;
          null == (e2 = this._localAudioTrack) || e2.setOutputMediaStreamTrack(this.mixWeight > 1 ? this.mixTrack : this._localAudioTrack.mediaTrack), null == (t2 = this._localScreenAudioTrack) || t2.setOutputMediaStreamTrack(this.mixWeight > 1 ? this.mixTrack : this._localScreenAudioTrack.mediaTrack);
        }
        removeInput(e2) {
          e2 instanceof mL ? delete this._localScreenAudioTrack : e2 instanceof cL && delete this._localAudioTrack;
        }
        addDenoiser(e2) {
          var t2;
          this.denoiser = e2, null == (t2 = this._localAudioTrack) || t2.addDenoiser(e2);
        }
        removeDenoiser(e2) {
          var t2;
          delete this.denoiser, null == (t2 = this._localAudioTrack) || t2.removeDenoiser(e2);
        }
        destroy() {
          this.close();
        }
      };
      function fL() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 30, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
        return XM((i2, r2) => function() {
          for (var n2 = arguments.length, o2 = new Array(n2), s2 = 0; s2 < n2; s2++)
            o2[s2] = arguments[s2];
          return new Promise((n3, s3) => {
            let a2 = setTimeout(() => {
              let i3 = new vb({ code: Sb.API_CALL_TIMEOUT, message: "checkPendingPromise ".concat(r2, "() timeout ").concat(e2, "s") });
              EO.warn(i3), 2 === t2 ? s3(i3) : 1 === t2 && n3();
            }, 1e3 * e2);
            i2.apply(this, o2).then(n3, s3).finally(() => {
              clearTimeout(a2);
            });
          });
        });
      }
      var gL = class extends HM {
        constructor(e2, t2, i2) {
          super({ userId: t2.userId, sdkAppId: e2.sdkAppId, mediaType: i2, room: e2 }), this.room = e2, this.user = t2, sb(this, "tinyId"), sb(this, "isRemote", true), this.tinyId = t2.tinyId;
        }
        setMute(e2) {
          this.hasFlag && super.setMute(e2);
        }
        setInputMediaStreamTrack(e2) {
          super.setInputMediaStreamTrack(e2), this.hasFlag && this.isSubscribed && this.player.setTrack(this.outMediaTrack);
        }
        waitHasMediaTrack() {
          return new Promise((e2) => {
            this.mediaTrack ? e2() : this.once("input-media-track-changed", e2);
          });
        }
        get isSubscribing() {
          return "subscribeing" === this.state.toString();
        }
        get isSubscribed() {
          return this.state === gL.STATE_SUBSCRIBE;
        }
        subscribe(e2) {
          return e2;
        }
        unsubscribe() {
          this.player.setTrack(null), "main" === this.streamType && "video" === this.kind && this.room.changeType(false, this.user);
        }
        updatePlayingState(e2) {
          if (this.isPlayCalled && this.player.isStopped === e2) {
            if (e2 && (!this.isSubscribed || !this.hasFlag || !this.outMediaTrack))
              return void this.log.info("abort play, isSubscribed:".concat(this.isSubscribed, " hasFlag:").concat(this.hasFlag, " hasTrack:").concat(!!this.outMediaTrack));
            super.updatePlayingState(e2);
          }
        }
        onFlagChanged() {
          this.updatePlayingState(this.hasFlag);
        }
      }, TL = gL;
      sb(TL, "STATE_SUBSCRIBE", "subscribe"), ob([fL(5, 1)], TL.prototype, "waitHasMediaTrack", 1), ob([_P(TP.INIT, TL.STATE_SUBSCRIBE, { success() {
        this.log.info("subscribed"), ew.emit(gO.REMOTE_TRACK_SUBSCRIBED, { track: this }), this.updatePlayingState(true);
      }, ignoreError: true })], TL.prototype, "subscribe", 1), ob([_P(TL.STATE_SUBSCRIBE, TP.INIT, { sync: true, success() {
        this.log.info("unsubscribed"), this.updatePlayingState(false), ew.emit(gO.REMOTE_TRACK_UNSUBSCRIBED, { track: this });
      } })], TL.prototype, "unsubscribe", 1);
      var EL = class extends TL {
        constructor(e2, t2) {
          super(e2, t2, 1), sb(this, "volume", 0), sb(this, "mediaType", 1), sb(this, "stat", { bytesReceived: 0, packetsReceived: 0, packetsLost: 0, end2EndDelay: 0, jitterBufferDelay: 0 }), this.manager = e2.audioManager;
        }
        getAudioLevel() {
          let e2 = this.volume || super.getAudioLevel();
          return e2 > 1 ? 1 : e2;
        }
        get hasFlag() {
          return this.user.muteState.hasAudio && !this.user.muteState.audioMuted;
        }
        isFlagChanged(e2) {
          let t2 = e2.hasAudio && !e2.audioMuted;
          return this.hasFlag || (this.volume = 0), this.hasFlag !== t2;
        }
      }, SL = class extends TL {
        constructor(e2, t2) {
          super(e2, t2, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4), sb(this, "mediaType", 4), sb(this, "source"), sb(this, "stat", { bytesReceived: 0, packetsReceived: 0, packetsLost: 0, framesReceived: 0, framesDecoded: 0, frameWidth: 0, frameHeight: 0, end2EndDelay: 0, jitterBufferDelay: 0 }), this.manager = e2.videoManager;
        }
        get isBig() {
          return 4 === this.mediaType;
        }
        get isSmall() {
          return 8 === this.mediaType;
        }
        changeType(e2) {
          this.room.changeType(e2, this.user);
        }
        get hasFlag() {
          return this.user.muteState.hasVideo && !this.user.muteState.videoMuted;
        }
        isFlagChanged(e2) {
          let t2 = e2.hasVideo && !e2.videoMuted;
          return this.hasFlag !== t2;
        }
        setMirror(e2) {
          "publish" === e2 || "both" === e2 || super.setMirror(e2);
        }
      }, IL = class extends SL {
        constructor(e2, t2) {
          super(e2, t2, 2), sb(this, "mediaType", 2), sb(this, "objectFit", "contain");
        }
        get hasFlag() {
          return this.user.muteState.hasAuxiliary;
        }
        isFlagChanged(e2) {
          let t2 = e2.hasAuxiliary;
          return this.hasFlag !== t2;
        }
      };
      function vL() {
      }
      var yL = (e2) => e2(), AL = () => "undefined" != typeof __FASTRX_DEVTOOLS__, RL = 1, CL = class extends Function {
        toString() {
          return "".concat(this.name, "(").concat(this.args.length ? [...this.args].join(", ") : "", ")");
        }
        subscribe(e2) {
          let t2 = new wL(e2, this, this.streamId++);
          return OL.subscribe({ id: this.id, end: false }, { nodeId: t2.sourceId, streamId: t2.id }), this(t2), t2;
        }
      }, bL = class {
        constructor() {
          this.defers = /* @__PURE__ */ new Set(), this.disposed = false;
        }
        next(e2) {
        }
        complete() {
          this.dispose();
        }
        error(e2) {
          this.dispose();
        }
        get bindDispose() {
          return () => this.dispose();
        }
        dispose() {
          this.disposed = true, this.complete = vL, this.error = vL, this.next = vL, this.dispose = vL, this.subscribe = vL, this.doDefer();
        }
        subscribe(e2) {
          return e2 instanceof CL ? e2.subscribe(this) : e2(this), this;
        }
        get bindSubscribe() {
          return (e2) => this.subscribe(e2);
        }
        doDefer() {
          this.defers.forEach(yL), this.defers.clear();
        }
        defer(e2) {
          this.defers.add(e2);
        }
        removeDefer(e2) {
          this.defers.delete(e2);
        }
        reset() {
          this.disposed = false, delete this.complete, delete this.next, delete this.dispose, delete this.next, delete this.subscribe;
        }
        resetNext() {
          delete this.next;
        }
        resetComplete() {
          delete this.complete;
        }
        resetError() {
          delete this.error;
        }
      }, kL = class extends bL {
        constructor(e2) {
          super(), this.sink = e2, e2.defer(this.bindDispose);
        }
        next(e2) {
          this.sink.next(e2);
        }
        complete() {
          this.sink.complete();
        }
        error(e2) {
          this.sink.error(e2);
        }
      };
      function NL(e2, t2, i2) {
        if (AL()) {
          let r2 = Object.defineProperties(Object.setPrototypeOf(e2, CL.prototype), { streamId: { value: 0, writable: true, configurable: true }, name: { value: t2, writable: true, configurable: true }, args: { value: i2, writable: true, configurable: true }, id: { value: 0, writable: true, configurable: true } });
          OL.create(r2);
          for (let e3 = 0; e3 < i2.length; e3++) {
            let t3 = i2[e3];
            "function" == typeof t3 && t3 instanceof CL && OL.addSource(r2, t3);
          }
          return r2;
        }
        return e2;
      }
      function DL(e2, t2) {
        window.postMessage({ source: "fastrx-devtools-backend", payload: { event: e2, payload: t2 } });
      }
      var wL = class extends kL {
        constructor(e2, t2, i2) {
          super(e2), this.source = t2, this.id = i2, this.sourceId = e2.sourceId, this.defer(() => {
            OL.defer(this.source, this.id);
          });
        }
        next(e2) {
          OL.next(this.source, this.id, e2), this.sink.next(e2);
        }
        complete() {
          OL.complete(this.source, this.id), this.sink.complete();
        }
        error(e2) {
          OL.complete(this.source, this.id, e2), this.sink.error(e2);
        }
      }, OL = { addSource(e2, t2) {
        DL("addSource", { id: e2.id, name: e2.toString(), source: { id: t2.id, name: t2.toString() } });
      }, next(e2, t2, i2) {
        DL("next", { id: e2.id, streamId: t2, data: i2 && i2.toString() });
      }, subscribe(e2, t2) {
        let { id: i2, end: r2 } = e2;
        DL("subscribe", { id: i2, end: r2, sink: { nodeId: t2 && t2.nodeId, streamId: t2 && t2.streamId } });
      }, complete(e2, t2, i2) {
        DL("complete", { id: e2.id, streamId: t2, err: i2 ? i2.toString() : null });
      }, defer(e2, t2) {
        DL("defer", { id: e2.id, streamId: t2 });
      }, pipe(e2) {
        DL("pipe", { name: e2.toString(), id: e2.id, source: { id: e2.source.id, name: e2.source.toString() } });
      }, update(e2) {
        DL("update", { id: e2.id, name: e2.toString() });
      }, create(e2) {
        e2.id || (e2.id = RL++), DL("create", { name: e2.toString(), id: e2.id });
      } }, PL = class extends bL {
        constructor(e2) {
          super(), this.source = e2, this.sinks = /* @__PURE__ */ new Set();
        }
        add(e2) {
          e2.defer(() => this.remove(e2)), 1 === this.sinks.add(e2).size && (this.reset(), this.subscribe(this.source));
        }
        remove(e2) {
          this.sinks.delete(e2), 0 === this.sinks.size && this.dispose();
        }
        next(e2) {
          this.sinks.forEach((t2) => t2.next(e2));
        }
        complete() {
          this.sinks.forEach((e2) => e2.complete()), this.sinks.clear();
        }
        error(e2) {
          this.sinks.forEach((t2) => t2.error(e2)), this.sinks.clear();
        }
      };
      var ML = /* @__PURE__ */ function(e2, t2) {
        return function() {
          for (var i2 = arguments.length, r2 = new Array(i2), n2 = 0; n2 < i2; n2++)
            r2[n2] = arguments[n2];
          return (i3) => {
            if (i3 instanceof CL) {
              let n3 = NL((t3) => {
                let o2 = new e2(t3, ...r2);
                o2.sourceId = n3.id, o2.subscribe(i3);
              }, t2, arguments);
              return n3.source = i3, OL.pipe(n3), n3;
            }
            return (t3) => i3(new e2(t3, ...r2));
          };
        };
      }(class extends kL {
        constructor(e2, t2, i2) {
          super(e2), this.mapper = t2, this.thisArg = i2;
        }
        next(e2) {
          super.next(this.mapper.call(this.thisArg, e2));
        }
      }, "map");
      !function(e2) {
        for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
          i2[r2 - 1] = arguments[r2];
        i2.reduce((e3, t3) => t3(e3), e2);
      }(function(e2) {
        return NL((t2) => {
          let i2 = 0, r2 = setInterval(() => t2.next(i2++), e2);
          return t2.defer(() => {
            clearInterval(r2);
          }), "interval";
        }, "interval", arguments);
      }(250), ML(() => performance.now()), /* @__PURE__ */ function() {
        return (e2) => {
          let t2 = new PL(e2);
          if (e2 instanceof CL) {
            let i2 = NL((e3) => {
              t2.add(e3);
            }, "share", arguments);
            return t2.sourceId = i2.id, i2.source = e2, OL.pipe(i2), i2;
          }
          return NL(t2.add.bind(t2), "share", arguments);
        };
      }());
      var LL = /* @__PURE__ */ new Map();
      function xL(e2, t2) {
        let i2 = tb(eb({}, t2), { timestamp: Ab() });
        LL.has(e2) ? LL.get(e2).push(i2) : LL.set(e2, [i2]);
      }
      ew.on(gO.JOIN_SUCCESS, (e2) => {
        let { room: t2 } = e2;
        xL(t2.userId, { eventId: 32788, eventDesc: "join room" });
      }), ew.on(gO.LEAVE_START, (e2) => {
        let { room: t2 } = e2;
        xL(t2.userId, { eventId: 32789, eventDesc: "leave room" });
      }), ew.on(gO.LOCAL_TRACK_PUBLISHED, (e2) => {
        let { track: t2 } = e2;
        if (t2.room) {
          let e3 = 32769;
          4 === t2.mediaType ? e3 = 32768 : 2 === t2.mediaType && (e3 = 32805), xL(t2.room.userId, { eventId: e3, eventDesc: "publish ".concat(t2.kind) });
        }
      }), ew.on(gO.LOCAL_TRACK_UNPUBLISHED, (e2) => {
        let { track: t2 } = e2;
        if (t2.room) {
          let e3 = 32771;
          4 === t2.mediaType ? e3 = 32770 : 2 === t2.mediaType && (e3 = 32806), xL(t2.room.userId, { eventId: e3, eventDesc: "unpublish ".concat(t2.kind) });
        }
      }), ew.on(gO.TRACK_MUTED, (e2) => {
        let { track: t2 } = e2;
        t2.room && (t2.kind === ok.AUDIO ? xL(t2.room.userId, { eventId: t2.isRemote ? 32785 : 32772, eventDesc: "mute audio", remoteUserId: t2.isRemote ? t2.userId : void 0 }) : xL(t2.room.userId, { eventId: t2.isRemote ? 32784 : 32773, eventDesc: "mute video", remoteUserId: t2.isRemote ? t2.userId : void 0 }));
      }), ew.on(gO.TRACK_UNMUTED, (e2) => {
        let { track: t2 } = e2;
        t2.room && (t2.kind === ok.AUDIO ? xL(t2.room.userId, { eventId: t2.isRemote ? 32787 : 32774, eventDesc: "unmute audio", remoteUserId: t2.isRemote ? t2.userId : void 0 }) : xL(t2.room.userId, { eventId: t2.isRemote ? 32786 : 32775, eventDesc: "unmute video", remoteUserId: t2.isRemote ? t2.userId : void 0 }));
      }), ew.on(gO.REMOTE_TRACK_SUBSCRIBED, (e2) => {
        let { track: t2 } = e2;
        !t2.room || (1 === t2.mediaType && xL(t2.room.userId, { eventId: 32777, eventDesc: "".concat(ok.SUBSCRIBE, " ").concat(t2.kind), remoteUserId: t2.userId }), 4 === t2.mediaType && xL(t2.room.userId, { eventId: 32776, eventDesc: "".concat(ok.SUBSCRIBE, " ").concat(t2.kind), remoteUserId: t2.userId }), 8 === t2.mediaType && xL(t2.room.userId, { eventId: 32803, eventDesc: "".concat(ok.SUBSCRIBE, " ").concat(ok.SMALL_VIDEO), remoteUserId: t2.userId }));
      }), ew.on(gO.REMOTE_TRACK_UNSUBSCRIBED, (e2) => {
        let { track: t2 } = e2;
        !t2.room || (1 === t2.mediaType && xL(t2.room.userId, { eventId: 32779, eventDesc: "".concat(ok.UNSUBSCRIBE, " ").concat(t2.kind), remoteUserId: t2.userId }), 4 === t2.mediaType && xL(t2.room.userId, { eventId: 32778, eventDesc: "".concat(ok.UNSUBSCRIBE, " ").concat(t2.kind), remoteUserId: t2.userId }), 8 === t2.mediaType && xL(t2.room.userId, { eventId: 32804, eventDesc: "".concat(ok.UNSUBSCRIBE, " ").concat(ok.SMALL_VIDEO), remoteUserId: t2.userId }));
      }), ew.on(gO.SWITCH_DEVICE_SUCCESS, (e2) => {
        let { track: t2 } = e2;
        t2.room && xL(t2.room.userId, { eventId: t2.kind === ok.VIDEO ? 32780 : 32781, eventDesc: "switch ".concat(t2.kind === ok.VIDEO ? "camera" : "microphone") });
      }), ew.on(gO.LOCAL_TRACK_REPLACED, (e2) => {
        let { track: t2 } = e2;
        t2.room && xL(t2.room.userId, { eventId: t2.kind === ok.VIDEO ? 32782 : 32783, eventDesc: "replace ".concat(t2.kind) });
      }), ew.on(gO.SIGNAL_CONNECTION_STATE_CHANGED, (e2) => {
        let t2, i2, { room: r2, prevState: n2, state: o2 } = e2;
        switch (o2) {
          case "CONNECTED":
            "RECONNECTING" === n2 ? (t2 = 32795, i2 = "signal reconnected") : (t2 = 32791, i2 = "signal connected");
            break;
          case "DISCONNECTED":
            "RECONNECTING" === n2 ? (t2 = 32796, i2 = "signal reconnect fail") : (t2 = 32790, i2 = "signal disconnected");
            break;
          case "RECONNECTING":
            t2 = 32794, i2 = "signal reconnecting";
        }
        t2 && i2 && xL(r2.userId, { eventId: t2, eventDesc: i2 });
      }), ew.on(gO.PEER_CONNECTION_STATE_CHANGED, (e2) => {
        let t2, i2, { room: r2, prevState: n2, state: o2, remoteUserId: s2 } = e2, a2 = !!s2, c2 = a2 ? "downlink" : "uplink";
        switch (o2) {
          case "CONNECTED":
            "RECONNECTING" === n2 ? (t2 = a2 ? 32801 : 32798, i2 = "".concat(c2, " reconnected")) : (t2 = a2 ? 32793 : 32792, i2 = "".concat(c2, " connected"));
            break;
          case "DISCONNECTED":
            "RECONNECTING" === n2 && (t2 = a2 ? 32802 : 32799, i2 = "".concat(c2, " reconnect fail"));
            break;
          case "RECONNECTING":
            t2 = a2 ? 32800 : 32797, i2 = "".concat(c2, " reconnecting");
        }
        t2 && i2 && xL(r2.userId, { eventId: t2, eventDesc: i2, remoteUserId: s2 });
      });
      var VL = nb(lb(), 1), UL = class extends VL.EventEmitter {
        constructor(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "userId";
          super(), this.mySelfId = e2, this._log = t2, this.key = i2, sb(this, "userMap", /* @__PURE__ */ new Map()), sb(this, "remotePublishedUserMap", /* @__PURE__ */ new Map());
        }
        getPublishedUser(e2) {
          return this.remotePublishedUserMap.get(e2);
        }
        addUser(e2) {
          let t2 = e2[this.key], { userId: i2, tinyId: r2, role: n2 } = e2;
          if (this.userMap.has(t2))
            return;
          let o2 = { userId: i2, tinyId: r2, role: 20 === n2 ? "anchor" : "audience" };
          this.userMap.set(t2, o2), this.emit("1", o2);
        }
        deleteUser(e2, t2) {
          let i2 = this.userMap.get(e2);
          if (!i2)
            return;
          let r2 = "peer leave [".concat(e2, "]");
          Mw(t2) || (r2 += ":".concat(eN[t2])), this._log.info(r2);
          let n2 = this.remotePublishedUserMap.get(e2);
          if (n2) {
            let t3 = n2.muteState;
            n2.flag = 0, this.emit("5", n2.userId), this.deleteRemotePublishedUser(e2), this.emit("6", { prevMuteState: t3, muteState: n2.muteState, flag: 0 });
          }
          this.userMap.delete(e2), this.emit("2", i2.userId);
        }
        setUserList(e2) {
          this.userMap.forEach((t2) => {
            e2.findIndex((e3) => e3[this.key] === t2[this.key]) < 0 && this.deleteUser(t2[this.key], 0);
          }), e2.forEach((e3) => {
            !this.userMap.has(e3[this.key]) && e3[this.key] !== this.mySelfId && this.addUser(e3);
          });
        }
        addRemotePublishedUser(e2) {
          this.remotePublishedUserMap.has(e2[this.key]) || this.remotePublishedUserMap.set(e2[this.key], e2);
        }
        deleteRemotePublishedUser(e2) {
          !this.remotePublishedUserMap.has(e2) || this.remotePublishedUserMap.delete(e2);
        }
        setRemotePublishedUserList(e2) {
          this.remotePublishedUserMap.forEach((t2) => {
            let i2 = t2[this.key];
            if (e2.findIndex((e3) => e3[this.key] === t2[this.key]) < 0) {
              this._log.info("remote [".concat(i2, "] unpublish"));
              let e3 = t2.muteState;
              t2.flag = 0, this.emit("5", t2.userId), this.deleteRemotePublishedUser(i2), this.emit("6", { prevMuteState: e3, muteState: t2.muteState, flag: 0 });
            }
          }), e2.forEach((e3) => {
            var t2;
            let i2 = e3[this.key];
            if (i2 === this.mySelfId)
              return;
            let { flag: r2, userId: n2, tinyId: o2 } = e3, s2 = $w(r2, n2), a2 = null == (t2 = this.remotePublishedUserMap.get(i2)) ? void 0 : t2.muteState;
            if (a2) {
              let e4 = this.remotePublishedUserMap.get(i2);
              e4 && e4.flag !== r2 && (e4.flag = r2, this._log.info("remote publish updated: ".concat(JSON.stringify(e4.muteState))), this.emit("6", { prevMuteState: a2, muteState: s2, flag: r2 }));
            } else
              this._log.info("remote publish. state: ".concat(JSON.stringify(s2))), this.addUser({ userId: n2, tinyId: o2, role: 20 }), this.emit("3", e3), this.emit("6", { prevMuteState: $w(0, n2), muteState: s2, flag: r2 });
          });
        }
        clear() {
          this.userMap.clear(), this.remotePublishedUserMap.clear();
        }
      };
      function FL(e2) {
        let { timesInSecond: t2, maxSizeInSecond: i2, getSize: r2 } = e2;
        return XM((e3, n2) => {
          let o2 = /* @__PURE__ */ new Map();
          return ew.on(gO.ROOM_DESTROY, (e4) => {
            let { room: t3 } = e4;
            return o2.delete(t3);
          }), function() {
            let s2 = o2.get(this);
            for (var a2 = arguments.length, c2 = new Array(a2), l2 = 0; l2 < a2; l2++)
              c2[l2] = arguments[l2];
            if (s2 || (s2 = { callCountInSecond: 0, timestamp: 0, totalSizeInSecond: 0 }, o2.set(this, s2)), 0 === s2.timestamp ? s2.timestamp = Date.now() : Date.now() - s2.timestamp > 1e3 && (s2.timestamp = Date.now(), s2.callCountInSecond = 0, s2.totalSizeInSecond = 0), r2 && (s2.totalSizeInSecond += r2(...c2)), 0 !== s2.timestamp && Date.now() - s2.timestamp < 1e3 && (s2.callCountInSecond >= t2 || s2.totalSizeInSecond > i2))
              throw new vb({ code: Sb.INVALID_OPERATION, message: XD({ key: uN.CALL_FREQUENCY_LIMIT, data: { isTimes: s2.callCountInSecond >= t2, isSize: s2.totalSizeInSecond > i2, name: n2, timesInSecond: t2, maxSizeInSecond: i2 } }) });
            s2.callCountInSecond++, e3.call(this, ...c2);
          };
        });
      }
      var BL, HL = true, jL = { SCENE_LIVE: "live", SCENE_RTC: "rtc", ROLE_ANCHOR: "anchor", ROLE_AUDIENCE: "audience", STREAM_TYPE_MAIN: "main", STREAM_TYPE_SUB: "sub", AUDIO_PROFILE_STANDARD: "standard", AUDIO_PROFILE_STANDARD_STEREO: "standard-stereo", AUDIO_PROFILE_HIGH: "high", AUDIO_PROFILE_HIGH_STEREO: "high-stereo", QOS_PREFERENCE_SMOOTH: "smooth", QOS_PREFERENCE_CLEAR: "clear" }, GL = { INVALID_PARAMETER: 5e3, INVALID_OPERATION: 5100, ENV_NOT_SUPPORTED: 5200, DEVICE_ERROR: 5300, SERVER_ERROR: 5400, OPERATION_FAILED: 5500, OPERATION_ABORT: 5998, UNKNOWN_ERROR: 5999 }, WL = ((BL = WL || {})[BL.INVALID_PARAMETER = 5e3] = "INVALID_PARAMETER", BL[BL.INVALID_PARAMETER_REQUIRED = 5001] = "INVALID_PARAMETER_REQUIRED", BL[BL.INVALID_PARAMETER_TYPE = 5002] = "INVALID_PARAMETER_TYPE", BL[BL.INVALID_PARAMETER_EMPTY = 5003] = "INVALID_PARAMETER_EMPTY", BL[BL.INVALID_PARAMETER_INSTANCE = 5004] = "INVALID_PARAMETER_INSTANCE", BL[BL.INVALID_PARAMETER_RANGE = 5005] = "INVALID_PARAMETER_RANGE", BL[BL.INVALID_PARAMETER_LESS_THAN_ZERO = 5006] = "INVALID_PARAMETER_LESS_THAN_ZERO", BL[BL.INVALID_PARAMETER_MIN = 5007] = "INVALID_PARAMETER_MIN", BL[BL.INVALID_PARAMETER_MAX = 5008] = "INVALID_PARAMETER_MAX", BL[BL.INVALID_ELEMENT_ID = 5009] = "INVALID_ELEMENT_ID", BL[BL.INVALID_ELEMENT_ID_TYPE = 5010] = "INVALID_ELEMENT_ID_TYPE", BL[BL.INVALID_STREAM_ID = 5011] = "INVALID_STREAM_ID", BL[BL.INVALID_ROOM_ID_STRING = 5012] = "INVALID_ROOM_ID_STRING", BL[BL.INVALID_ROOM_ID_INTEGER = 5013] = "INVALID_ROOM_ID_INTEGER", BL[BL.INVALID_STREAM_TYPE = 5014] = "INVALID_STREAM_TYPE", BL[BL.INVALID_ROOM_ID_REQUIED = 5015] = "INVALID_ROOM_ID_REQUIED", BL[BL.INVALID_ROOM_ID_INTEGER_STRING = 5016] = "INVALID_ROOM_ID_INTEGER_STRING", BL[BL.INVALID_BUFFER_EMPTY = 5017] = "INVALID_BUFFER_EMPTY", BL[BL.INVALID_BUFFER_OVERSIZE = 5018] = "INVALID_BUFFER_OVERSIZE", BL[BL.INVALID_OPERATION = 5100] = "INVALID_OPERATION", BL[BL.INVALID_OPERATION_NOT_JOINED = 5101] = "INVALID_OPERATION_NOT_JOINED", BL[BL.INVALID_OPERATION_REMOTE_USER_NOT_EXIST = 5102] = "INVALID_OPERATION_REMOTE_USER_NOT_EXIST", BL[BL.INVALID_OPERATION_STREAM_TYPE_NOT_EXIST = 5103] = "INVALID_OPERATION_STREAM_TYPE_NOT_EXIST", BL[BL.INVALID_OPERATION_REPEAT_CALL = 5104] = "INVALID_OPERATION_REPEAT_CALL", BL[BL.INVALID_OPERATION_NEED_VIDEO = 5105] = "INVALID_OPERATION_NEED_VIDEO", BL[BL.INVALID_OPERATION_NEED_AUDIO = 5106] = "INVALID_OPERATION_NEED_AUDIO", BL[BL.INVALID_ROLE_AUDIENCE = 5107] = "INVALID_ROLE_AUDIENCE", BL[BL.ENV_NOT_SUPPORTED = 5200] = "ENV_NOT_SUPPORTED", BL[BL.NOT_SUPPORTED_HTTP = 5201] = "NOT_SUPPORTED_HTTP", BL[BL.NOT_SUPPORTED_WEBRTC = 5202] = "NOT_SUPPORTED_WEBRTC", BL[BL.NOT_SUPPORTED_H264_ENCODE = 5203] = "NOT_SUPPORTED_H264_ENCODE", BL[BL.NOT_SUPPORTED_H264_DECODE = 5204] = "NOT_SUPPORTED_H264_DECODE", BL[BL.NOT_SUPPORTED_SCREEN_SHARE = 5205] = "NOT_SUPPORTED_SCREEN_SHARE", BL[BL.NOT_SUPPORTED_SMALL_VIDEO = 5206] = "NOT_SUPPORTED_SMALL_VIDEO", BL[BL.NOT_SUPPORTED_SEI = 5207] = "NOT_SUPPORTED_SEI", BL[BL.NOT_SUPPORTED_WEBGL = 5208] = "NOT_SUPPORTED_WEBGL", BL[BL.NOT_SUPPORTED_CHROME_VERSION = 5209] = "NOT_SUPPORTED_CHROME_VERSION", BL[BL.DEVICE_ERROR = 5300] = "DEVICE_ERROR", BL[BL.DEVICE_NOT_FOUND_ERROR = 5301] = "DEVICE_NOT_FOUND_ERROR", BL[BL.DEVICE_NOT_ALLOWED_ERROR = 5302] = "DEVICE_NOT_ALLOWED_ERROR", BL[BL.DEVICE_NOT_READABLE_ERROR = 5303] = "DEVICE_NOT_READABLE_ERROR", BL[BL.DEVICE_OVERCONSTRAINED_ERROR = 5304] = "DEVICE_OVERCONSTRAINED_ERROR", BL[BL.DEVICE_INVALID_STATE_ERROR = 5305] = "DEVICE_INVALID_STATE_ERROR", BL[BL.DEVICE_SECURITY_ERROR = 5306] = "DEVICE_SECURITY_ERROR", BL[BL.DEVICE_ABORT_ERROR = 5307] = "DEVICE_ABORT_ERROR", BL[BL.CAMERA_RECOVER_FAILED = 5308] = "CAMERA_RECOVER_FAILED", BL[BL.MICROPHONE_RECOVER_FAILED = 5309] = "MICROPHONE_RECOVER_FAILED", BL[BL.SERVER_ERROR = 5400] = "SERVER_ERROR", BL[BL.NEED_TO_BUY = 5401] = "NEED_TO_BUY", BL[BL.ACCOUNT_NO_MONEY = -100013] = "ACCOUNT_NO_MONEY", BL[BL.OPERATION_FAILED = 5500] = "OPERATION_FAILED", BL[BL.FIREWALL_RESTRICTION = 5501] = "FIREWALL_RESTRICTION", BL[BL.REJOIN_FAILED = 5502] = "REJOIN_FAILED", BL[BL.EVENT_HANDLER_ERROR = 5503] = "EVENT_HANDLER_ERROR", BL[BL.VIDEO_CONTEXT_ERROR = 5504] = "VIDEO_CONTEXT_ERROR", BL[BL.OPERATION_ABORT = 5998] = "OPERATION_ABORT", BL[BL.UNKNOWN_ERROR = 5999] = "UNKNOWN_ERROR", BL);
      var JL = tb(eb({}, hN), { INVALID_PARAMETER(e2) {
        let { fnName: t2 } = e2;
        return "the parameters of the '".concat(t2, "' you called does not meet the requirements, please check the API documentation.");
      }, INVALID_PARAMETER_REQUIRED(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "'".concat(t2 || i2.name, "' is a required param when calling ").concat(r2, "(), received: ").concat(n2, ".");
      }, INVALID_PARAMETER_TYPE(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2, o2 = "".concat(t2 || i2.name), s2 = "";
        return s2 = Array.isArray(i2.type) ? i2.type.join("|") : i2.type, "'".concat(o2, "' must be type of ").concat(s2, " when calling ").concat(r2, "(), received type: ").concat(Ow(n2), ".");
      }, INVALID_PARAMETER_EMPTY(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "'".concat(t2 || i2.name, "' cannot be '").concat(n2, "' when calling ").concat(r2, "().");
      }, INVALID_PARAMETER_INSTANCE(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2, o2 = "".concat(t2 || i2.name), s2 = "".concat(i2.instanceOf.name || i2.instanceOf);
        return "'".concat(o2, "' must be instanceof ").concat(s2, " when calling ").concat(r2, "(), received type: ").concat(Ow(n2), ".");
      }, INVALID_PARAMETER_RANGE(e2) {
        let { key: t2, rule: i2, fnName: r2, value: n2 } = e2;
        return "'".concat(t2 || i2.name, "' must be one of ").concat(i2.values.join("|"), " when calling ").concat(r2, "(), received: ").concat(n2, ".");
      }, INVALID_PARAMETER_LESS_THAN_ZERO(e2) {
        let { key: t2, rule: i2, fnName: r2 } = e2;
        return "'".concat(t2 || i2.name, "' cannot be less than 0 when calling ").concat(r2, "().");
      }, INVALID_PARAMETER_MIN(e2) {
        let { key: t2, rule: i2, value: r2 } = e2;
        return "the min value of ".concat(t2 || i2.name, " is ").concat(i2.min, ", received: ").concat(r2, ".");
      }, INVALID_PARAMETER_MAX(e2) {
        let { key: t2, rule: i2, value: r2 } = e2;
        return "the max value of ".concat(t2 || i2.name, " is ").concat(i2.max, ", received: ").concat(r2, ".");
      }, INVALID_ELEMENT_ID(e2) {
        let { key: t2, fnName: i2 } = e2;
        return "'".concat(t2, "' is not found in the document object when calling ").concat(i2, "().");
      }, INVALID_ELEMENT_ID_TYPE(e2) {
        let { key: t2, fnName: i2, type: r2 } = e2;
        return "the element corresponding to '".concat(t2, "' must be instanceof HTMLElement when calling ").concat(i2, "(), received: ").concat(r2, ".");
      }, INVALID_STREAM_ID(e2) {
        let { key: t2 } = e2;
        return "'".concat(t2, "' can only consist of uppercase and lowercase english letters (a-zA-Z), numbers (0-9), hyphens and underscores.");
      }, INVALID_ROOM_ID_STRING(e2) {
        let { key: t2 } = e2;
        return "'".concat(t2, "' must be a valid string.");
      }, INVALID_ROOM_ID_INTEGER(e2) {
        let { key: t2 } = e2;
        return "'".concat(t2, "' must be an integer between [1, 4294967294].");
      }, INVALID_ROOM_ID_INTEGER_STRING(e2) {
        let { key: t2 } = e2;
        return "'".concat(t2, "' must be an integer but go a string, use 'parseInt' to convert it or use 'strRoomId' instead.");
      }, INVALID_ROOM_ID_REQUIED: () => "at least one of 'roomId'(between [1, 4294967294]) and 'strRoomId'(not empty) is required.", INVALID_STREAM_TYPE: (e2) => {
        let { fnName: t2 } = e2;
        return "'streamType' is required when 'userId' is not '*', calling ".concat(t2, "()");
      }, INVALID_IMAGE_URL: "The 'src' param must be filled in when the background type is image.", INVALID_OPERATION(e2) {
        let { fnName: t2 } = e2;
        return "the API '".concat(t2, "' you called does not meet the requirements, please check the API documentation.");
      }, INVALID_OPERATION_NOT_JOINED(e2) {
        let { fnName: t2 } = e2;
        return "cannot ".concat(t2, " because you are not enter room yet.");
      }, INVALID_OPERATION_REMOTE_USER_NOT_EXIST(e2) {
        let { fnName: t2, value: i2 } = e2;
        return "cannot ".concat(t2, " because remote user(userId: ").concat(i2.userId, ") does not publishing stream.");
      }, INVALID_OPERATION_STREAM_TYPE_NOT_EXIST(e2) {
        let { fnName: t2, value: i2 } = e2;
        return "cannot ".concat(t2, " because remote user(userId: ").concat(i2.userId, ") does not publishing ").concat(i2.streamType, " video.");
      }, INVALID_OPERATION_REPEAT_CALL(e2) {
        let { fnName: t2 } = e2;
        return "you are already ".concat(t2, "(), cannot repeated call '").concat(t2, "'.");
      }, INVALID_OPERATION_NEED_VIDEO(e2) {
        let { fnName: t2 } = e2;
        return "cannot call '".concat(t2, "' because the camera is not turned on.");
      }, INVALID_OPERATION_NEED_AUDIO(e2) {
        let { fnName: t2 } = e2;
        return "cannot call '".concat(t2, "' because the microphone is not turned on.");
      }, INVALID_BUFFER_EMPTY: (e2) => {
        let { key: t2 } = e2;
        return "the buffer size of paramerter '".concat(t2, "' cannot be empty");
      }, INVALID_BUFFER_OVERSIZE: () => "buffer size is over 1000 Bytes", INVALID_ROLE_AUDIENCE: () => "role: '".concat("audience", "' cannot call this api."), ENV_NOT_SUPPORTED(e2) {
        let { fnName: t2 } = e2;
        return "the current browser does not support the capability of the function '".concat(t2, "' you are calling, please check the API documentation.");
      }, NOT_SUPPORTED_WEBRTC: "the current browser does not support WebRTC capability, please check the SDK documentation.", NOT_SUPPORTED_H264_ENCODE: "this browser does not support H264 encode.", NOT_SUPPORTED_H264_DECODE: "this browser does not support H264 decode.", NOT_SUPPORTED_SCREEN_SHARE: "this browser does not support screen share, please check the browser version.", NOT_SUPPORTED_SMALL_VIDEO: "this browser does not support small video, please check the browser version.", NOT_SUPPORTED_SEI: "this browser does not support SEI, please check the browser version.", NOT_SUPPORTED_WEBGL: "this browser does not support WebGL, please check the browser version.", NOT_SUPPORTED_CHROME_VERSION(e2) {
        let { fnName: t2 } = e2;
        return "cannot call ".concat(t2, " because the browser version is too low, please upgrade to the latest version");
      }, DEVICE_ERROR(e2) {
        let { fnName: t2, error: i2 } = e2;
        return "'".concat(t2, "' got device exception").concat(i2 ? ", error: ".concat(i2.toString(), ".") : ".");
      }, DEVICE_NOT_FOUND_ERROR(e2) {
        let { fnName: t2, deviceType: i2 = KL(t2), error: r2 } = e2;
        return "NotFoundError, no ".concat(i2, " detected, please check your device and the configuration on '").concat(t2, "'").concat(r2 ? ", error: ".concat(r2.toString(), ".") : ".");
      }, DEVICE_NOT_ALLOWED_ERROR(e2) {
        let { fnName: t2, deviceType: i2 = KL(t2), error: r2 } = e2;
        return "NotAllowedError, you have disabled ".concat(i2, " access, please allow the current application to use the ").concat(i2).concat(r2 ? ", error: ".concat(r2.toString(), ".") : ".");
      }, DEVICE_NOT_READABLE_ERROR(e2) {
        let { fnName: t2, deviceType: i2 = KL(t2), error: r2 } = e2;
        return "NotReadableError, the ".concat(i2, " maybe in use by another APP, please check if the device is pre-occupied by another APP.");
      }, DEVICE_OVERCONSTRAINED_ERROR(e2) {
        let { fnName: t2, deviceType: i2 = KL(t2), error: r2 } = e2;
        return "OverconstrainedError, the device ID is incorrect, please check whether the device ID passed in is correct".concat(r2 ? ", error: ".concat(r2.toString(), ".") : ".");
      }, DEVICE_INVALID_STATE_ERROR(e2) {
        let { fnName: t2, deviceType: i2 = KL(t2), error: r2 } = e2;
        return "InvalidStateError, after the user clicks and interacts with the page, turn on the ".concat(i2).concat(r2 ? ", error: ".concat(r2.toString(), ".") : ".");
      }, DEVICE_SECURITY_ERROR(e2) {
        let { fnName: t2, deviceType: i2 = KL(t2), error: r2 } = e2;
        return "SecurityError, check whether the system security policy restricts the use of the ".concat(i2, ", and it is recommended to turn on the ").concat(i2, " after the user interacts with the page").concat(r2 ? ", error: ".concat(r2.toString(), ".") : ".");
      }, DEVICE_ABORT_ERROR(e2) {
        let { fnName: t2, deviceType: i2 = KL(t2), error: r2 } = e2;
        return "AbortError, an unknown exception in the system makes the device unusable, recommended to change the device or browser and re-check whether the device is normal".concat(r2 ? " error: ".concat(r2.toString(), ".") : ".");
      }, CAMERA_RECOVER_FAILED(e2) {
        let { error: t2 } = e2;
        return "camera recover capture failed ".concat((null == t2 ? void 0 : t2.name) || "", ": ").concat((null == t2 ? void 0 : t2.originMessage) || (null == t2 ? void 0 : t2.message));
      }, MICROPHONE_RECOVER_FAILED(e2) {
        let { error: t2 } = e2;
        return "microphone recover capture failed ".concat((null == t2 ? void 0 : t2.name) || "", ": ").concat((null == t2 ? void 0 : t2.originMessage) || (null == t2 ? void 0 : t2.message));
      }, OPERATION_FAILED(e2) {
        let { fnName: t2, error: i2 } = e2;
        return "'".concat(t2, "' failed, reason: ").concat(null == i2 ? void 0 : i2.toString());
      }, FIREWALL_RESTRICTION: () => "media connection failure due to firewall restrictions, please try to change your network.", EVENT_HANDLER_ERROR(e2) {
        let { eventName: t2 } = e2;
        return "an error was caught on trtc.on('".concat(t2, "', handler), please check your code on 'handler'.");
      }, VIDEO_CONTEXT_ERROR(e2) {
        let { reason: t2, error: i2 } = e2;
        return "video context error ".concat(t2, " ").concat((null == i2 ? void 0 : i2.name) || "", " ").concat((null == i2 ? void 0 : i2.message) || "");
      }, SERVER_ERROR(e2) {
        let { fnName: t2, error: i2 } = e2;
        return "'".concat(t2, "' got server error: ").concat(null == i2 ? void 0 : i2.toString(), ", please check the SDK documentation.");
      }, NEED_TO_BUY(e2) {
        let { value: t2, url: i2 } = e2;
        return "You need to buy packages for ".concat(t2, ". Refer to: ").concat(i2);
      }, ACCOUNT_NO_MONEY: (e2) => {
        let { fnParams: t2 } = e2;
        return "your TRTC account run out of credit, please recharge.".concat(t2.sdkAppId ? " SDKAppId: ".concat(t2.sdkAppId) : "");
      }, OPERATION_ABORT(e2) {
        let { fnName: t2 } = e2;
        return "'".concat(t2, "' abort");
      }, UNKNOWN_ERROR(e2) {
        let { fnName: t2, error: i2 } = e2;
        return "'".concat(t2, "' throw unknown exception").concat(i2 ? ", error: ".concat(i2.toString(), ".") : ".");
      } });
      function KL(e2) {
        if (!e2)
          return "camera";
        let t2 = e2.toLowerCase();
        return t2.includes("screen") ? "screen share" : t2.includes("audio") ? "microphone" : "camera";
      }
      var zL = class extends Error {
        constructor(e2) {
          let { code: t2, extraCode: i2, message: r2 = "", messageParams: n2, fnName: o2 = "", originError: s2 } = e2;
          var a2;
          let c2;
          c2 = r2 || function(e3) {
            let t3, { code: i3, params: r3, enableDocLink: n3 = false } = e3, s3 = "", a3 = WL[i3];
            try {
              t3 = JL[a3];
            } catch (o3) {
              t3 = JL.UNKNOWN_ERROR;
            }
            return Pw(t3) ? s3 = t3(r3) : Lw(t3) && (s3 = t3), r3.fnName && !s3.includes(r3.fnName) && ("." !== s3[s3.length - 1] && (s3 += "."), s3 += " thrown from ".concat(r3.fnName, "()")), n3 && (s3 += " doc:"), s3;
          }({ code: i2 || t2, params: eb({ fnName: o2, error: s2 }, n2) }), super(c2), sb(this, "name", "RtcError"), sb(this, "code"), sb(this, "extraCode"), sb(this, "functionName"), sb(this, "message"), sb(this, "handler"), sb(this, "originError"), this.name = WL[t2], this.code = t2, this.extraCode = i2, this.functionName = o2, this.originError = s2, this.message = c2, 5302 === this.extraCode && (null == (a2 = this.originError) ? void 0 : a2.message.includes("system")) && (this.handler = () => {
            let e3 = document.createElement("a");
            oD ? e3.href = "ms-settings:privacy-".concat({ startLocalVideo: "webcam", startLocalAudio: "microphone" }[this.functionName]) : sD && (e3.href = "x-apple.systempreferences:com.apple.preference.security?Privacy_".concat({ startLocalVideo: "Camera", startLocalAudio: "Microphone", startScreenShare: "ScreenCapture" }[this.functionName])), e3.href.length > 0 && e3.click();
          });
        }
        static convertFrom(e2, t2, i2) {
          let r2 = e2;
          if (e2 instanceof vb) {
            let { stack: n2 } = e2, o2 = { code: GL.UNKNOWN_ERROR, fnName: t2, originError: e2 };
            switch (e2.getCode()) {
              case Sb.INVALID_PARAMETER:
                o2.code = GL.INVALID_PARAMETER, o2.message = e2.message;
                break;
              case Sb.INVALID_OPERATION:
                o2.code = GL.INVALID_OPERATION;
                break;
              case Sb.NOT_SUPPORTED:
              case Sb.NOT_SUPPORTED_H264:
                o2.code = GL.ENV_NOT_SUPPORTED, e2.getCode() === Sb.NOT_SUPPORTED_H264 && (o2.extraCode = e2.message.includes(hN.NOT_SUPPORTED_H264ENCODE) ? 5203 : 5204);
                break;
              case Sb.JOIN_ROOM_FAILED:
                o2.messageParams = { fnParams: i2 };
              case Sb.SERVER_TIMEOUT:
              case Sb.SWITCH_ROLE_FAILED:
                o2.code = GL.SERVER_ERROR, o2.extraCode = e2.getExtraCode();
                break;
              case Sb.API_CALL_ABORTED:
                o2.code = GL.OPERATION_ABORT;
                break;
              case Sb.DEVICE_NOT_FOUND:
              case Sb.DEVICE_AUTO_RECOVER_FAILED:
              case Sb.INITIALIZE_FAILED:
                o2.code = 5300, e2.name && (o2.extraCode = function(e3) {
                  let t3;
                  switch (e3) {
                    case "NotFoundError":
                      t3 = 5301;
                      break;
                    case "NotAllowedError":
                      t3 = 5302;
                      break;
                    case "NotReadableError":
                      t3 = 5303;
                      break;
                    case "OverconstrainedError":
                      t3 = 5304;
                      break;
                    case "InvalidStateError":
                      t3 = 5305;
                      break;
                    case "SecurityError":
                      t3 = 5306;
                      break;
                    case "AbortError":
                      t3 = 5307;
                      break;
                    default:
                      t3 = 5300;
                  }
                  return t3;
                }(e2.name));
                break;
              case Sb.UNKNOWN:
                break;
              default:
                o2.code = GL.OPERATION_FAILED;
            }
            r2 = new zL(o2), n2 && (r2.stack += n2.substr(n2.indexOf("\n")));
          } else {
            if (e2 instanceof zL)
              return e2;
            r2 = new zL({ code: GL.UNKNOWN_ERROR, fnName: t2, originError: e2 });
          }
          return r2;
        }
      };
      var qL = zL, YL = { type: "object", properties: { cameraId: { type: "string" }, useFrontCamera: { type: "boolean" }, fillMode: { type: "string", values: ["contain", "cover", "fill"] }, mirror: { type: ["string", "boolean"], values: [true, false, "view", "publish", "both"] }, small: { properties: { width: { type: "number" }, height: { type: "number" }, frameRate: { type: "number" }, bitrate: { type: "number" } } }, videoTrack: { instanceOf: MediaStreamTrack } } }, QL = { type: "object", properties: { systemAudio: { type: "boolean" }, fillMode: { type: "string", values: ["contain", "cover", "fill"] }, profile: { type: ["string", "object"], properties: { width: { type: "number" }, height: { type: "number" }, frameRate: { type: "number" }, bitrate: { type: "number" } } }, videoTrack: { instanceOf: MediaStreamTrack }, audioTrack: { instanceOf: MediaStreamTrack } } }, XL = { type: ["string", HTMLElement, null, "array"], arrayItem: { instanceOf: HTMLElement }, validate(e2, t2, i2) {
        if (Lw(e2) && !document.getElementById(e2))
          throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5009, fnName: i2, messageParams: { key: t2 } });
      } }, $L = { name: "userId", required: true, type: "string" }, ZL = { type: "object", properties: { microphoneId: { type: "string" }, audioTrack: { instanceOf: MediaStreamTrack }, captureVolume: { type: "number", min: 0 }, earMonitorVolume: { type: "number", min: 0, max: 100 }, profile: { values: [jL.AUDIO_PROFILE_STANDARD, jL.AUDIO_PROFILE_STANDARD_STEREO, jL.AUDIO_PROFILE_HIGH, jL.AUDIO_PROFILE_HIGH_STEREO] }, echoCancellation: { type: "boolean" }, autoGainControl: { type: "boolean" }, noiseSuppression: { type: "boolean" } } };
      function ex(e2, t2) {
        if (!e2)
          throw new qL({ code: GL.INVALID_OPERATION, extraCode: 5101, fnName: t2 });
      }
      function tx(e2, t2, i2) {
        if (!e2)
          throw new qL({ code: GL.INVALID_OPERATION, extraCode: 5102, fnName: t2, messageParams: { value: i2 } });
      }
      var ix = { create: [{ name: "RoomConfig", instanceOf: Function }, { name: "CreateConfig", type: "object", properties: { plugins: { type: "array", arrayItem: { instanceOf: Function } } } }], enterRoom: { name: "EnterRoomConfig", type: "object", required: true, validate(e2, t2, i2) {
        if (this._room.isJoined)
          throw new qL({ code: GL.INVALID_OPERATION, extraCode: 5104, fnName: i2 });
        if (e2.roomId) {
          if (Lw(e2.roomId))
            throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5016, fnName: i2, messageParams: { key: t2 } });
          if (!(/^[1-9]\d*$/.test(String(e2.roomId)) && e2.roomId < 4294967295))
            throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5013, fnName: i2, messageParams: { key: t2 } });
        } else {
          if (!e2.strRoomId)
            throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5015, fnName: i2 });
          if (!/^[A-Za-z\d\s!#$%&()+\-:;<=.>?@[\]^_{}|~,]{1,64}$/.test(e2.strRoomId))
            throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5012, fnName: i2, messageParams: { key: t2 } });
        }
      }, properties: { sdkAppId: { required: true, type: "number", allowEmpty: false }, userId: { required: true, type: "string", allowEmpty: false }, userSig: { required: true, type: "string", allowEmpty: false }, scene: { type: "string", values: ["live", "rtc"] }, role: { type: "string", values: ["audience", "anchor"] }, roomId: { type: ["string", "number"] }, strRoomId: { type: "string" }, proxy: { type: ["object", "string"], properties: { websocketProxy: { type: "string" }, turnServer: { type: ["object", "array"], properties: { url: { required: true, type: "string" }, username: { type: "string" }, credential: { type: "string" }, credentialType: { type: "string", values: ["password"] } } }, loggerProxy: { type: "string" }, webtransportProxy: { type: "string" } } }, enableAutoPlayDialog: { type: "boolean" }, userDefineRecordId: { type: "string" } } }, startLocalVideo: { name: "LocalVideoConfig", type: "object", properties: { view: XL, mute: { type: ["boolean", "string"] }, publish: { type: "boolean" }, option: YL }, validate(e2) {
        var t2;
        if ((null == (t2 = null == e2 ? void 0 : e2.option) || !t2.videoTrack) && wO())
          throw new qL({ code: GL.ENV_NOT_SUPPORTED, extraCode: 5201 });
      } }, updateLocalVideo: { name: "updateLocalVideoConfig", type: "object", required: true, properties: { view: tb(eb({}, XL), { required: false }), publish: { type: "boolean" }, mute: { type: ["boolean", "string"] }, option: YL } }, startLocalAudio: { name: "LocalAudioConfig", type: "object", properties: { publish: { type: "boolean" }, option: ZL }, validate(e2) {
        var t2;
        if ((null == (t2 = null == e2 ? void 0 : e2.option) || !t2.audioTrack) && wO())
          throw new qL({ code: GL.ENV_NOT_SUPPORTED, extraCode: 5201 });
      } }, updateLocalAudio: { name: "updateLocalAudioConfig", type: "object", required: true, properties: { publish: { type: "boolean" }, mute: { type: "boolean" }, option: ZL } }, startScreenShare: { name: "ScreenShareConfig", type: "object", properties: { view: XL, publish: { type: "boolean" }, option: QL }, validate(e2, t2, i2, r2, n2) {
        var o2;
        if ((null == (o2 = null == e2 ? void 0 : e2.option) || !o2.videoTrack) && wO())
          throw new qL({ code: GL.ENV_NOT_SUPPORTED, extraCode: 5201 });
        if (!VO())
          throw new qL({ code: GL.ENV_NOT_SUPPORTED, fnName: i2, extraCode: 5205 });
      } }, updateScreenShare: { name: "updateScreenShareConfig", type: "object", required: true, properties: { view: XL, publish: { type: "boolean" }, option: QL } }, muteRemoteAudio: [$L, { name: "mute", required: true, type: "boolean" }], setRemoteAudioVolume: [$L, { name: "volume", required: true, type: "number", min: 0 }], startRemoteVideo: { name: "startRemoteVideoConfig", type: "object", required: true, properties: { view: XL, userId: { type: "string", required: true }, streamType: { values: ["main", "sub"], required: true }, option: { type: "object", properties: { fillMode: { type: "string", values: ["contain", "cover", "fill"] }, mirror: { type: "boolean" } } } }, validate(e2, t2, i2) {
        ex(this._room.isJoined, i2);
        let r2 = this._room.remotePublishedUserMap.get(e2.userId);
        if (tx(!!r2, i2, e2), r2 && ("main" === e2.streamType && !r2.muteState.videoAvailable || "sub" === e2.streamType && !r2.muteState.hasAuxiliary))
          throw new qL({ code: GL.INVALID_OPERATION, extraCode: 5103, fnName: i2, messageParams: { value: e2 } });
      } }, updateRemoteVideo: { name: "updateRemoteVideoConfig", type: "object", required: true, properties: { view: tb(eb({}, XL), { required: false }), userId: { type: "string", required: true }, streamType: { values: ["main", "sub"], required: true }, option: { type: "object", properties: { fillMode: { type: "string", values: ["contain", "cover", "fill"] }, mirror: { type: "boolean" } } } }, validate(e2, t2, i2) {
        ex(this._room.isJoined, i2);
        let r2 = this._room.remotePublishedUserMap.get(e2.userId);
        if (tx(!!r2, i2, e2), r2 && ("main" === e2.streamType && !r2.muteState.videoAvailable || "sub" === e2.streamType && !r2.muteState.hasAuxiliary))
          throw new qL({ code: GL.INVALID_OPERATION, extraCode: 5103, fnName: i2, messageParams: { value: e2 } });
      } }, stopRemoteVideo: { name: "stopRemoteVideoConfig", type: "object", required: true, properties: { userId: { type: "string", required: true }, streamType: { values: ["main", "sub"] } }, validate(e2, t2, i2) {
        if ("*" !== e2.userId && Mw(e2.streamType))
          throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5014, fnName: i2 });
      } }, switchRole: { name: "role", required: true, values: ["anchor", "audience"], validate(e2, t2, i2) {
        ex(this._room.isJoining || this._room.isJoined, i2);
      } }, enableAudioVolumeEvaluation: [{ name: "interval", type: "number" }, { name: "enableInBackground", type: "boolean" }], sendSEIMessage: [{ name: "buffer", required: true, instanceOf: ArrayBuffer, validate(e2, t2, i2, r2) {
        if (!iP)
          throw new qL({ code: GL.ENV_NOT_SUPPORTED, fnName: i2, extraCode: 5207 });
        if (!this._room.enableSEI)
          throw new qL({ code: GL.INVALID_OPERATION, messageParams: { key: uN.SEI_DISABLED } });
        if (e2.byteLength > 1e3)
          throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5018, fnName: i2 });
        if (0 === e2.byteLength)
          throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5017, messageParams: { key: t2 }, fnName: i2 });
        if (ex(this._room.isJoined, i2), !this._room.isMainStreamPublished)
          throw new qL({ code: GL.INVALID_PARAMETER, messageParams: { key: uN.SEI_BEFORE_PUBLISH } });
      } }, { name: "options", type: "object", properties: { seiPayloadType: { type: "number", values: [5, 243] } } }], sendCustomMessage: { name: "message", required: true, type: "object", properties: { cmdId: { type: "number", required: true, min: 1, max: 10 }, data: { instanceOf: ArrayBuffer, required: true, validate(e2, t2, i2, r2) {
        if (e2.byteLength > 1e3)
          throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5018, fnName: i2 });
        if (0 === e2.byteLength)
          throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5017, fnName: i2, messageParams: { key: t2 } });
      } } }, validate(e2, t2, i2) {
        if (ex(this._room.isJoined, i2), "live" === this._room.scene && "audience" === this._room.role)
          throw new qL({ code: GL.INVALID_OPERATION, extraCode: 5107, fnName: i2, messageParams: { key: t2 } });
      } } }, rx = { TRTC: ix }, nx = class extends Error {
      };
      function ox(e2, t2) {
        let i2 = iO(e2);
        for (let r2 = 0; r2 < t2.length; r2++)
          tO(i2[r2], t2[r2]);
        return i2;
      }
      function sx(e2) {
        this._resolve = Promise.resolve(e2);
      }
      function ax(e2) {
        this._reject = Promise.reject(e2);
      }
      var cx = class {
        constructor(e2, t2) {
          this.instance = e2, this.group = t2, this.started = false, this.ops = [], this.startSame = () => true, this.mergeUpdate = ox;
          let i2 = cx.instances.get(e2);
          i2 ? i2.set(t2, this) : cx.instances.set(e2, /* @__PURE__ */ new Map([[t2, this]]));
        }
        static get(e2, t2) {
          let i2 = cx.instances.get(e2);
          return i2 && i2.get(t2) || new cx(e2, t2);
        }
        action(e2, t2, i2) {
          let r2 = (t3) => {
            var i3;
            return 0 === e2 ? this.started = true : 3 === e2 && (this.started = false), this.ops.shift(), null == (i3 = this.currentOp) || i3.action(), t3;
          }, n2 = (t3) => {
            var i3, r3;
            throw this.ops.shift(), 0 === e2 && 2 === (null == (i3 = this.currentOp) ? void 0 : i3.type) && this.ops.shift().reject(new nx("start failed")), null == (r3 = this.currentOp) || r3.action(), t3;
          }, o2 = { type: e2, action: () => t2(...o2.args).then(r2, n2), args: i2, resolve: sx, reject: ax };
          try {
            switch (this.state) {
              case 1:
                if (0 === e2)
                  throw new nx("already started");
                break;
              case 4:
                if (2 === e2)
                  throw new nx("not started");
                break;
              default:
                return this.cacheOp(o2);
            }
          } catch (s2) {
            return Promise.reject(s2);
          }
          return this.ops.push(o2), o2.promise = t2(...o2.args).then(r2, n2);
        }
        cacheOp(e2) {
          if (1 === this.ops.length)
            switch (this.state) {
              case 0:
              case 2:
                if (0 === e2.type)
                  throw new nx("already start");
                break;
              case 3:
                switch (e2.type) {
                  case 2:
                    throw new nx("update not allowed when stopping");
                  case 3:
                    return this.currentOp.promise;
                }
                break;
              default:
                throw new nx("unknown state");
            }
          else
            switch (e2.type) {
              case 3:
                if (3 === this.lastOpType)
                  return this.lastOp.promise;
                {
                  let e3 = new nx("keep stop");
                  if (this.ops.slice(1).forEach((t3) => t3.reject(e3)), this.ops = this.ops.slice(0, 1), 3 === this.state)
                    return this.currentOp.promise;
                }
                break;
              case 2:
                switch (this.lastOpType) {
                  case 2:
                    return this.lastOp.args = this.mergeUpdate(this.lastOp.args, e2.args), this.lastOp.promise;
                  case 3:
                    throw new nx("update not allowed after stop");
                }
                break;
              case 0:
                switch (this.lastOpType) {
                  case 2:
                    throw new nx("start not allowed after update");
                  case 0:
                    throw new nx("duplicate start");
                  case 3:
                    if (this.startSame(this.currentOp.args, e2.args))
                      throw this.ops.pop().reject(new nx("keep start")), new nx("already start");
                }
            }
          e2.promise = new Promise((t3, i2) => {
            e2._resolve ? e2._resolve.then(t3) : e2.resolve = t3, e2._reject ? e2._reject.catch(i2) : e2.reject = i2;
          });
          let { action: t2 } = e2;
          return e2.action = () => t2().then(e2.resolve, e2.reject), this.ops.push(e2), e2.promise;
        }
        get lastOp() {
          return this.ops[this.ops.length - 1];
        }
        get lastOpType() {
          return this.lastOp.type;
        }
        get currentOp() {
          return this.ops[0];
        }
        get state() {
          return this.currentOp ? this.currentOp.type : this.started ? 1 : 4;
        }
      }, lx = cx;
      lx.instances = /* @__PURE__ */ new WeakMap();
      var dx = /* @__PURE__ */ new WeakMap(), ux = (e2, t2) => {
        if (t2 instanceof nx) {
          let { stack: i2 } = t2;
          t2 = new qL({ code: GL.OPERATION_ABORT, message: "".concat(e2, " abort: ").concat(t2.message), fnName: e2 }), i2 && (t2.stack += i2.substr(i2.indexOf("\n")));
        }
        throw t2;
      };
      function hx(e2, t2) {
        return XM((i2, r2) => function() {
          for (var n2 = arguments.length, o2 = new Array(n2), s2 = 0; s2 < n2; s2++)
            o2[s2] = arguments[s2];
          let a2 = lx.get(this, "string" == typeof e2 ? e2 : e2.call(this, ...o2));
          return t2 && (a2.startSame = t2.bind(this)), a2.action(0, i2.bind(this), o2).catch(ux.bind(null, r2));
        });
      }
      function px(e2, t2) {
        let { merge: i2, debounce: r2 } = t2 || {};
        return XM((t3, n2) => function() {
          for (var o2 = arguments.length, s2 = new Array(o2), a2 = 0; a2 < o2; a2++)
            s2[a2] = arguments[a2];
          let c2 = lx.get(this, "string" == typeof e2 ? e2 : e2.call(this, ...s2));
          if (i2 && (c2.mergeUpdate = i2.bind(this)), r2 && r2.isNeedToDebounce.apply(this, s2)) {
            let { delay: e3, getKey: i3 } = r2;
            return new Promise((r3, o3) => {
              var a3, l2;
              let d2 = null == (a3 = dx.get(this)) ? void 0 : a3.get(i3(...s2));
              if (d2) {
                let { timeoutId: e4, resolve: t4 } = d2;
                clearTimeout(e4), t4();
              }
              let u2 = setTimeout(() => {
                if (3 === c2.state || 4 === c2.state)
                  return r3();
                c2.action(2, t3.bind(this), s2).catch(ux.bind(null, n2)).then(r3, o3);
              }, e3);
              dx.has(this) ? null == (l2 = dx.get(this)) || l2.set(i3(...s2), { timeoutId: u2, resolve: r3 }) : dx.set(this, /* @__PURE__ */ new Map([[i3(...s2), { timeoutId: u2, resolve: r3 }]]));
            });
          }
          return c2.action(2, t3.bind(this), s2).catch(ux.bind(null, n2));
        });
      }
      function mx(e2) {
        return XM((t2, i2) => function() {
          for (var r2 = arguments.length, n2 = new Array(r2), o2 = 0; o2 < r2; o2++)
            n2[o2] = arguments[o2];
          return lx.get(this, "string" == typeof e2 ? e2 : e2.call(this, ...n2)).action(3, t2.bind(this), n2).catch(ux.bind(null, i2));
        });
      }
      var _x = { ERROR: "error", AUTOPLAY_FAILED: "autoplay-failed", KICKED_OUT: "kicked-out", REMOTE_USER_ENTER: "remote-user-enter", REMOTE_USER_EXIT: "remote-user-exit", REMOTE_AUDIO_AVAILABLE: "remote-audio-available", REMOTE_AUDIO_UNAVAILABLE: "remote-audio-unavailable", REMOTE_VIDEO_AVAILABLE: "remote-video-available", REMOTE_VIDEO_UNAVAILABLE: "remote-video-unavailable", AUDIO_VOLUME: "audio-volume", NETWORK_QUALITY: "network-quality", CONNECTION_STATE_CHANGED: "connection-state-changed", AUDIO_PLAY_STATE_CHANGED: "audio-play-state-changed", VIDEO_PLAY_STATE_CHANGED: "video-play-state-changed", SCREEN_SHARE_STOPPED: "screen-share-stopped", DEVICE_CHANGED: "device-changed", PUBLISH_STATE_CHANGED: "publish-state-changed", TRACK: "track", STATISTICS: "statistics", SEI_MESSAGE: "sei-message", CUSTOM_MESSAGE: "custom-message" };
      function fx(e2) {
        return "sub" === e2 ? "auxiliary" : "auxiliary" === e2 ? "sub" : "main";
      }
      function gx(e2) {
        return e2 === jL.QOS_PREFERENCE_CLEAR ? "detail" : e2 === jL.QOS_PREFERENCE_SMOOTH ? "motion" : "";
      }
      var Tx = /* @__PURE__ */ new WeakMap();
      function Ex() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
          t2[i2] = arguments[i2];
        return XM((e3, i3) => function() {
          for (var r2 = arguments.length, n2 = new Array(r2), o2 = 0; o2 < r2; o2++)
            n2[o2] = arguments[o2];
          try {
            Ix.call(this, t2, n2, i3, this._name);
          } catch (Ob2) {
            return Promise.reject(Ob2);
          }
          return e3.apply(this, n2);
        });
      }
      function Sx() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
          t2[i2] = arguments[i2];
        return XM((e3, i3) => function() {
          for (var r2 = arguments.length, n2 = new Array(r2), o2 = 0; o2 < r2; o2++)
            n2[o2] = arguments[o2];
          try {
            Ix.call(this, t2, n2, i3, this._name);
          } catch (Ob2) {
            throw Ob2;
          }
          return e3.apply(this, n2);
        });
      }
      function Ix(e2, t2, i2, r2) {
        if (Fw(e2))
          for (let n2 = 0; n2 < e2.length; n2++)
            vx.call(this, { rule: e2[n2], value: t2[n2], key: e2[n2].name, fnName: i2, className: r2 });
        else
          vx.call(this, { rule: e2, value: t2[0], key: e2.name, fnName: i2, className: r2 });
      }
      function vx(e2) {
        let { rule: t2, value: i2, key: r2, fnName: n2, className: o2 } = e2;
        function s2(e3) {
          return { code: GL.INVALID_PARAMETER, extraCode: e3, fnName: n2, messageParams: { key: r2, rule: t2, value: i2 } };
        }
        if (Mw(i2)) {
          if (t2.required)
            throw new qL(s2(5001));
          if (Mw(t2.defaultValue))
            return void (Pw(t2.validate) && t2.validate.call(this, i2, r2, n2, o2, this));
          i2 = t2.defaultValue;
        }
        if (Array.isArray(t2.type)) {
          let e3 = false;
          for (let r3 = 0; r3 < t2.type.length; r3++)
            null === t2.type[r3] && null === i2 && (e3 = true), Pw(t2.type[r3]) && i2 instanceof t2.type[r3] && (e3 = true), Lw(t2.type[r3]) && Ow(i2) === t2.type[r3].toLowerCase() && (e3 = true);
          if (!e3)
            throw new qL({ code: GL.INVALID_PARAMETER, extraCode: 5002, fnName: n2, messageParams: { key: r2, rule: { type: t2.type.map((e4) => Gw(e4) ? Ww(e4) : Lw(e4) ? e4 : Ow(e4)) }, value: i2 } });
        } else if (!Mw(t2.type) && Ow(i2) !== t2.type)
          throw new qL(s2(5002));
        if (false === t2.allowEmpty) {
          let e3 = xw(i2) && (0 === i2 || Number.isNaN(i2)), t3 = Lw(i2) && "" === i2.trim();
          if (e3 || t3)
            throw new qL(s2(5003));
        }
        if (t2.notLessThanZero && xw(i2) && i2 < 0)
          throw new qL(s2(5006));
        if (!Mw(t2.min) && xw(i2) && i2 < t2.min)
          throw new qL(s2(5007));
        if (!Mw(t2.max) && xw(i2) && i2 > t2.max)
          throw new qL(s2(5008));
        if (Lw(t2.instanceOf)) {
          if (!i2 || i2._name !== t2.instanceOf)
            throw new qL(s2(5004));
        } else if (Pw(t2.instanceOf) && !(i2 instanceof t2.instanceOf))
          throw new qL(s2(5004));
        if (Array.isArray(t2.values) && !t2.values.includes(i2))
          throw new qL(s2(5005));
        let { properties: a2 } = t2;
        Nw(a2) && Uw(i2) && Object.keys(a2).forEach((e3) => {
          vx.call(this, { rule: a2[e3], value: i2 && i2[e3], key: "".concat(e3), fnName: n2, className: o2 });
        });
        let { arrayItem: c2 } = t2;
        Nw(c2) && Fw(i2) && i2.forEach((e3, t3) => {
          vx.call(this, { rule: c2, value: e3, key: "".concat(r2, "[").concat(t3, "]"), fnName: n2, className: o2 });
        }), Pw(t2.validate) && t2.validate.call(this, i2, r2, n2, o2, this);
      }
      function yx() {
        let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { getRemoteId: t2 = () => "", replaceArg: i2, getKVReportKey: r2 } = e2;
        return XM((e3, n2) => function() {
          for (var o2 = arguments.length, s2 = new Array(o2), a2 = 0; a2 < o2; a2++)
            s2[a2] = arguments[a2];
          function c2(e4, t3, r3) {
            if (r3 && r3.includes(e4))
              return "hided";
            if (i2) {
              let e5 = i2(...s2);
              if (s2[e5.argIndex] === t3)
                return e5.value;
            }
            if (t3 === s2 || e4 in s2)
              return t3;
            try {
              return t3 instanceof HTMLElement ? "id: ".concat(t3.id, " type:").concat(Ow(t3)) : (JSON.stringify(t3), t3);
            } catch (n3) {
              return "type:".concat(Ow(t3));
            }
          }
          let l2 = this._log || EO;
          s2.length > 0 ? l2.info("".concat(n2, "() ").concat(JSON.stringify(s2, (e4, t3) => c2(e4, t3, ["userSig", "privateMapKey"])))) : l2.info("".concat(n2, "()"));
          let d2 = r2 ? r2(...s2) : sM[n2];
          try {
            let i3 = e3.apply(this, s2), r3 = zw();
            return jw(i3) ? i3.then((e4) => (l2.info("".concat(n2, "() success ").concat(t2.call(this, ...s2))), mM.addSuccessEvent({ key: d2, cost: zw() - r3 }), e4)).catch((e4) => {
              throw e4 = qL.convertFrom.call(this, e4, n2, 1 === s2.length ? s2[0] : s2), l2.error("".concat(n2, "() failed ").concat(t2.call(this, ...s2), " ").concat(e4, " params: ").concat(JSON.stringify(s2, c2))), mM.addFailedEvent({ key: d2, error: e4 }), e4;
            }) : (mM.addSuccessEvent({ key: d2 }), i3);
          } catch (u2) {
            throw u2 = qL.convertFrom.call(this, u2, n2), l2.error("".concat(n2, "() failed ").concat(u2, " params: ").concat(JSON.stringify(s2, c2))), mM.addFailedEvent({ key: d2, error: u2 }), u2;
          }
        });
      }
      var Ax = (e2) => XM((t2, i2) => function(r2, n2) {
        return cb(this, null, function* () {
          let o2 = this._plugins.get(r2);
          if (!o2)
            throw this._log.error("plugin ".concat(String(r2), " is not found")), new qL({ code: GL.OPERATION_ABORT, message: "plugin ".concat(String(r2), " is not found"), fnName: i2 });
          return Ix.call(this, o2.getValidateRule(e2), [n2], i2, "TRTC"), t2.call(this, o2, n2);
        });
      }), Rx = 0, Cx = class {
        constructor(e2, t2) {
          sb(this, "player"), sb(this, "publisher"), sb(this, "mixInput"), this.mixInput = new TM(t2), e2.url ? (this.player = new Audio(e2.url), this.player.crossOrigin = "anonymous", this.publisher = new Audio(e2.url), this.publisher.crossOrigin = "anonymous", this.mixInput.replaceSource(this.publisher)) : this.mixInput.replaceSource(e2.track), e2.loop && (this.loop = e2.loop), e2.volume && (this.volume = e2.volume), this.mixInput.connect();
        }
        reset() {
          this.seek(0), this.mixInput.connect();
        }
        seek(e2) {
          !this.player || e2 < 0 && e2 > this.player.duration || (this.player.currentTime = e2, this.publisher.currentTime = e2);
        }
        play() {
          var e2, t2;
          return null == (e2 = this.publisher) || e2.play(), null == (t2 = this.player) ? void 0 : t2.play();
        }
        pause() {
          var e2, t2;
          null == (e2 = this.player) || e2.pause(), null == (t2 = this.publisher) || t2.pause();
        }
        stop() {
          var e2;
          null == (e2 = this.player) || e2.pause(), this.mixInput.disconnect();
        }
        setOperation(e2) {
          "pause" === e2 && this.pause(), "resume" === e2 && (this.pause(), this.play()), "stop" === e2 && (this.pause(), this.seek(0));
        }
        set volume(e2) {
          !this.player || !this.publisher || (this.player.volume = e2, this.publisher.volume = e2);
        }
        set loop(e2) {
          !this.player || !this.publisher || (this.player.loop = e2, this.publisher.loop = e2);
        }
      }, bx = class {
        constructor(e2) {
          this.core = e2, sb(this, "log"), sb(this, "mixedMusicMap", /* @__PURE__ */ new Map()), sb(this, "cacheMusicMap", /* @__PURE__ */ new Map()), Rx += 1, this.log = e2.log.createChild({ id: "".concat(this.getAlias()).concat(Rx) }), this.log.info("[audioMixer] created id=".concat(this.getAlias()).concat(Rx)), this.core = e2;
        }
        getName() {
          return bx.Name;
        }
        getAlias() {
          return "ax";
        }
        getGroup(e2) {
          return null == e2 ? void 0 : e2.id;
        }
        getValidateRule(e2) {
          switch (e2) {
            case "start":
              return bx.startValidateRule;
            case "update":
              return bx.updateValidateRule;
            case "stop":
              return bx.stopValidateRule;
          }
        }
        start(e2) {
          return cb(this, null, function* () {
            let { room: t2 } = this.core;
            this.log.info("add music source, id: ".concat(e2.id, " url: ").concat(e2.url, ", track: ").concat(e2.track));
            let { id: i2, url: r2 } = e2;
            if (this.mixedMusicMap.has(i2))
              return;
            let n2 = this.cacheMusicMap.get(i2);
            n2 ? e2.url ? n2.reset() : (n2.mixInput.replaceSource(e2.track), n2.mixInput.connect()) : (n2 = new Cx(e2, t2.audioManager), this.cacheMusicMap.set(i2, n2)), yield n2.play(), this.mixedMusicMap.set(i2, n2), this.log.info("start mix audio track ".concat(i2, " success.")), mM.addEnum({ key: 502700, value: 3 });
          });
        }
        update(e2) {
          return cb(this, null, function* () {
            let { id: t2, volume: i2, loop: r2, operation: n2, seekFrom: o2 } = e2;
            this.log.info("update music source, ".concat(JSON.stringify(e2)));
            let s2 = this.mixedMusicMap.get(t2);
            s2 ? (Mw(i2) || (s2.volume = i2), Mw(r2) || (s2.loop = r2), Mw(n2) || s2.setOperation(n2), Mw(o2) || s2.seek(o2)) : this.log.warn("update music source failed, music id: ".concat(t2, " not found."));
          });
        }
        stop(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { id: i2 } = e3;
            return function* () {
              var e4;
              t2.mixedMusicMap.has(i2) && (t2.log.info("remove music source, music id: ".concat(i2)), null == (e4 = t2.mixedMusicMap.get(i2)) || e4.stop(), t2.mixedMusicMap.delete(i2)), "*" === i2 && t2.destroyAllMusic();
            }();
          });
        }
        destroyAllMusic() {
          this.log.info("destroy all music source."), this.mixedMusicMap.forEach((e2, t2) => this.stop({ id: t2 }));
        }
        destroyAllCache() {
          this.log.info("destroy all music cache."), this.cacheMusicMap.clear();
        }
        destroy() {
          this.log.info("destroy audio mixer plugin."), this.destroyAllMusic(), this.destroyAllCache();
        }
      }, kx = bx;
      sb(kx, "startValidateRule", { name: "options", required: true, type: "object", properties: { id: { type: "string", required: true }, url: { type: "string", required: false }, track: { required: false }, loop: { type: "boolean" }, volume: { type: "number" } }, validate(e2, t2, i2) {
        if (e2.url && "*" !== e2.url) {
          let t3 = e2.url.split("?")[0], r2 = ["mp3", "ogg", "wav", "flac"], n2 = t3.split(".").pop(), o2 = r2.indexOf(n2) >= 0, s2 = t3.startsWith("blob"), a2 = t3.startsWith("data");
          if (!(o2 || s2 || a2))
            throw new qL({ code: GL.INVALID_PARAMETER, message: "start audioMixer plugin: music url is invalid, please check your file format.", fnName: i2 });
        }
        if (!e2.url && !e2.track)
          throw new qL({ code: GL.INVALID_PARAMETER, message: "start audioMixer plugin: param url or track is required.", fnName: i2 });
      } }), sb(kx, "updateValidateRule", { name: "options", required: true, type: "object", properties: { id: { type: "string", required: true }, loop: { type: "boolean" }, volume: { type: "number" }, seekFrom: { type: "number" }, operation: { type: "string", values: ["pause", "resume", "stop"] } } }), sb(kx, "stopValidateRule", { name: "options", type: "object", required: true, properties: { id: { type: "string", required: true } } }), sb(kx, "Name", "AudioMixer");
      var Nx = (e2) => (e2 = Number(e2)) > 0 && e2 < 14e8, Dx = 0, wx = class {
        constructor(e2) {
          this.core = e2, sb(this, "log"), sb(this, "workletReady"), sb(this, "audioContext", nM()), sb(this, "workletNode"), Dx += 1, this.log = e2.log.createChild({ id: "".concat(this.getAlias()).concat(Dx) }), this.log.info("[audioDenoiser] created id=".concat(this.getAlias()).concat(Dx)), e2.assetsPath && (this.workletReady = $P(this.audioContext, "".concat(e2.assetsPath, "/denoiser-wasm.js")), this.workletReady.catch((t2) => {
            this.log.error("Init assets from ".concat(e2.assetsPath, " failed! Reason: ").concat(t2));
          }));
        }
        static startValidateRule(e2) {
          return { name: "options", required: true, type: "object", properties: { sdkAppId: { type: "number", required: true }, userId: { type: "string", required: true }, userSig: { type: "string", required: true } }, validate(t2, i2, r2, n2) {
            if (!e2.room.audioManager.hasAudioTrack)
              throw new qL({ code: GL.INVALID_OPERATION, extraCode: 5106, fnName: r2 });
          } };
        }
        getName() {
          return wx.Name;
        }
        getAlias() {
          return "ad";
        }
        getGroup() {
          return "AIDenoiser_".concat(Date.now());
        }
        getValidateRule(e2) {
          switch (e2) {
            case "start":
              return wx.startValidateRule(this.core);
            case "update":
              return wx.updateValidateRule;
            case "stop":
              return wx.stopValidateRule;
          }
        }
        start(e2) {
          return cb(this, null, function* () {
            let { room: t2 } = this.core;
            if (this.workletReady || (this.workletReady = $P(this.audioContext, "".concat(e2.assetsPath, "/denoiser-wasm.js")), this.workletReady.catch((t3) => {
              this.log.error("Init assets from ".concat(e2.assetsPath, " failed! Reason: ").concat(t3));
            })), !this.workletNode) {
              let t3 = String(Date.now()).slice(0, -3), { auth: i2, sign: r2, status: n2, message: o2 } = yield function(e3) {
                return cb(this, arguments, function(e4) {
                  let { sdkAppId: t4, userId: i3, userSig: r3, timestamp: n3 } = e4;
                  return function* () {
                    let e5 = "https://".concat(function(e6) {
                      let t5;
                      return t5 = Nx(e6) ? Px.MAIN_OVERSEA : Px.MAIN, t5;
                    }(t4), "/api/v1/audioAiAuth?sdkAppId=").concat(t4, "&userId=").concat(i3, "&userSig=").concat(r3, "&timestamp=").concat(n3), o3 = yield fetch(e5), { data: { errCode: s2, errMsg: a2, sign: c2, status: l2 } } = yield o3.json();
                    if ("1" === l2)
                      return { auth: true, sign: c2, status: l2, message: a2 };
                    let d2 = "Init RTCAIDenoiser failed.", u2 = "";
                    switch (s2) {
                      case 1:
                        u2 = "Please check your params.";
                        break;
                      case 2:
                        u2 = "You need to buy packages. Refer to: https://cloud.tencent.com/document/product/647/44247";
                        break;
                      case 3:
                        u2 = "Server is invalid. Please contact our engineer. ";
                        break;
                      case 4:
                        u2 = "Your packages is not active. Refer to: https://cloud.tencent.com/document/product/647/44247";
                        break;
                      case 5:
                        u2 = "Your packages is expired. Refer to: https://cloud.tencent.com/document/product/647/44247";
                        break;
                      case 6:
                        u2 = "Your version is not supported.";
                    }
                    return { auth: false, status: l2, message: a2 ? "".concat(d2, " Reason: ").concat(a2, ". ").concat(u2) : "".concat(d2, ", ").concat(u2) };
                  }();
                });
              }(tb(eb({}, e2), { timestamp: t3 }));
              if (!i2)
                throw this.log.info("RTCAIDenoiser: ".concat(e2.userId, " auth result: ").concat(i2, ". Message: ").concat(o2)), new qL({ code: GL.INVALID_PARAMETER, message: o2 });
              yield this.workletReady, this.workletNode = new AudioWorkletNode(this.audioContext, "trtc-denoiser-processor", { numberOfInputs: 1, numberOfOutputs: 1 }), this.workletNode.port.postMessage({ type: "init", data: { sdkAppId: String(e2.sdkAppId), userId: e2.userId, timestamp: t3, sign: r2, status: n2 } }), this.workletNode.port.onmessage = (e3) => {
                let { data: t4 } = e3;
                "cost" === t4.type && this.log.debug("[RTCAIDenoiser] ".concat(t4.value));
              };
            }
            this.workletNode.port.postMessage({ type: "enable" }), t2.audioManager.addDenoiser(this.workletNode), t2.sendAbilityStatus({ ai_denoise: 1 });
          });
        }
        update() {
          return cb(this, null, function* () {
          });
        }
        stop() {
          return cb(this, null, function* () {
            if (!this.workletNode)
              return;
            let { room: e2 } = this.core;
            this.workletNode.port.postMessage({ type: "disable" }), yield e2.audioManager.removeDenoiser(this.workletNode);
          });
        }
        destroy() {
        }
      }, Ox = wx;
      sb(Ox, "updateValidateRule", { type: "object" }), sb(Ox, "stopValidateRule", { type: "object" }), sb(Ox, "Name", "AIDenoiser");
      var Px = { MAIN: "schedule.cloud-rtc.com", MAIN_OVERSEA: "schedule.rtc.tencentcloud.com" };
      var Mx = 0, Lx = /* @__PURE__ */ new Set(), xx = null;
      Db("5.6.1");
      var Vx = { RtcError: qL, ErrorCode: GL, ErrorCodeDictionary: WL }, Ux = class extends Tb.EventEmitter {
        constructor(e2, t2) {
          super(), sb(this, "_room"), sb(this, "_eventListened", /* @__PURE__ */ new Set()), sb(this, "_localVideoTrack", null), sb(this, "_localAudioTrack", null), sb(this, "_localScreenTrack", null), sb(this, "_localScreenAudioTrack", null), sb(this, "_localVideoConfig", null), sb(this, "_localScreenConfig", null), sb(this, "_localAudioConfig", null), sb(this, "_remoteVideoConfigMap", /* @__PURE__ */ new Map()), sb(this, "_remoteAudioConfigMap", /* @__PURE__ */ new Map()), sb(this, "_remoteAudioMuteMap", /* @__PURE__ */ new Map()), sb(this, "_mediaTrackMap", /* @__PURE__ */ new WeakMap()), sb(this, "_log", EO.createLogger({ id: "t".concat(++Mx) })), sb(this, "_plugins", /* @__PURE__ */ new Map()), sb(this, "_networkQuality", null), sb(this, "_speakerId"), this._room = new e2(eb({ logger: this._log, frameWorkType: Ux.frameWorkType }, t2)), this._log.debug(JSON.stringify(t2)), Object.defineProperties(this, { dumpAudio: { enumerable: false, value(e3) {
            return this._room.audioManager.dump(e3);
          } } }), t2.plugins && t2.plugins.forEach((e3) => {
            this._use(e3, t2.assetsPath);
          }), this._use(kx, t2.assetsPath), this._use(Ox, t2.assetsPath), this._room.on("audio-volume", (e3) => {
            !e3.find((e4) => "" === e4.userId) && this._localAudioTrack && e3.push({ userId: "", volume: Math.floor(100 * this._localAudioTrack.getAudioLevel()) }), this.emit(_x.AUDIO_VOLUME, { result: e3.sort((e4, t3) => t3.volume - e4.volume) });
          }), this._room.videoManager.on("error", (e3) => {
            let { reason: t3, error: i2 } = e3;
            this._log.error(new qL({ code: GL.OPERATION_FAILED, extraCode: 5504, messageParams: { reason: t3, error: i2 } }));
          }), this._listenEvents(), this._initActiveSpeaker(), ((e3, t3) => {
            let { emit: i2 } = e3;
            e3.emit = function() {
              for (var r2 = arguments.length, n2 = new Array(r2), o2 = 0; o2 < r2; o2++)
                n2[o2] = arguments[o2];
              try {
                return i2.apply(e3, n2);
              } catch (Ob2) {
                let i3 = XD({ key: uN.CATCH_HANDLER_ERROR, data: { name: t3, event: n2[0] }, addDocLink: false });
                return EO.warn("".concat(i3, "\n\n").concat(Ob2.stack)), false;
              }
            };
          })(this, "trtc");
        }
        static create(e2) {
        }
        static _create(e2, t2) {
          var i2;
          HL && (HL = false, 5 !== EO.getLogLevel() && (console.info("******************************************************************************"), console.info("*   TRTC Web SDK"), console.info("*   API Document: ".concat(Gb, "/en/index.html")), console.info("*   Changelog: ".concat(Gb, "/en/tutorial-01-info-changelog.html")), console.info("*   Report issues: https://github.com/LiteAVSDK/TRTC_Web/issues"), console.info("******************************************************************************")), EO.info("TRTC Web SDK Version:", Nb), EO.info("UA:", navigator.userAgent), EO.info("URL: ".concat(location.href).concat("IFRAME" === (null == (i2 = self.frameElement) ? void 0 : i2.tagName) ? " in iframe" : "")), GD().then((e3) => {
            if (e3) {
              let t3 = "UAData: ".concat(e3.platform, "/").concat(e3.platformVersion);
              e3.architecture && e3.bitness && (t3 += " ".concat(e3.architecture, "/").concat(e3.bitness)), e3.mobile && (t3 += " mobile"), e3.model && (t3 += " model: ".concat(e3.model)), e3.fullVersionList && (t3 += " ".concat(e3.fullVersionList.filter((e4) => "Not/A)Brand" !== e4.brand).map((e4) => "".concat(e4.brand, "/").concat(e4.version)).join(","))), EO.info(t3);
            }
          }));
          let r2 = new Ux(e2, t2 || {});
          return Lx.add(r2), r2;
        }
        _listenEvents() {
          bP(this, this._room).add("peer-join", (e2) => {
            let { userId: t2 } = e2;
            this.emit(_x.REMOTE_USER_ENTER, { userId: t2 });
          }).add("peer-leave", (e2) => {
            this.emit(_x.REMOTE_USER_EXIT, { userId: e2 });
          }).add("banned", (e2) => {
            this._exitRoom().then(() => {
              this.emit(_x.KICKED_OUT, { reason: e2.reason });
            });
          }).add("error", (e2) => {
            this._exitRoom().then(() => {
              this.emit(_x.ERROR, qL.convertFrom(e2));
            });
          }).add("signal-connection-state-changed", (e2) => {
            this.emit(_x.CONNECTION_STATE_CHANGED, e2);
          }).add("network-quality", (e2) => {
            this._networkQuality = e2, this.emit(_x.NETWORK_QUALITY, e2);
          }).add("remote-published", (e2) => {
            [e2.remoteAudioTrack, e2.remoteVideoTrack, e2.remoteAuxiliaryTrack].forEach((t2) => {
              bP(t2, t2).add("player-state-changed", (i2) => {
                let r2 = tb(eb({}, i2), { userId: e2.userId });
                t2.kind === ok.VIDEO && (r2.streamType = fx(t2.streamType)), this.emit(t2.kind === ok.AUDIO ? _x.AUDIO_PLAY_STATE_CHANGED : _x.VIDEO_PLAY_STATE_CHANGED, r2);
              }).add("error", (e3) => {
                e3.getCode() === Sb.PLAY_NOT_ALLOWED && this.emit(_x.AUTOPLAY_FAILED, { userId: t2.userId });
              });
            });
          }).add("remote-unpublished", (e2) => {
            [e2.remoteAudioTrack, e2.remoteVideoTrack, e2.remoteAuxiliaryTrack].forEach((e3) => {
              kP(e3);
            });
          }).add("remote-publish-state-changed", (e2) => {
            let { prevMuteState: t2, muteState: i2 } = e2, { userId: r2 } = i2, n2 = t2.audioAvailable, o2 = t2.videoAvailable, { audioAvailable: s2, videoAvailable: a2 } = i2;
            s2 || this._remoteAudioConfigMap.delete(r2), a2 || this._remoteVideoConfigMap.delete("".concat(r2, "_", "main")), i2.hasAuxiliary || this._remoteVideoConfigMap.delete("".concat(r2, "_", "sub")), n2 !== s2 && (this.emit(s2 ? _x.REMOTE_AUDIO_AVAILABLE : _x.REMOTE_AUDIO_UNAVAILABLE, { userId: r2 }), s2 ? this._onAudioAvailable({ userId: r2 }) : this._onAudioUnavailable({ userId: r2, muteState: i2 })), o2 !== a2 && (this.emit(a2 ? _x.REMOTE_VIDEO_AVAILABLE : _x.REMOTE_VIDEO_UNAVAILABLE, { userId: r2, streamType: "main" }), a2 ? this._onVideoAvailable({ userId: r2, streamType: "main" }) : this._onVideoUnavailable({ userId: r2, streamType: "main" })), t2.hasAuxiliary !== i2.hasAuxiliary && (this.emit(i2.hasAuxiliary ? _x.REMOTE_VIDEO_AVAILABLE : _x.REMOTE_VIDEO_UNAVAILABLE, { userId: r2, streamType: "sub" }), i2.hasAuxiliary ? this._onVideoAvailable({ userId: r2, streamType: "sub" }) : this._onVideoUnavailable({ userId: r2, streamType: "sub" }));
          }).add("firewall-restriction", () => {
            this.emit(_x.ERROR, new qL({ code: GL.OPERATION_FAILED, extraCode: 5501 }));
          }).add("sei-message", (e2) => {
            this.emit(_x.SEI_MESSAGE, tb(eb({}, e2), { streamType: fx(e2.streamType) }));
          }).add("heartbeat-report", (e2) => {
            var t2, i2, r2, n2, o2, s2, a2;
            let c2 = { 2: "big", 3: "small", 7: "sub" }, l2 = { rtt: e2.msg_up_stream_info.msg_network_status.uint32_rtt || (null == (t2 = e2.msg_down_stream_info[0]) ? void 0 : t2.msg_network_status.uint32_rtt) || (null == (i2 = this._networkQuality) ? void 0 : i2.uplinkRTT) || (null == (r2 = this._networkQuality) ? void 0 : r2.downlinkRTT) || 0, upLoss: (null == (n2 = this._networkQuality) ? void 0 : n2.uplinkLoss) || 0, downLoss: (null == (o2 = this._networkQuality) ? void 0 : o2.downlinkLoss) || 0, bytesSent: e2.bytes_sent || 0, bytesReceived: e2.bytes_received || 0, localStatistics: { audio: { bitrate: ((null == (s2 = e2.msg_up_stream_info.msg_audio_status) ? void 0 : s2.uint32_audio_codec_bitrate) || 0) / 1e3, audioLevel: ((null == (a2 = e2.msg_up_stream_info.msg_audio_status) ? void 0 : a2.uint32_audio_level) || 0) / dN }, video: e2.msg_up_stream_info.msg_video_status.filter((e3) => c2[e3.uint32_video_stream_type]).map((e3) => ({ bitrate: (e3.uint32_video_codec_bitrate || 0) / 1e3, width: e3.uint32_video_width, height: e3.uint32_video_height, frameRate: e3.uint32_video_enc_fps, videoType: c2[e3.uint32_video_stream_type] })) }, remoteStatistics: e2.msg_down_stream_info.map((e3) => ({ userId: e3.msg_user_info.str_identifier, audio: { bitrate: (e3.msg_audio_status.uint32_audio_codec_bitrate || 0) / 1e3, audioLevel: (e3.msg_audio_status.uint32_audio_level || 0) / dN }, video: e3.msg_video_status.map((e4) => ({ bitrate: (e4.uint32_video_codec_bitrate || 0) / 1e3, width: e4.uint32_video_width, height: e4.uint32_video_height, frameRate: e4.uint32_video_dec_fps, videoType: c2[e4.uint32_video_stream_type] })) })) };
            this.emit(_x.STATISTICS, l2);
          }).add("custom-message", (e2) => {
            this.emit(_x.CUSTOM_MESSAGE, e2);
          }), bP(this, kM).add("audioInputAdded", (e2) => {
            this.emit(_x.DEVICE_CHANGED, { type: "microphone", action: "add", device: e2 });
          }).add("audioInputRemoved", (e2) => {
            this.emit(_x.DEVICE_CHANGED, { type: "microphone", action: "remove", device: e2 });
          }).add("videoInputAdded", (e2) => {
            this.emit(_x.DEVICE_CHANGED, { type: "camera", action: "add", device: e2 });
          }).add("videoInputRemoved", (e2) => {
            this.emit(_x.DEVICE_CHANGED, { type: "camera", action: "remove", device: e2 });
          }).add("audioOutputAdded", (e2) => cb(this, null, function* () {
            if (this.emit(_x.DEVICE_CHANGED, { type: "speaker", action: "add", device: e2 }), xx && xx.deviceId === Xk) {
              let e3 = (yield MM()).find((e4) => e4.deviceId === Xk);
              e3 && xx.groupId !== e3.groupId && (xx = e3, this.emit(_x.DEVICE_CHANGED, { type: "speaker", action: "active", device: e3 }));
            }
          })).add("audioOutputRemoved", (e2) => cb(this, null, function* () {
            this.emit(_x.DEVICE_CHANGED, { type: "speaker", action: "remove", device: e2 });
            let t2 = (yield MM())[0];
            t2 && xx && (xx.deviceId === e2.deviceId || xx.deviceId === Xk && xx.groupId !== t2.groupId) && (xx = t2, this.emit(_x.DEVICE_CHANGED, { type: "speaker", action: "active", device: t2 }));
          }));
        }
        use(e2) {
          let t2, i2;
          "plugin" in e2 ? (t2 = e2.plugin, i2 = e2.assetsPath) : t2 = e2, this._use(t2, i2 || "https://web.sdk.qcloud.com/trtc/webrtc/v5/assets/");
        }
        _use(e2, t2) {
          if (this._plugins.get(e2.Name))
            return void this._log.warn("duplicate install plugin", e2.Name);
          let i2 = new e2(function(e3, t3, i3) {
            return { room: e3, assetsPath: i3, innerEmitter: ew, constants: bb, environment: pN, utils: Cb, eventLogger: iw, log: e3.getLogger(), errorModule: t3, kvStatManager: mM, clearStarted(t4, i4) {
              let r2 = t4.getAlias(), n2 = lx.instances.get(e3);
              if (n2)
                if (i4) {
                  let e4 = n2.get(r2 + i4);
                  if (!e4)
                    return;
                  e4.started = false;
                } else
                  n2.forEach((e4, t5) => {
                    t5.startsWith(r2) && (e4.started = false);
                  });
            } };
          }(this._room, Vx, t2));
          this._plugins.set(e2.Name, i2);
        }
        enterRoom(e2) {
          return cb(this, null, function* () {
            var t2, i2;
            let { scene: r2 = "rtc", enableAutoPlayDialog: n2 = true, autoReceiveAudio: o2 = true, autoReceiveVideo: s2 = false } = e2;
            e2.proxy && (this._room.setProxyServer(e2.proxy), !Lw(e2.proxy) && e2.proxy.turnServer && (null == (i2 = (t2 = this._room).setTurnServer) || i2.call(t2, e2.proxy.turnServer, e2.proxy.iceTransportPolicy))), this._room.enableAutoPlayDialog = n2, this._room.autoReceiveAudio = o2, this._room.autoReceiveVideo = s2, Vw(e2.enableHWEncoder) && (this._room.enableHWEncoder = e2.enableHWEncoder);
            let a2 = { sdkAppId: e2.sdkAppId, userId: e2.userId, userSig: e2.userSig, privateMapKey: e2.privateMapKey || null, role: "audience" === e2.role ? 21 : 20, roomId: e2.roomId || 0, strRoomId: e2.strRoomId || "", businessInfo: e2.businessInfo || null, streamId: null, userDefineRecordId: e2.userDefineRecordId || null, frameWorkType: e2.frameWorkType, component: e2.component, language: e2.language };
            e2.strRoomId && !e2.roomId ? this._room.useStringRoomId = true : this._room.useStringRoomId = false, yield this._room.join(a2, r2, Ux.frameWorkType), this._checkTrackToPublish();
          });
        }
        exitRoom() {
          return cb(this, null, function* () {
            return yield this._exitRoom();
          });
        }
        switchRole(e2, t2) {
          return cb(this, null, function* () {
            null != t2 && t2.privateMapKey && (this._room.privateMapKey = t2.privateMapKey), yield this._room.switchRole(e2), "anchor" === e2 && this._checkTrackToPublish();
          });
        }
        destroy() {
          kP(this), this.removeAllListeners(), this._room.destroy(), Lx.delete(this), this._localAudioTrack && this.stopLocalAudio(), this._localVideoTrack && this.stopLocalVideo(), this._localScreenTrack && this.stopScreenShare(), this._plugins.forEach((e2) => {
            var t2;
            return null == (t2 = e2.destroy) ? void 0 : t2.call(e2);
          });
        }
        startLocalAudio() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { publish: true };
            return function* () {
              if (e2._localAudioTrack)
                return void e2._log.warn("local audio is already started");
              let { publish: i2 = true, mute: r2, option: n2 } = t2, o2 = new cL(e2._room.audioManager), s2 = {}, a2 = { muted: true };
              n2 && (Mw(n2.microphoneId) ? Mw(n2.audioTrack) || (s2.customSource = n2.audioTrack) : s2.deviceId = n2.microphoneId, n2 && xw(n2.captureVolume) && o2.setCaptureVolume(n2.captureVolume), Mw(n2.profile) || (Lw(n2.profile) ? ik[n2.profile] && o2.setProfile(ik[n2.profile]) : o2.setProfile(n2.profile)), xw(n2.earMonitorVolume) && (a2.muted = !(n2.earMonitorVolume > 0), a2.volume = n2.earMonitorVolume), Mw(n2.echoCancellation) || (o2.profile.echoCancellation = n2.echoCancellation), Mw(n2.noiseSuppression) || (o2.profile.noiseSuppression = n2.noiseSuppression), Mw(n2.autoGainControl) || (o2.profile.autoGainControl = n2.autoGainControl)), o2.on("5", (t3) => {
                e2.emit(_x.ERROR, new qL({ code: GL.DEVICE_ERROR, extraCode: 5309, messageParams: { error: t3 } }));
              }), o2.on("2", (t3) => {
                e2.emit(_x.DEVICE_CHANGED, { type: "microphone", action: "active", device: t3 });
              }), o2.on("4", (t3) => {
                let i3;
                t3.error && (i3 = qL.convertFrom(t3.error)), e2.emit(_x.PUBLISH_STATE_CHANGED, tb(eb({}, t3), { error: i3 }));
              }), e2._listenOutputTrackChanged(o2), e2._speakerId && o2.setAudioOutput(e2._speakerId), yield o2.capture(s2), Mw(r2) || o2.setMute(r2), bP(o2, o2).add("player-state-changed", (t3) => {
                e2.emit(_x.AUDIO_PLAY_STATE_CHANGED, tb(eb({}, t3), { userId: "" }));
              }), i2 && e2._room.isJoined && e2._room.publish(o2).catch(() => {
              }), e2._localAudioTrack = o2, e2._localAudioConfig = tb(eb({}, t2), { publish: i2 }), yield e2._updateAudioPlayOption({ playOption: a2, track: o2 });
            }();
          });
        }
        updateLocalAudio(e2) {
          return cb(this, null, function* () {
            if (!this._localAudioTrack || !this._localAudioConfig)
              return;
            let { publish: t2, mute: i2, option: r2 } = e2, n2 = {};
            r2 && (r2.microphoneId ? yield this._localAudioTrack.switchDevice(r2.microphoneId) : Mw(r2.audioTrack) || (yield this._localAudioTrack.setInputMediaStreamTrack(r2.audioTrack)), Mw(r2.captureVolume) || this._localAudioTrack.setCaptureVolume(r2.captureVolume), Mw(r2.earMonitorVolume) || (n2.muted = !(r2.earMonitorVolume > 0), n2.volume = r2.earMonitorVolume), yield this._localAudioTrack.update3A(r2)), this._room.isJoined && !Mw(t2) && (t2 && !this._localAudioConfig.publish && this._room.publish(this._localAudioTrack).catch(() => {
            }), this._localAudioConfig.publish && !t2 && this._room.unpublish(this._localAudioTrack).catch(() => {
            })), Mw(i2) || this._localAudioTrack.setMute(i2), yield this._updateAudioPlayOption({ playOption: n2, track: this._localAudioTrack, prevConfig: this._localAudioConfig }), tO(this._localAudioConfig, e2);
          });
        }
        stopLocalAudio() {
          return cb(this, null, function* () {
            !this._localAudioTrack || (this._room.isJoined && (yield this._room.unpublish(this._localAudioTrack).catch(() => {
            })), this._localAudioTrack.stop(), this._localAudioTrack.close(), this._room.audioManager.removeInput(this._localAudioTrack), kP(this._localAudioTrack), this._localAudioTrack = null, this._localAudioConfig = null);
          });
        }
        startLocalVideo() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { publish: true, view: null };
            return function* () {
              if (e2._localVideoTrack)
                return void e2._log.warn("local video is already started");
              let { view: i2, publish: r2 = true, mute: n2, option: o2 } = t2, s2 = new lL(e2._room.videoManager), a2 = {}, c2 = {};
              if (o2 && (o2.cameraId ? a2.deviceId = o2.cameraId : Mw(o2.useFrontCamera) ? Mw(o2.videoTrack) || (a2.customSource = o2.videoTrack) : a2.facingMode = o2.useFrontCamera ? ok.FACING_MODE_USER : ok.FACING_MODE_ENVIRONMENT, Mw(o2.profile) || (Lw(o2.profile) ? rk[o2.profile] && s2.setProfile(rk[o2.profile]) : s2.setProfile(o2.profile)), Mw(o2.fillMode) || (c2.objectFit = o2.fillMode), Mw(o2.mirror) || (c2.mirror = o2.mirror), Mw(o2.small) || (WO() ? Lw(o2.small) ? s2.small = rk[o2.small] : true === o2.small ? s2.small = rk["120p"] : s2.small = o2.small : e2._log.warn("small stream is not supported"))), s2.on("5", (t3) => {
                e2.emit(_x.ERROR, new qL({ code: GL.DEVICE_ERROR, extraCode: 5308, messageParams: { error: t3 } }));
              }), s2.on("2", (t3) => {
                e2.emit(_x.DEVICE_CHANGED, { type: "camera", action: "active", device: t3 });
              }), s2.on("4", (t3) => {
                let i3;
                t3.error && (i3 = qL.convertFrom(t3.error)), e2.emit(_x.PUBLISH_STATE_CHANGED, tb(eb({}, t3), { error: i3 }));
              }), e2._listenOutputTrackChanged(s2), yield s2.capture(a2), Mw(n2) || (yield s2.setMute(n2)), s2.mediaTrack)
                if (null != o2 && o2.qosPreference) {
                  let e3 = gx(o2.qosPreference);
                  s2.mediaTrack.contentHint = e3;
                } else
                  null != o2 && o2.videoTrack || (s2.mediaTrack.contentHint = gx(jL.QOS_PREFERENCE_SMOOTH));
              bP(s2, s2).add("player-state-changed", (t3) => {
                e2.emit(_x.VIDEO_PLAY_STATE_CHANGED, tb(eb({}, t3), { userId: "", streamType: "main" }));
              }), r2 && e2._room.isJoined && e2._room.publish(s2).catch(() => {
              }), e2._localVideoTrack = s2, e2._localVideoConfig = tb(eb({}, t2), { view: i2, publish: r2 }), yield e2._updateVideoPlayOption({ view: i2, playOption: c2, track: s2 });
            }();
          });
        }
        updateLocalVideo(e2) {
          return cb(this, null, function* () {
            if (!this._localVideoTrack || !this._localVideoConfig)
              return;
            let { view: t2, publish: i2, mute: r2, option: n2 } = e2, o2 = {};
            if (n2) {
              if (Mw(n2.profile) || (Lw(n2.profile) ? rk[n2.profile] && this._localVideoTrack.setProfile(rk[n2.profile]) : this._localVideoTrack.setProfile(n2.profile), (!n2.cameraId || !this._localVideoTrack.isNeedToSwitchDevice(n2.cameraId)) && Mw(n2.useFrontCamera) && this._localVideoTrack.applyProfile()), n2.cameraId ? yield this._localVideoTrack.switchDevice(n2.cameraId) : Mw(n2.useFrontCamera) ? Mw(n2.videoTrack) || (yield this._localVideoTrack.setInputMediaStreamTrack(n2.videoTrack)) : yield this._localVideoTrack.switchDevice(n2.useFrontCamera ? ok.FACING_MODE_USER : ok.FACING_MODE_ENVIRONMENT), Mw(n2.fillMode) || (o2.objectFit = n2.fillMode), Mw(n2.mirror) || (o2.mirror = n2.mirror), n2.qosPreference && this._localVideoTrack.mediaTrack) {
                let e3 = gx(n2.qosPreference);
                this._localVideoTrack.mediaTrack.contentHint = e3;
              }
              if (n2.small) {
                let e3 = !this._localVideoTrack.small;
                WO() ? (true === n2.small ? this._localVideoTrack.small = rk["120p"] : Lw(n2.small) ? this._localVideoTrack.small = rk[n2.small] : this._localVideoTrack.small = n2.small, this._room.videoManager.update(), e3 && this._room.enableSmall(true)) : this._log.warn("small stream is not supported");
              } else
                false === n2.small && this._localVideoTrack.small && (delete this._localVideoTrack.small, this._room.videoManager.update(), this._room.enableSmall(false));
            }
            this._room.isJoined && !Mw(i2) && (i2 && !this._localVideoConfig.publish && this._room.publish(this._localVideoTrack).catch(() => {
            }), this._localVideoConfig.publish && !i2 && this._room.unpublish(this._localVideoTrack).catch(() => {
            })), Mw(r2) || (yield this._localVideoTrack.setMute(r2)), yield this._updateVideoPlayOption({ view: t2, playOption: o2, track: this._localVideoTrack, prevConfig: this._localVideoConfig }), tO(this._localVideoConfig, e2);
          });
        }
        stopLocalVideo() {
          return cb(this, null, function* () {
            !this._localVideoTrack || (this._room.isJoined && (yield this._room.unpublish(this._localVideoTrack).catch(() => {
            })), this._localVideoTrack.stop(), this._localVideoTrack.close(), kP(this._localVideoTrack), this._localVideoTrack = null, this._localVideoConfig = null);
          });
        }
        startScreenShare() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { publish: true, view: null };
            return function* () {
              if (e2._localScreenTrack)
                return void e2._log.warn("screen share is already started");
              let { view: i2 = null, publish: r2 = true, option: n2 } = t2, o2 = new pL(e2._room.videoManager);
              o2.on("4", (t3) => {
                let i3;
                t3.error && (i3 = qL.convertFrom(t3.error)), e2.emit(_x.PUBLISH_STATE_CHANGED, tb(eb({}, t3), { error: i3 }));
              }), e2._listenOutputTrackChanged(o2);
              let s2 = null, a2 = {}, c2 = {};
              n2 && (Mw(n2.profile) || (Lw(n2.profile) ? nk[n2.profile] && o2.setProfile(nk[n2.profile]) : o2.setProfile(n2.profile)), n2.systemAudio && (a2.systemAudio = true, a2.echoCancellation = n2.echoCancellation, a2.noiseSuppression = n2.noiseSuppression, a2.autoGainControl = n2.autoGainControl), Mw(n2.fillMode) || (c2.objectFit = n2.fillMode), n2.videoTrack && (a2.videoTrack = n2.videoTrack), n2.audioTrack && (a2.audioTrack = n2.audioTrack), n2.captureElement && (a2.captureElement = n2.captureElement), n2.preferDisplaySurface && (a2.preferDisplaySurface = n2.preferDisplaySurface));
              let l2 = yield o2.capture(a2);
              if (null != n2 && n2.qosPreference) {
                let e3 = gx(n2.qosPreference);
                o2.mediaTrack.contentHint = e3;
              } else
                null != n2 && n2.videoTrack || (o2.mediaTrack.contentHint = gx(jL.QOS_PREFERENCE_CLEAR));
              if (o2.mediaTrack.addEventListener(ok.ENDED, () => {
                e2._stopScreenShare(), e2.emit(_x.SCREEN_SHARE_STOPPED);
              }), l2.getAudioTracks()[0] && (s2 = new mL(e2._room.audioManager), s2.setInputMediaStreamTrack(l2.getAudioTracks()[0]), e2._speakerId && s2.setAudioOutput(e2._speakerId)), bP(o2, o2).add("player-state-changed", (t3) => {
                e2.emit(_x.VIDEO_PLAY_STATE_CHANGED, tb(eb({}, t3), { userId: "", streamType: "sub" }));
              }), r2 && e2._room.isJoined) {
                let t3 = [o2];
                s2 && t3.push(s2), e2._room.publish(...t3).catch(() => {
                });
              }
              e2._localScreenTrack = o2, e2._localScreenAudioTrack = s2, e2._localScreenConfig = tb(eb({}, t2), { view: i2, publish: r2 }), yield e2._updateVideoPlayOption({ view: i2, playOption: c2, track: o2 });
            }();
          });
        }
        updateScreenShare(e2) {
          return cb(this, null, function* () {
            if (!this._localScreenTrack || !this._localScreenConfig)
              return;
            let { view: t2, publish: i2, option: r2 } = e2, n2 = {};
            if (r2 && (Mw(r2.fillMode) || (n2.objectFit = r2.fillMode), r2.qosPreference)) {
              let e3 = gx(r2.qosPreference);
              this._localScreenTrack.mediaTrack.contentHint = e3;
            }
            this._room.isJoined && !Mw(i2) && (i2 && !this._localScreenConfig.publish && (this._room.publish(this._localScreenTrack).catch(() => {
            }), this._localScreenAudioTrack && this._room.publish(this._localScreenAudioTrack).catch(() => {
            })), this._localScreenConfig.publish && !i2 && (this._room.unpublish(this._localScreenTrack).catch(() => {
            }), this._localScreenAudioTrack && this._room.unpublish(this._localScreenAudioTrack).catch(() => {
            }))), yield this._updateVideoPlayOption({ view: t2, playOption: n2, track: this._localScreenTrack, prevConfig: this._localScreenConfig }), tO(this._localScreenConfig, e2);
          });
        }
        stopScreenShare() {
          return cb(this, null, function* () {
            return yield this._stopScreenShare();
          });
        }
        startRemoteVideo(e2) {
          return cb(this, null, function* () {
            let { view: t2, userId: i2, streamType: r2, option: n2 } = e2, o2 = "".concat(i2, "_").concat(r2);
            if (this._remoteVideoConfigMap.has(o2))
              return void this._log.warn("remote video has already started. userId:".concat(i2, ", streamType:").concat(r2));
            let s2 = this._room.remotePublishedUserMap.get(i2);
            if (!s2)
              return;
            let a2 = {}, c2 = "main" === r2 ? s2.remoteVideoTrack : s2.remoteAuxiliaryTrack;
            this._listenOutputTrackChanged(c2), n2 && (Mw(n2.fillMode) || (a2.objectFit = n2.fillMode), Mw(n2.mirror) || (a2.mirror = n2.mirror), "main" === r2 && !Mw(n2.small) && (s2.remoteVideoTrack.setMediaType(n2.small ? 8 : 4), this._room.changeType(n2.small, c2.user))), yield this._room.subscribe(c2), yield this._updateVideoPlayOption({ view: t2, playOption: a2, track: c2 }), this._emitTrackEvent(c2), this._remoteVideoConfigMap.set(o2, { config: e2 }), n2 && !Mw(n2.receiveWhenViewVisible) && this._observeView({ remoteTrack: c2, view: t2, receiveWhenViewVisible: n2.receiveWhenViewVisible, viewRoot: null == n2 ? void 0 : n2.viewRoot });
          });
        }
        updateRemoteVideo(e2) {
          return cb(this, null, function* () {
            var t2, i2;
            let { view: r2, userId: n2, streamType: o2, option: s2 } = e2, a2 = "".concat(n2, "_").concat(o2), c2 = this._remoteVideoConfigMap.get(a2);
            if (!c2 || !this._room.remotePublishedUserMap.has(n2))
              return;
            let l2 = {};
            s2 && (Mw(s2.fillMode) || (l2.objectFit = s2.fillMode), Mw(s2.mirror) || (l2.mirror = s2.mirror));
            let d2 = null, u2 = this._room.remotePublishedUserMap.get(n2);
            if ("main" === o2 && (null == u2 ? void 0 : u2.muteState.hasVideo) && (d2 = u2.remoteVideoTrack), "sub" === o2 && (null == u2 ? void 0 : u2.muteState.hasAuxiliary) && (d2 = u2.remoteAuxiliaryTrack), !d2)
              return;
            let { config: h2 } = c2;
            "main" === o2 && s2 && !Mw(s2.small) && this._room.changeType(s2.small, d2.user), yield this._updateVideoPlayOption({ view: r2, playOption: l2, track: d2, prevConfig: h2 }), tO(h2, e2);
            let p2 = Mw(null == s2 ? void 0 : s2.receiveWhenViewVisible) ? null == (t2 = h2.option) ? void 0 : t2.receiveWhenViewVisible : s2.receiveWhenViewVisible, m2 = Mw(r2) ? h2.view : r2, _2 = Mw(null == s2 ? void 0 : s2.viewRoot) ? null == (i2 = h2.option) ? void 0 : i2.viewRoot : s2.viewRoot;
            this._observeView({ remoteTrack: d2, view: m2, receiveWhenViewVisible: p2, viewRoot: _2 });
          });
        }
        stopRemoteVideo(e2) {
          return cb(this, null, function* () {
            return this._stopRemoteVideo(e2);
          });
        }
        _stopRemoteVideo(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          return cb(this, null, function* () {
            let i2 = [], r2 = this._room.remotePublishedUserMap.get(e2.userId);
            if (r2) {
              let { muteState: t3, remoteVideoTrack: n3, remoteAuxiliaryTrack: o2 } = r2;
              "main" === e2.streamType && (n3.stop(), t3.hasVideo && i2.push(n3)), "sub" === e2.streamType && (o2.stop(), t3.hasAuxiliary && i2.push(o2));
            }
            for (let e3 of i2)
              t2 && (yield this._room.unsubscribe(e3), this._mediaTrackMap.get(e3.outMediaTrack) === e3.userId && this._mediaTrackMap.delete(e3.outMediaTrack));
            let n2 = this._remoteVideoConfigMap.get("".concat(e2.userId, "_").concat(e2.streamType));
            n2 && n2.observer && n2.observer.disconnect(), this._remoteVideoConfigMap.delete("".concat(e2.userId, "_").concat(e2.streamType));
          });
        }
        muteRemoteAudio(e2, t2) {
          return cb(this, null, function* () {
            if ("*" === e2)
              if (t2)
                yield this._stopRemoteAudio({ userId: e2 });
              else {
                let e3 = [...this._room.remotePublishedUserMap.values()];
                for (let t3 of e3)
                  t3.muteState.hasAudio && (yield this._startRemoteAudio({ userId: t3.userId }));
              }
            else
              t2 ? yield this._stopRemoteAudio({ userId: e2 }) : yield this._startRemoteAudio({ userId: e2 });
            this._remoteAudioMuteMap.set(e2, t2);
          });
        }
        setRemoteAudioVolume(e2, t2) {
          if ("*" === e2) {
            let e3 = [...this._room.remotePublishedUserMap.values()];
            for (let i2 of e3)
              this._updateAudioPlayOption({ playOption: { volume: t2 }, track: i2.remoteAudioTrack });
          } else if (e2) {
            let i2 = this._room.remotePublishedUserMap.get(e2);
            i2 && this._updateAudioPlayOption({ playOption: { volume: t2 }, track: i2.remoteAudioTrack });
          }
        }
        startPlugin(e2, t2) {
          return cb(this, null, function* () {
            return e2.start(t2);
          });
        }
        updatePlugin(e2, t2) {
          return cb(this, null, function* () {
            return e2.update(t2);
          });
        }
        stopPlugin(e2, t2) {
          return cb(this, null, function* () {
            return e2.stop(t2);
          });
        }
        enableAudioVolumeEvaluation() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2e3, t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this._room.enableAudioVolumeEvaluation(e2, t2);
        }
        on(e2, t2, i2) {
          return this.listeners(e2).includes(t2) || (super.on(e2, t2, i2), this._eventListened.add(e2)), this;
        }
        off(e2, t2, i2) {
          return "*" === e2 ? (this._eventListened.clear(), this.removeAllListeners()) : super.off(e2, t2, i2), this;
        }
        getAudioTrack() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { userId: "", streamType: "main" };
          var t2, i2;
          let r2, n2 = "main";
          if (Lw(e2) ? r2 = e2 : (r2 = e2.userId, e2.streamType && (n2 = e2.streamType)), !r2)
            return "sub" === n2 ? (null == (t2 = this._localScreenAudioTrack) ? void 0 : t2.mediaTrack) || null : (null == (i2 = this._localAudioTrack) ? void 0 : i2.mediaTrack) || null;
          {
            let e3 = this._room.remotePublishedUserMap.get(r2);
            if (e3)
              return e3.remoteAudioTrack.mediaTrack;
          }
          return null;
        }
        getVideoTrack() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { userId: "", streamType: "main" }, { userId: t2 = "", streamType: i2 = "main" } = e2;
          if ("" === t2) {
            if ("main" === i2 && this._localVideoTrack)
              return this._localVideoTrack.mediaTrack;
            if ("sub" === i2 && this._localScreenTrack)
              return this._localScreenTrack.mediaTrack;
          } else {
            let e3 = this._room.remotePublishedUserMap.get(t2);
            if (e3)
              return "main" === i2 ? e3.remoteVideoTrack.mediaTrack : e3.remoteAuxiliaryTrack.mediaTrack;
          }
          return null;
        }
        getVideoSnapshot() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, { userId: t2, streamType: i2 = "main" } = e2;
          if (t2) {
            let e3 = this._room.remotePublishedUserMap.get(t2);
            if ("main" === i2 && (null == e3 ? void 0 : e3.muteState.hasVideo))
              return e3.remoteVideoTrack.getVideoFrame();
            if ("sub" === i2 && (null == e3 ? void 0 : e3.muteState.hasAuxiliary))
              return e3.remoteAuxiliaryTrack.getVideoFrame();
          } else {
            if ("main" === i2 && this._localVideoTrack)
              return this._localVideoTrack.getVideoFrame();
            if ("sub" === i2 && this._localScreenTrack)
              return this._localScreenTrack.getVideoFrame();
          }
          return "";
        }
        setCurrentSpeaker(e2) {
          var t2, i2;
          this._speakerId = e2, null == (t2 = this._localAudioTrack) || t2.setAudioOutput(e2), null == (i2 = this._localScreenAudioTrack) || i2.setAudioOutput(e2), this._room.remotePublishedUserMap.forEach((t3) => t3.remoteAudioTrack.setAudioOutput(e2));
        }
        _startRemoteAudio(e2) {
          return this._doStartRemoteAudio(e2);
        }
        _doStartRemoteAudio(e2) {
          return cb(this, null, function* () {
            let { userId: t2, option: i2 } = e2;
            if (this._remoteAudioConfigMap.has(t2))
              return void this._log.warn("remote audio has already started. userId:".concat(t2));
            let r2 = this._room.remotePublishedUserMap.get(t2);
            if (!r2)
              return;
            let n2 = {};
            i2 && (Mw(i2.volume) || (n2.volume = i2.volume));
            let o2 = r2.remoteAudioTrack;
            this._listenOutputTrackChanged(o2), this._speakerId && o2.setAudioOutput(this._speakerId);
            try {
              this._remoteAudioConfigMap.set(t2, e2), yield this._room.subscribe(o2), yield this._updateAudioPlayOption({ playOption: n2, track: o2 });
            } catch (WU2) {
              throw this._remoteAudioConfigMap.delete(t2), WU2;
            }
            this._emitTrackEvent(o2);
          });
        }
        _stopRemoteAudio(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          return cb(this, null, function* () {
            let i2 = this._room.remotePublishedUserMap.get(e2.userId);
            i2 && (i2.remoteAudioTrack.stop(), i2.muteState.hasAudio && t2 && (yield this._room.unsubscribe(i2.remoteAudioTrack)), this._mediaTrackMap.get(i2.remoteAudioTrack.outMediaTrack) === e2.userId && this._mediaTrackMap.delete(i2.remoteAudioTrack.outMediaTrack)), this._remoteAudioConfigMap.delete("".concat(e2.userId));
          });
        }
        _updateVideoPlayOption(e2) {
          return cb(this, arguments, function(e3) {
            let { view: t2, playOption: i2, track: r2, prevConfig: n2 } = e3;
            return function* () {
              if (r2.setMirror(i2.mirror), Mw(t2) && n2 && n2.view && !Xw(i2)) {
                let e4 = rO(n2.view);
                e4.length > 0 && (yield r2.play(e4, i2));
              }
              if (!Mw(t2)) {
                let e4 = rO(t2);
                e4.length > 0 ? yield r2.play(e4, i2) : r2.stop();
              }
            }();
          });
        }
        _updateAudioPlayOption(e2) {
          return cb(this, arguments, function(e3) {
            let { playOption: t2 = {}, track: i2, prevConfig: r2 } = e3;
            return function* () {
              if (!i2.isPlayCalled)
                try {
                  yield i2.play(null, t2);
                } catch (Pb2) {
                }
              Mw(t2.muted) || i2.setPlayerMute(t2.muted), Mw(t2.volume) || i2.setAudioVolume(t2.volume / 100);
            }();
          });
        }
        _listenOutputTrackChanged(e2) {
          0 === e2.listeners("output-media-track-changed").length && e2.on("output-media-track-changed", () => this._emitTrackEvent(e2));
        }
        _emitTrackEvent(e2) {
          let t2 = e2.isRemote ? e2.userId : "";
          e2.outMediaTrack && this._mediaTrackMap.get(e2.outMediaTrack) !== t2 && (this._mediaTrackMap.set(e2.outMediaTrack, t2), this.emit(_x.TRACK, { userId: t2, streamType: fx(e2.streamType), track: e2.outMediaTrack }));
        }
        _checkTrackToPublish() {
          var e2, t2, i2;
          let r2 = [];
          if ((null == (e2 = this._localAudioConfig) ? void 0 : e2.publish) && this._localAudioTrack && r2.push(this._localAudioTrack), (null == (t2 = this._localVideoConfig) ? void 0 : t2.publish) && this._localVideoTrack && r2.push(this._localVideoTrack), null != (i2 = this._localScreenConfig) && i2.publish && (this._localScreenTrack && r2.push(this._localScreenTrack), this._localScreenAudioTrack && r2.push(this._localScreenAudioTrack)), 0 !== r2.length)
            return this._room.publish(...r2).catch(() => {
            });
        }
        _observeView(e2) {
          let { remoteTrack: t2, view: i2, receiveWhenViewVisible: r2 = false, viewRoot: n2 } = e2;
          if (Mw(i2))
            return;
          let o2 = this._remoteVideoConfigMap.get("".concat(t2.userId, "_").concat(fx(t2.streamType)));
          if (!o2)
            return;
          let s2 = o2.observer || void 0;
          if (null === i2 || Fw(i2) && 0 === i2.length || !r2)
            return null == s2 || s2.disconnect(), void (t2.isSubscribed || this._room.subscribe(t2).catch(() => {
            }));
          let a2 = o2.visibleViewMap || /* @__PURE__ */ new Map(), c2 = -1;
          (!s2 || s2.root !== n2) && (null == s2 || s2.disconnect(), a2.clear(), s2 = new IntersectionObserver((e3) => {
            e3.forEach((e4) => {
              a2.set(e4.target, e4.isIntersecting);
            }), clearTimeout(c2), c2 = window.setTimeout(() => {
              [...a2.values()].find((e4) => e4) ? t2.isSubscribed || this._room.subscribe(t2).catch(() => {
              }) : t2.isSubscribed && this._room.unsubscribe(t2).catch(() => {
              });
            }, 200);
          }, { root: n2 }));
          let l2 = new Set(rO(i2));
          a2.forEach((e3, t3) => {
            l2.has(t3) || (s2.unobserve(t3), a2.delete(t3));
          }), l2.forEach((e3) => {
            a2.set(e3, true), s2.observe(e3);
          }), s2.takeRecords().forEach((e3) => {
            a2.set(e3.target, e3.isIntersecting);
          }), o2.visibleViewMap = a2, o2.observer = s2;
        }
        _exitRoom() {
          return cb(this, null, function* () {
            this._room.isJoined && (yield this._room.leave()), (/* @__PURE__ */ new Set([...this._remoteAudioConfigMap.keys(), ...this._remoteAudioMuteMap.keys()])).forEach((e2) => {
              this._stopRemoteAudio({ userId: e2 }).catch();
            }), [...this._remoteVideoConfigMap.keys()].forEach((e2) => {
              let t2 = e2.includes("main") ? "main" : "sub", i2 = e2.split("_".concat(t2))[0];
              i2 && this._stopRemoteVideo({ userId: i2, streamType: t2 }).catch();
            }), this._remoteVideoConfigMap.clear(), this._remoteAudioConfigMap.clear(), this._remoteAudioMuteMap.clear(), this._room.remotePublishedUserMap.forEach((e2) => {
              kP(e2.remoteAudioTrack), kP(e2.remoteVideoTrack), kP(e2.remoteAuxiliaryTrack);
            });
          });
        }
        _stopScreenShare() {
          return cb(this, null, function* () {
            var e2;
            if (this._localScreenTrack) {
              if (this._room.isJoined) {
                let t2 = [this._localScreenTrack];
                this._localScreenAudioTrack && t2.push(this._localScreenAudioTrack), yield null == (e2 = this._room) ? void 0 : e2.unpublish(...t2).catch(() => {
                });
              }
              this._localScreenTrack.stop(), this._localScreenTrack.close(), this._localScreenAudioTrack && (this._localScreenAudioTrack.stop(), this._localScreenAudioTrack.close(), this._room.audioManager.removeInput(this._localScreenAudioTrack), this._localScreenAudioTrack = null), kP(this._localScreenTrack), this._localScreenTrack = null, this._localScreenConfig = null;
            }
          });
        }
        _initActiveSpeaker() {
          return cb(this, null, function* () {
            if (xx && !NM(xx))
              this.emit(_x.DEVICE_CHANGED, { type: "speaker", action: "active", device: xx });
            else {
              let e2 = yield MM();
              if (e2[0] && !NM(e2[0]))
                xx = e2[0], this.emit(_x.DEVICE_CHANGED, { type: "speaker", action: "active", device: e2[0] });
              else {
                let e3 = (e4) => {
                  let { track: t2 } = e4;
                  "audio" === t2.kind && (!xx || NM(xx)) && (this._initActiveSpeaker(), ew.off("102", this._initActiveSpeaker));
                };
                ew.on("102", e3);
              }
            }
          });
        }
        _onAudioAvailable(e2) {
          let { userId: t2 } = e2, i2 = this._remoteAudioMuteMap.has(t2) ? this._remoteAudioMuteMap.get(t2) : this._remoteAudioMuteMap.get("*");
          (false === i2 || this._room.autoReceiveAudio && !i2) && this._doStartRemoteAudio({ userId: t2 }).catch(() => {
          });
        }
        _onVideoAvailable(e2) {
          let { userId: t2, streamType: i2 } = e2;
          if (!this._room.autoReceiveVideo)
            return;
          let r2 = this._room.remotePublishedUserMap.get(t2);
          if (r2) {
            let e3 = "main" === i2 ? r2.remoteVideoTrack : r2.remoteAuxiliaryTrack;
            this._room.subscribe(e3).then(() => {
              this._emitTrackEvent(e3);
            }).catch(() => {
            });
          }
        }
        _onAudioUnavailable(e2) {
          let { userId: t2, muteState: i2 } = e2;
          i2.hasAudio && i2.audioMuted || this._stopRemoteAudio({ userId: t2 }, false).catch(() => {
          });
        }
        _onVideoUnavailable(e2) {
          let { userId: t2, streamType: i2 } = e2;
          this._stopRemoteVideo({ userId: t2, streamType: i2 }, false).catch(() => {
          });
        }
        sendSEIMessage(e2, t2) {
          this._room.sendSEI(e2, t2 || { seiPayloadType: 243 });
        }
        sendCustomMessage(e2) {
          var t2, i2;
          null == (i2 = (t2 = this._room).sendCustomMessage) || i2.call(t2, e2);
        }
        static setLogLevel(e2, t2) {
          EO.setLogLevel(e2), Mw(t2) || (t2 ? EO.enableUploadLog() : EO.disableUploadLog());
        }
        static isSupported() {
          return LO();
        }
        static getCameraList() {
          return OM(true);
        }
        static getMicrophoneList() {
          return wM(true);
        }
        static getSpeakerList() {
          return MM(true);
        }
        static setCurrentSpeaker(e2) {
          return cb(this, null, function* () {
            (yield MM()).forEach((t2) => {
              t2.deviceId === e2 && (Lx.forEach((i2) => {
                i2.setCurrentSpeaker(e2), i2.emit(_x.DEVICE_CHANGED, { type: "speaker", action: "active", device: t2 });
              }), xx = t2);
            });
          });
        }
        static _addKVStat(e2) {
          let { type: t2, key: i2, value: r2, base: n2, useUV: o2, version: s2 } = e2;
          switch (s2 && (pM.version = s2), t2) {
            case "count":
              pM.addCount({ key: i2, useUV: o2 });
              break;
            case "enum":
              pM.addEnum({ key: i2, value: r2, useUV: o2 });
              break;
            case "number":
              pM.addNumber({ key: i2, value: r2, split: n2 });
          }
        }
      }, Fx = Ux;
      sb(Fx, "_loggerManager", EO), sb(Fx, "EVENT", _x), sb(Fx, "ERROR_CODE", GL), sb(Fx, "TYPE", jL), sb(Fx, "frameWorkType", 30), ob([yx({ replaceArg: (e2) => ({ argIndex: 0, value: { name: "plugin" in e2 ? e2.plugin.Name : e2.Name, assetsPath: "assetsPath" in e2 ? null == e2 ? void 0 : e2.assetsPath : "default" } }) })], Fx.prototype, "use", 1), ob([Ex(rx.TRTC.enterRoom), hx("room", (e2, t2) => {
        let [i2] = e2, [r2] = t2;
        return (i2.roomId || i2.strRoomId) === (r2.roomId || r2.strRoomId) && i2.userId === r2.userId && i2.sdkAppId === r2.sdkAppId;
      }), XM((e2) => function(t2) {
        return this._log.setUserId(t2.userId), this._log.setSdkAppId(t2.sdkAppId), e2.call(this, t2);
      }), yx()], Fx.prototype, "enterRoom", 1), ob([yx()], Fx.prototype, "exitRoom", 1), ob([Ex(rx.TRTC.switchRole), px("room", { merge: (e2, t2) => t2 }), yx()], Fx.prototype, "switchRole", 1), ob([yx()], Fx.prototype, "destroy", 1), ob([Ex(rx.TRTC.startLocalAudio), hx("audio", (e2, t2) => {
        let [i2] = e2, [r2] = t2;
        var n2, o2;
        return (null == (n2 = null == i2 ? void 0 : i2.option) ? void 0 : n2.microphoneId) === (null == (o2 = null == r2 ? void 0 : r2.option) ? void 0 : o2.microphoneId);
      }), yx()], Fx.prototype, "startLocalAudio", 1), ob([Ex(rx.TRTC.updateLocalAudio), px("audio", { debounce: { delay: 200, getKey: () => "".concat(Mx, "-localAudio"), isNeedToDebounce: (e2) => {
        var t2;
        return !Mw(null == (t2 = e2.option) ? void 0 : t2.captureVolume);
      } } }), yx()], Fx.prototype, "updateLocalAudio", 1), ob([mx("audio"), yx()], Fx.prototype, "stopLocalAudio", 1), ob([Ex(rx.TRTC.startLocalVideo), hx("video", (e2, t2) => {
        let [i2] = e2, [r2] = t2;
        var n2, o2;
        return (null == (n2 = null == i2 ? void 0 : i2.option) ? void 0 : n2.cameraId) === (null == (o2 = null == r2 ? void 0 : r2.option) ? void 0 : o2.cameraId);
      }), yx()], Fx.prototype, "startLocalVideo", 1), ob([Ex(rx.TRTC.updateLocalVideo), px("video"), yx()], Fx.prototype, "updateLocalVideo", 1), ob([mx("video"), yx()], Fx.prototype, "stopLocalVideo", 1), ob([Ex(rx.TRTC.startScreenShare), hx("screen", () => true), yx()], Fx.prototype, "startScreenShare", 1), ob([Ex(rx.TRTC.updateScreenShare), px("screen"), yx()], Fx.prototype, "updateScreenShare", 1), ob([yx()], Fx.prototype, "stopScreenShare", 1), ob([Ex(rx.TRTC.startRemoteVideo), hx((e2) => "v".concat(e2.userId).concat(e2.streamType), () => true), yx({ getRemoteId: (e2) => "".concat(e2.userId, "_").concat(e2.streamType) })], Fx.prototype, "startRemoteVideo", 1), ob([Ex(rx.TRTC.updateRemoteVideo), px((e2) => "v".concat(e2.userId).concat(e2.streamType)), yx({ getRemoteId: (e2) => "".concat(e2.userId, "_").concat(e2.streamType) })], Fx.prototype, "updateRemoteVideo", 1), ob([Ex(rx.TRTC.stopRemoteVideo), XM((e2) => function(t2) {
        return cb(this, null, function* () {
          if ("*" === t2.userId) {
            let e3 = [];
            return this._room.remotePublishedUserMap.forEach((t3) => {
              this._remoteVideoConfigMap.has("".concat(t3.userId, "_", "main")) && e3.push(this.stopRemoteVideo({ streamType: "main", userId: t3.userId }).catch(() => {
              })), this._remoteVideoConfigMap.has("".concat(t3.userId, "_", "sub")) && e3.push(this.stopRemoteVideo({ streamType: "sub", userId: t3.userId }).catch(() => {
              }));
            }), Promise.all(e3);
          }
          return e2.call(this, t2);
        });
      }), yx({ getRemoteId: (e2) => "".concat(e2.userId, "_").concat(e2.streamType) })], Fx.prototype, "stopRemoteVideo", 1), ob([mx((e2) => "v".concat(e2.userId).concat(e2.streamType))], Fx.prototype, "_stopRemoteVideo", 1), ob([Ex(...rx.TRTC.muteRemoteAudio), yx({ getRemoteId: (e2) => e2 })], Fx.prototype, "muteRemoteAudio", 1), ob([Sx(...rx.TRTC.setRemoteAudioVolume), function(e2, t2) {
        return XM((i2, r2) => function() {
          for (var r3 = arguments.length, n2 = new Array(r3), o2 = 0; o2 < r3; o2++)
            n2[o2] = arguments[o2];
          var s2, a2;
          let c2 = null == (s2 = Tx.get(this)) ? void 0 : s2.get(t2(...n2));
          c2 && c2 > 0 && clearTimeout(c2);
          let l2 = window.setTimeout(() => {
            i2.apply(this, n2);
          }, e2);
          Tx.has(this) ? null == (a2 = Tx.get(this)) || a2.set(t2(...n2), l2) : Tx.set(this, /* @__PURE__ */ new Map([[t2(...n2), l2]]));
        });
      }(200, (e2) => e2), yx({ getRemoteId: (e2) => e2 })], Fx.prototype, "setRemoteAudioVolume", 1), ob([Ax("start"), hx((e2, t2) => e2.getAlias() + e2.getGroup(t2)), yx({ replaceArg: (e2) => ({ argIndex: 0, value: e2.getName() }), getKVReportKey: (e2) => aM[e2.getName()] })], Fx.prototype, "startPlugin", 1), ob([Ax("update"), px((e2, t2) => e2.getAlias() + e2.getGroup(t2)), yx({ replaceArg: (e2) => ({ argIndex: 0, value: e2.getName() }), getKVReportKey: (e2) => cM[e2.getName()] })], Fx.prototype, "updatePlugin", 1), ob([Ax("stop"), mx((e2, t2) => e2.getAlias() + e2.getGroup(t2)), yx({ replaceArg: (e2) => ({ argIndex: 0, value: e2.getName() }), getKVReportKey: (e2) => lM[e2.getName()] })], Fx.prototype, "stopPlugin", 1), ob([Sx(...rx.TRTC.enableAudioVolumeEvaluation)], Fx.prototype, "enableAudioVolumeEvaluation", 1), ob([yx()], Fx.prototype, "getVideoSnapshot", 1), ob([yx()], Fx.prototype, "setCurrentSpeaker", 1), ob([hx((e2) => "a".concat(e2.userId), () => true)], Fx.prototype, "_startRemoteAudio", 1), ob([XM((e2) => function(t2) {
        return cb(this, null, function* () {
          return "*" === t2.userId ? Promise.all([...this._room.remotePublishedUserMap.values()].map((e3) => this._stopRemoteAudio(tb(eb({}, t2), { userId: e3.userId })).catch(() => {
          }))) : e2.call(this, t2);
        });
      }), mx((e2) => "a".concat(e2.userId))], Fx.prototype, "_stopRemoteAudio", 1), ob([mx("room")], Fx.prototype, "_exitRoom", 1), ob([mx("screen")], Fx.prototype, "_stopScreenShare", 1), ob([Ex(...rx.TRTC.sendSEIMessage), FL({ timesInSecond: 30, maxSizeInSecond: 8e3, getSize: function() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
          t2[i2] = arguments[i2];
        return t2[0].byteLength;
      } })], Fx.prototype, "sendSEIMessage", 1), ob([Ex(rx.TRTC.sendCustomMessage), FL({ timesInSecond: 30, maxSizeInSecond: 8e3, getSize: (e2) => e2.data.byteLength })], Fx.prototype, "sendCustomMessage", 1), ob([Ex(rx.TRTC.create)], Fx, "_create", 1);
      var Bx = Fx, Hx = class {
        constructor() {
          this._set = /* @__PURE__ */ new Set(), ew.on(gO.LEAVE_SUCCESS, this.delete, this);
        }
        add(e2) {
          let { room: t2, roomId: i2 } = e2;
          if ("rtc" === t2.scene)
            return;
          let r2 = this.getKey(t2.userId, i2 || t2.roomId, t2.sdkAppId, t2.useStringRoomId);
          this._set.add(r2);
        }
        delete(e2) {
          let { room: t2, roomId: i2 } = e2;
          if ("rtc" === t2.scene)
            return;
          let r2 = this.getKey(t2.userId, t2.roomId || i2, t2.sdkAppId, t2.useStringRoomId);
          this._set.delete(r2);
        }
        getKey(e2, t2, i2, r2) {
          return "".concat(i2, "_").concat(t2, "_").concat(e2, "_").concat(r2);
        }
        isJoined(e2) {
          let { userId: t2, roomId: i2, sdkAppId: r2, room: n2 } = e2;
          return "rtc" !== n2.scene && this._set.has(this.getKey(t2, i2, r2, n2.useStringRoomId));
        }
      };
      function jx() {
        return cb(this, null, function* () {
          let e2, t2;
          try {
            let t3 = yield wM();
            e2 = t3 && t3.length;
          } catch (u2) {
          }
          try {
            let e3 = yield OM();
            t2 = e3 && e3.length;
          } catch (u2) {
          }
          let i2 = { microphone: e2, camera: t2 }, { isH264EncodeSupported: r2, isVp8EncodeSupported: n2, isH264DecodeSupported: o2, isVp8DecodeSupported: s2 } = this.checkSystemResult.detail, a2 = vO.basis(), c2 = { webRTC: a2.isWebRTCSupported, getUserMedia: a2.isGetUserMediaSupported, webSocket: a2.isWebSocketsSupported, screenShare: a2.isScreenShareSupported, webAudio: a2.isWebAudioSupported, h264Encode: r2, h264Decode: o2, vp8Encode: n2, vp8Decode: s2 }, l2 = { browser: a2.browser, os: a2.os, trtc: c2, devices: i2 }, d2 = { isWebCodecSupported: a2.isWebCodecSupported, isMediaSessionSupported: a2.isMediaSessionSupported, isWebTransportSupported: a2.isWebTransportSupported };
          iw.uploadEvent({ log: "trtcstats-".concat(JSON.stringify(l2)), userId: this.userId }), this._log.info("TrtcStats-".concat(JSON.stringify(l2))), iw.uploadEvent({ log: "trtcadvancedstats-".concat(JSON.stringify(d2)), userId: this.userId });
        });
      }
      var Gx = nb(lb(), 1), Wx = Symbol("instance"), Jx = Symbol("cacheResult"), Kx = class {
        constructor(e2, t2, i2) {
          this.oldState = e2, this.newState = t2, this.action = i2, this.aborted = false;
        }
        abort(e2) {
          this.aborted = true, Xx.call(e2, this.oldState, new Error("action '".concat(this.action, "' aborted")));
        }
        toString() {
          return "".concat(this.action, "ing");
        }
      }, zx = class extends Error {
        constructor(e2, t2, i2) {
          super(t2), this.state = e2, this.message = t2, this.cause = i2;
        }
      };
      var qx = /* @__PURE__ */ new Map();
      function Yx(e2, t2) {
        let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return (r2, n2, o2) => {
          let s2 = i2.action || n2;
          if (!i2.context) {
            let i3 = qx.get(r2) || [];
            qx.has(r2) || qx.set(r2, i3), i3.push({ from: e2, to: t2, action: s2 });
          }
          let a2 = o2.value;
          o2.value = function() {
            let r3 = this;
            for (var n3 = arguments.length, o3 = new Array(n3), c2 = 0; c2 < n3; c2++)
              o3[c2] = arguments[c2];
            if (i2.context && (r3 = $x.get("function" == typeof i2.context ? i2.context.call(this, ...o3) : i2.context)), r3.state === t2)
              return r3[Jx];
            r3.state instanceof Kx && r3.state.action == i2.abortAction && r3.state.abort(r3);
            let l2 = null;
            if (Array.isArray(e2) ? 0 == e2.length ? r3.state instanceof Kx && r3.state.abort(r3) : ("string" != typeof r3.state || !e2.includes(r3.state)) && (l2 = new zx(r3._state, "".concat(r3.name, " ").concat(s2, " to ").concat(t2, " failed: current state ").concat(r3._state, " not in from config"))) : e2 !== r3.state && (l2 = new zx(r3._state, "".concat(r3.name, " ").concat(s2, " to ").concat(t2, " failed: current state ").concat(r3._state, " not from ").concat(e2))), l2) {
              if (!i2.fail) {
                if (i2.ignoreError)
                  return l2;
                throw l2;
              }
              i2.fail.call(this, l2);
            }
            let d2 = r3.state, u2 = new Kx(d2, t2, s2);
            Xx.call(r3, u2);
            let h2 = (e3) => {
              var n4;
              return r3[Jx] = e3, u2.aborted || (Xx.call(r3, t2), null === (n4 = i2.success) || void 0 === n4 || n4.call(this, r3[Jx])), e3;
            }, p2 = (e3) => {
              let t3 = e3 instanceof Error ? e3.message : String(e3);
              if (Xx.call(r3, d2, e3), !i2.fail) {
                if (i2.ignoreError)
                  return e3;
                throw e3;
              }
              i2.fail.call(this, new zx(r3._state, "action '".concat(s2, "' failed :").concat(t3), e3 instanceof Error ? e3 : new Error(t3)));
            };
            try {
              let e3 = a2.apply(this, o3);
              return function(e4) {
                return "object" == typeof e4 && e4 && "then" in e4;
              }(e3) ? e3.then(h2).catch(p2) : h2(e3);
            } catch (m2) {
              p2(m2);
            }
          };
        };
      }
      var Qx = "undefined" != typeof window && window.__AFSM__ ? (e2, t2) => {
        window.dispatchEvent(new CustomEvent(e2, { detail: t2 }));
      } : "undefined" != typeof importScripts ? (e2, t2) => {
        postMessage({ type: e2, payload: t2 });
      } : () => {
      };
      function Xx(e2, t2) {
        let i2 = this._state;
        this._state = e2;
        let r2 = e2.toString();
        e2 && this.emit(r2, i2), this.emit($x.STATECHANGED, e2, i2, t2), this.updateDevTools({ value: e2, old: i2, err: t2 instanceof Error ? t2.message : String(t2) });
      }
      var $x = class extends Gx.default {
        constructor(e2, t2, i2) {
          super(), this.name = e2, this.groupName = t2, this._state = $x.INIT, e2 || (e2 = Date.now().toString(36)), i2 ? Object.setPrototypeOf(this, i2) : i2 = Object.getPrototypeOf(this), t2 || (this.groupName = this.constructor.name);
          let r2 = i2[Wx];
          r2 ? this.name = r2.name + "-" + r2.count++ : i2[Wx] = { name: this.name, count: 0 }, this.updateDevTools({ diagram: this.stateDiagram });
        }
        get stateDiagram() {
          let e2 = Object.getPrototypeOf(this), t2 = qx.get(e2) || [], i2 = /* @__PURE__ */ new Set(), r2 = [], n2 = [], o2 = /* @__PURE__ */ new Set(), s2 = Object.getPrototypeOf(e2);
          qx.has(s2) && (s2.stateDiagram.forEach((e3) => i2.add(e3)), s2.allStates.forEach((e3) => o2.add(e3))), t2.forEach((e3) => {
            let { from: t3, to: i3, action: o3 } = e3;
            "string" == typeof t3 ? r2.push({ from: t3, to: i3, action: o3 }) : t3.length ? t3.forEach((e4) => {
              r2.push({ from: e4, to: i3, action: o3 });
            }) : n2.push({ to: i3, action: o3 });
          }), r2.forEach((e3) => {
            let { from: t3, to: r3, action: n3 } = e3;
            o2.add(t3), o2.add(r3), o2.add(n3 + "ing"), i2.add("".concat(t3, " --> ").concat(n3, "ing : ").concat(n3)), i2.add("".concat(n3, "ing --> ").concat(r3, " : ").concat(n3, " ð¢")), i2.add("".concat(n3, "ing --> ").concat(t3, " : ").concat(n3, " ð´"));
          }), n2.forEach((e3) => {
            let { to: t3, action: r3 } = e3;
            i2.add("".concat(r3, "ing --> ").concat(t3, " : ").concat(r3, " ð¢")), o2.forEach((e4) => {
              e4 !== t3 && i2.add("".concat(e4, " --> ").concat(r3, "ing : ").concat(r3));
            });
          });
          let a2 = [...i2];
          return Object.defineProperties(e2, { stateDiagram: { value: a2 }, allStates: { value: o2 } }), a2;
        }
        static get(e2) {
          let t2;
          return "string" == typeof e2 ? (t2 = $x.instances.get(e2), t2 || $x.instances.set(e2, t2 = new $x(e2, void 0, Object.create($x.prototype)))) : (t2 = $x.instances2.get(e2), t2 || $x.instances2.set(e2, t2 = new $x(e2.constructor.name, void 0, Object.create($x.prototype)))), t2;
        }
        static getState(e2) {
          var t2;
          return null === (t2 = $x.get(e2)) || void 0 === t2 ? void 0 : t2.state;
        }
        updateDevTools() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          Qx($x.UPDATEAFSM, Object.assign({ name: this.name, group: this.groupName }, e2));
        }
        get state() {
          return this._state;
        }
        set state(e2) {
          Xx.call(this, e2);
        }
      };
      $x.STATECHANGED = "stateChanged", $x.UPDATEAFSM = "updateAFSM", $x.INIT = "[*]", $x.ON = "on", $x.OFF = "off", $x.instances = /* @__PURE__ */ new Map(), $x.instances2 = /* @__PURE__ */ new WeakMap();
      var Zx = nb(lb()), eV = "1", tV = "5", iV = "2", rV = "3", nV = "5", oV = "4", sV = { CLIENT_BANNED: 9, CHANNEL_SETUP_RESULT: 19, CHANNEL_RECONNECT_RESULT: 514, JOIN_ROOM_RESULT: 20, PEER_JOIN: 4134, PEER_LEAVE: 4135, STREAM_ADDED: 16, STREAM_REMOVED: 18, UPLINK_NETWORK_STATS: 22, UPDATE_REMOTE_MUTE_STAT: 23, PUBLISH_RESULT: 4098, PUBLISH_STATE_CHANGE_RESULT: 4112, UNPUBLISH_RESULT: 4100, SUBSCRIBE_RESULT: 4102, UNSUBSCRIBE_RESULT: 4104, SUBSCRIBE_CHANGE_RESULT: 4106, MUTE_RESULT: 4108, UPDATE_OFFER_RESULT: 4128, START_PUBLISH_TENCENT_CDN_RES: 1286, STOP_PUBLISH_TENCENT_CDN_RES: 1288, START_PUBLISH_GIVEN_CDN_RES: 777, STOP_PUBLISH_GIVEN_CDN_RES: 779, START_MIX_TRANSCODE_RES: 781, STOP_MIX_TRANSCODE_RES: 783, USER_LIST_RES: 4137, SWITCH_ROLE_RES: 4110, UPDATE_CONSTRAINT_CONFIG_RES: 772, REBUILD_PEER_CONNECTION_RES: 4150, SPC_PUBLISH_RESULT: 4146, SPC_SUBSCRIBE_RESULT: 4156, ABILITY_STATUS_REPORT_RESULT: 4158, SERVER_FIRST_PACKAGE_RECEIVED: 5e3, RECEIVE_CUSTOM_MSG: 4140 }, aV = [sV.UPDATE_REMOTE_MUTE_STAT, sV.UPLINK_NETWORK_STATS, sV.USER_LIST_RES, sV.MUTE_RESULT, sV.SERVER_FIRST_PACKAGE_RECEIVED, sV.RECEIVE_CUSTOM_MSG], cV = { CLIENT_BANNED: "client-banned", CHANNEL_SETUP_RESULT: "channel-setup-result", CHANNEL_RECONNECT_RESULT: "channel-reconnect-result", JOIN_ROOM_RESULT: "join-room-result", PEER_JOIN: "peer-join", PEER_LEAVE: "peer-leave", STREAM_ADDED: "stream-added", STREAM_REMOVED: "stream-removed", UPLINK_NETWORK_STATS: "uplink-network-stats", UPDATE_REMOTE_MUTE_STAT: "update-remote-mute-stat", PUBLISH_RESULT: "publish-result", PUBLISH_STATE_CHANGE_RESULT: "publish-state-change-result", UNPUBLISH_RESULT: "unpublish-result", SUBSCRIBE_RESULT: "subscribe-result", SUBSCRIBE_CHANGE_RESULT: "subscribe-change-result", UNSUBSCRIBE_RESULT: "unsubscribe-result", UPDATE_OFFER_RESULT: "update-offer-result", START_PUBLISH_TENCENT_CDN_RES: "start-publish-tencent-cdn-res", STOP_PUBLISH_TENCENT_CDN_RES: "stop-publish-tencent-cdn-res", START_PUBLISH_GIVEN_CDN_RES: "start-publish-given-cdn-res", STOP_PUBLISH_GIVEN_CDN_RES: "stop-publish-given-cdn-res", START_MIX_TRANSCODE_RES: "start-mix-transcode-res", STOP_MIX_TRANSCODE_RES: "stop-mix-transcode-res", USER_LIST_RES: "user-list-res", SWITCH_ROLE_RES: "switch_role_res", MUTE_RESULT: "mute-result", UPDATE_CONSTRAINT_CONFIG_RES: "update-contraint-config-res", REBUILD_PEER_CONNECTION_RES: "rebuild-pc-res", SPC_PUBLISH_RESULT: "spc-publish-result", SPC_SUBSCRIBE_RESULT: "spc-subscribe-result", ABILITY_STATUS_REPORT_RESULT: "ability-status-report", SERVER_FIRST_PACKAGE_RECEIVED: "first-pkg-received", RECEIVE_CUSTOM_MSG: "receive-custom-msg" }, lV = "publish_change", dV = "join", uV = "leave", hV = "quality_report", pV = "mute_uplink", mV = "publish", _V = "publish_state_change", fV = "unpublish", gV = "subscribe", TV = "unsubscribe", EV = "subscribe_change", SV = "start_publishing", IV = "stop_publishing", vV = "start_push_user_cdn", yV = "stop_push_user_cdn", AV = "start_mcu_mix", RV = "stop_mcu_mix", CV = "get_user_list", bV = "change_role", kV = "update_constraint_config", NV = "rebuild_pc", DV = "join/v2", wV = "publish/v2", OV = "subscribe/v3", PV = "ability_status_report", MV = "reconnect", LV = "channel_msg", xV = /* @__PURE__ */ new WeakMap();
      function VV(e2) {
        let { settings: t2 = { retries: 5, timeout: 2e3 }, onError: i2, onRetrying: r2, onRetryFailed: n2 } = e2;
        return function(e3, o2, s2) {
          let a2 = ZD({ retryFunction: s2.value, settings: t2, onError(t3) {
            let { error: r3, retry: n3, reject: s3, retryFuncArgs: a3 } = t3;
            i2 && i2.call(this, r3, () => {
              var t4;
              null != (t4 = xV.get(e3)) && t4.has(o2) ? n3() : s3(r3);
            }, s3, a3);
          }, onRetrying(t3, i3) {
            var n3;
            Pw(r2) && r2.call(this, t3, i3), null != (n3 = xV.get(e3)) && n3.has(o2) && (xV.get(e3).get(o2).stopRetry = i3);
          }, onRetryFailed: n2 });
          return s2.value = function() {
            let t3 = xV.get(e3);
            for (var i3 = arguments.length, r3 = new Array(i3), n3 = 0; n3 < i3; n3++)
              r3[n3] = arguments[n3];
            return t3 ? t3.set(o2, { args: r3 }) : xV.set(e3, /* @__PURE__ */ new Map([[o2, { args: r3 }]])), a2.apply(this, r3).finally(() => {
              var t4;
              return null == (t4 = xV.get(e3)) ? void 0 : t4.delete(o2);
            });
          }, s2;
        };
      }
      function UV(e2) {
        let { fnName: t2, callback: i2, validateArgs: r2 = true } = e2;
        return function(e3, n2, o2) {
          let s2 = o2.value;
          return o2.value = function() {
            for (var n3, o3, a2 = arguments.length, c2 = new Array(a2), l2 = 0; l2 < a2; l2++)
              c2[l2] = arguments[l2];
            if (null != (n3 = xV.get(e3)) && n3.has(t2)) {
              let { stopRetry: n4, args: s3 } = xV.get(e3).get(t2), a3 = true;
              if (r2) {
                for (let e4 of s3)
                  if (!c2.find((t3) => t3 === e4)) {
                    a3 = false;
                    break;
                  }
              }
              a3 && (i2 && i2.apply(this, c2), n4 && n4(), null == (o3 = xV.get(e3)) || o3.delete(t2));
            }
            return s2.apply(this, c2);
          }, o2;
        };
      }
      var FV = /* @__PURE__ */ new Set();
      var BV = class extends Zx.default {
        constructor(e2) {
          var t2, i2;
          super(), sb(this, "room"), sb(this, "url"), sb(this, "backupUrl"), sb(this, "race"), sb(this, "destroyed", false), sb(this, "_socketInUse"), sb(this, "_socket"), sb(this, "_backupSocket"), sb(this, "_signalInfo", { tinyId: void 0, clientIp: "", signalIp: "", relayIp: "", relayInnerIp: "", relayPort: 0 }), sb(this, "_currentState", "DISCONNECTED"), sb(this, "_isReconnecting", false), sb(this, "_seq", 0), sb(this, "_log"), sb(this, "_lastMessageTime", -1), sb(this, "_connnectStartTime", -1), sb(this, "_stopConnectRetry"), sb(this, "bytesSent", 0), sb(this, "bytesReceived", 0), sb(this, "keepAlive", false), this.room = e2.room, this.race = !!Mw(e2.race) || e2.race, ((null == (i2 = null == (t2 = this.room.scheduleResult) ? void 0 : t2.config) ? void 0 : i2.keepAliveClient) || 0) - FV.size > 0 && this.room.enableSPC && (this.keepAlive = true, FV.add(this)), this.url = e2.url, this.backupUrl = e2.backupUrl, this._seq = 0, this._log = EO.createLogger({ id: "ws", userId: this.userId, sdkAppId: this.sdkAppId }), this.onmessage = this.onmessage.bind(this), this.onerror = this.onerror.bind(this), this.onclose = this.onclose.bind(this);
        }
        get urlParam() {
          let e2 = "?sdkAppId=".concat(encodeURIComponent(this.sdkAppId), "&userId=").concat(encodeURIComponent(this.userId), "&userSig=").concat(encodeURIComponent(this.userSig), "&keepAlive=").concat(encodeURIComponent(Number(this.keepAlive)));
          return this.race ? "".concat(e2, "&race=1") : e2;
        }
        get _urlWithParam() {
          return "".concat(this.url).concat(this.race ? "/v2/ws" : "").concat(this.urlParam);
        }
        get _backupUrlWithParam() {
          return "".concat(this.backupUrl).concat(this.race ? "/v2/ws" : "").concat(this.urlParam);
        }
        get isConnected() {
          return "CONNECTED" === this._currentState;
        }
        get isConnecting() {
          return "CONNECTING" === this._currentState;
        }
        get sdkAppId() {
          return this.room.sdkAppId;
        }
        get userId() {
          return this.room.userId;
        }
        get userSig() {
          return this.room.userSig;
        }
        get isOnline() {
          return "CONNECTED" === this._currentState && Date.now() - this._lastMessageTime < 12e3;
        }
        connect() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e4;
            return function* () {
              if (e2.isConnected)
                return Promise.resolve();
              e2._log.info("connect to [".concat(e2.url, ", ").concat(e2.backupUrl, "]").concat(t2 ? " timeout: ".concat(t2) : "", " keepAlive: ").concat(Number(e2.keepAlive))), e2.emitConnectionStateChanged("CONNECTING"), e2._connnectStartTime = zw();
              let i2 = [e2.connectWS({ url: e2._urlWithParam, isMain: true, timeout: t2 })];
              e2.race && e2._backupUrlWithParam !== e2._urlWithParam && i2.push(e2.connectWS({ url: e2._backupUrlWithParam, isMain: false, timeout: t2 })), e2._socketInUse = yield Kw(i2), e2.unbindAndCloseSocket(e2._socketInUse === e2._socket ? ok.BACKUP : ok.MAIN), e2.emitConnectionStateChanged("CONNECTED");
            }();
          });
        }
        connectWS(e2) {
          let { url: t2, timeout: i2, isMain: r2 } = e2, n2 = new WebSocket(t2);
          this.bindSocket(n2), r2 ? this._socket = n2 : this._backupSocket = n2;
          let o2 = -1;
          return new Promise((e3, t3) => {
            n2.onclose = t3, n2.onerror = t3, n2.onopen = () => e3(n2), i2 && (o2 = setTimeout(() => {
              this.unbindAndCloseSocket(r2 ? ok.MAIN : ok.BACKUP), t3(new vb({ code: Sb.SIGNAL_CHANNEL_SETUP_FAILED, message: "ws connect timeout" }));
            }, i2));
          }).finally(() => {
            n2.onclose = null, n2.onerror = null, n2.onopen = null, clearTimeout(o2);
          });
        }
        bindSocket(e2) {
          e2.addEventListener("close", this.onclose), e2.addEventListener("error", this.onerror), e2.addEventListener("message", this.onmessage);
        }
        unbindSocket(e2) {
          e2.removeEventListener("close", this.onclose), e2.removeEventListener("error", this.onerror), e2.removeEventListener("message", this.onmessage);
        }
        unbindAndCloseSocket(e2) {
          if (e2 === ok.MAIN) {
            if (this._socket) {
              this.unbindSocket(this._socket);
              try {
                this._socket.close(1e3);
              } catch (wk2) {
              }
              this._socket = null;
            }
          } else if (this._backupSocket) {
            this.unbindSocket(this._backupSocket);
            try {
              this._backupSocket.close(1e3);
            } catch (wk2) {
            }
            this._backupSocket = null;
          }
        }
        onclose(e2) {
          if (e2.target === this._socketInUse && (this._log.warn("".concat(e2.target === this._socket ? "main" : "backup", " is closed code:").concat(e2.code, " ").concat(e2.reason)), this.emitConnectionStateChanged("DISCONNECTED"), !e2.wasClean || 1e3 !== e2.code)) {
            this._socketInUse.onclose = null, this._socketInUse.close(4011);
            let e3 = this._socketInUse === this._socket;
            this.unbindAndCloseSocket(e3 ? ok.MAIN : ok.BACKUP), this._socketInUse = null, this.reconnect();
          }
        }
        onerror(e2) {
          this._log.error("".concat(e2.target === this._socket ? "main" : "backup", " error observed")), e2.target === this._socketInUse && (this.unbindAndCloseSocket(ok.MAIN), this.unbindAndCloseSocket(ok.BACKUP), this._socketInUse = null, this.reconnect());
        }
        onmessage(e2) {
          if (!this.isConnected)
            return;
          this._lastMessageTime = Date.now(), this.bytesReceived += lO(e2.data);
          let t2 = JSON.parse(e2.data), { cmd: i2, data: r2 } = t2, n2 = Object.values(sV), o2 = Object.keys(sV)[n2.indexOf(i2)], s2 = cV[o2];
          switch (aV.includes(i2) || (this._log.debug("received ".concat(i2, " msg: ").concat(e2.data)), s2 && this._log.info("Received event: [ ".concat(s2, " ]"))), i2) {
            case sV.CHANNEL_SETUP_RESULT:
              if (0 === t2.code)
                this._signalInfo.clientIp = r2.clientIp, this._signalInfo.signalIp = r2.signalInnerIp, r2.svrTime && function(e3) {
                  yb = e3 - (/* @__PURE__ */ new Date()).getTime();
                  let t3 = /* @__PURE__ */ new Date();
                  t3.setTime(e3), EO.info("baseTime from server: ".concat(t3, " offset: ").concat(yb));
                }(r2.svrTime), this._log.info("ChannelSetup Success"), mM.addSuccessEvent({ key: 521701, cost: zw() - this._connnectStartTime }), this._connnectStartTime = -1, this.emit(eV, { signalInfo: this._signalInfo });
              else {
                let e3 = new vb({ code: Sb.SIGNAL_CHANNEL_SETUP_FAILED, extraCode: t2.code, message: XD({ key: uN.SIGNAL_CHANNEL_SETUP_FAILED, data: { errorCode: t2.code, errorMsg: t2.message } }) });
                this._log.error("".concat(t2.code, ", ").concat(t2.message)), this.close(), mM.addFailedEvent({ key: 521701, error: e3 }), this.emit(tV, e3);
              }
              break;
            case sV.JOIN_ROOM_RESULT:
              0 === t2.code && (this._signalInfo.relayIp = r2.relayOuterIp, this._signalInfo.relayInnerIp = r2.relayInnerIp, this._signalInfo.relayPort = r2.relayPort, this._signalInfo.tinyId = t2.tinyId, this._log.info("signalIp:".concat(this._signalInfo.signalIp, " clientIp:").concat(this._signalInfo.clientIp, " relayIp: ").concat(this._signalInfo.relayIp))), this.emit(s2, { data: t2 });
              break;
            default:
              this.emit(s2, { data: t2 });
          }
        }
        reGetSignalChannelUrl() {
          return cb(this, null, function* () {
            try {
              ow(true), yield this.room.schedule(this.room.roomId);
              let { mainUrl: e2, backupUrl: t2 } = this.room.getSignalChannelUrl();
              this.url = e2, this.backupUrl = t2;
            } catch (wb2) {
            }
          });
        }
        reconnect() {
          return cb(this, null, function* () {
            if (!this._isReconnecting) {
              if (!this.room.isJoined && this.keepAlive)
                return void this.close();
              this._isReconnecting = true;
              try {
                this._log.warn("reconnect"), yield this.connect();
                let { roomId: e2, useStringRoomId: t2 } = this.room, { relayIp: i2, relayInnerIp: r2, relayPort: n2 } = this._signalInfo, { data: o2 } = yield this.sendWaitForResponse({ command: MV, data: { roomId: e2, useStringRoomId: t2, relayInnerIp: r2, relayOuterIp: i2, relayPort: n2 }, responseCommand: cV.CHANNEL_RECONNECT_RESULT });
                0 === o2.code ? (this._log.warn("reconnect success"), this.stopReconnection(), mM.addSuccessEvent({ key: 521702, cost: zw() - this._connnectStartTime }), this._connnectStartTime = -1, this.room.syncUserList(), this.room.checkConnectionsToReconnect()) : (mM.addFailedEvent({ key: 521702, error: o2.code }), this._log.warn("reconnect failed, ".concat(o2.code, " ").concat(o2.message)), this.room.reJoin());
              } catch (wb2) {
                this._log.error(wb2), this.room.reJoin();
              }
            }
          });
        }
        send(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (this.isConnected && !this.room.isLeft) {
            let i2 = { cmd: e2, data: t2, userId: this.userId, tinyId: this._signalInfo.tinyId, seq: ++this._seq }, r2 = JSON.stringify(i2);
            return this._socketInUse.send(r2), this.bytesSent += lO(r2), i2.seq;
          }
        }
        sendWaitForResponse(e2) {
          let { command: t2, data: i2, timeout: r2 = 5e3, responseCommand: n2, commandDesc: o2, enableLog: s2 = true } = e2;
          return new Promise((e3, a2) => {
            let c2 = setTimeout(() => {
              this.off(n2, l2);
              let e4 = new vb({ code: Sb.API_CALL_TIMEOUT, message: XD({ key: uN.API_CALL_TIMEOUT, data: { commandDesc: o2, command: t2 } }) });
              s2 && this._log.warn(e4), a2(e4);
            }, r2), l2 = (t3) => {
              t3.data.seq === d2 && (clearTimeout(c2), this.off(n2, l2), e3(t3));
            };
            this.on(n2, l2);
            let d2 = this.send(t2, i2);
          });
        }
        sendWaitForResponseWithRetry(e2) {
          let { commandDesc: t2, command: i2, retries: r2 = 0, retryTimeout: n2 = 0 } = e2;
          return ZD({ retryFunction: this.sendWaitForResponse, onError: (e3) => {
            let { retry: t3 } = e3;
            this.isOnline ? t3() : (this._log.warn("retry ".concat(i2, " when connected")), this.once(rV, t3));
          }, onRetrying: (e3) => {
            this._log.warn("".concat(t2 || i2, " timeout observed, retrying [").concat(e3, "/").concat(r2, "]"));
          }, settings: { retries: r2, timeout: n2 }, context: this })(e2);
        }
        getCurrentState() {
          return this._currentState;
        }
        getSignalInfo() {
          return this._signalInfo;
        }
        stopReconnection() {
          this._isReconnecting = false, this._stopConnectRetry && this._stopConnectRetry();
        }
        close() {
          this._log.info("closed"), FV.delete(this), this.stopReconnection(), this._signalInfo = { tinyId: void 0, clientIp: "", signalIp: "", relayIp: "", relayInnerIp: "", relayPort: 0 }, this._socketInUse = null, this.bytesSent = 0, this.bytesReceived = 0, this._stopConnectRetry && this._stopConnectRetry(), this.unbindAndCloseSocket(ok.MAIN), this.unbindAndCloseSocket(ok.BACKUP), this.emitConnectionStateChanged("DISCONNECTED");
        }
        destroy() {
          this.close(), this.destroyed = true;
        }
        stopKeepAliveIn() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3600;
          if (this.keepAlive) {
            this._log.info("stopKeepAlive in ".concat(e2, "s"));
            let t2 = setTimeout(() => {
              this.keepAlive = false, this._log.info("close due to not used ".concat(e2, "s")), this.close();
            }, 1e3 * e2), i2 = (e3) => {
              e3 instanceof Kx && "join" === e3.action && (this._log.info("stopKeepAlive clear timeout"), clearTimeout(t2), this.room.off($x.STATECHANGED, i2));
            };
            this.room.on($x.STATECHANGED, i2);
          }
        }
        emitConnectionStateChanged(e2) {
          e2 !== this._currentState && (this._log.info("".concat(this._currentState, " -> ").concat(e2)), this.emit(iV, { prevState: this._currentState, state: e2 }), this._currentState = e2, "CONNECTED" === e2 ? this.emit(rV) : "DISCONNECTED" === e2 && this.emit(nV));
        }
      };
      ob([VV({ settings: { retries: 1 / 0, timeout: 2e3 }, onError(e2, t2) {
        !this.room.isDestroyed && !this.destroyed && t2();
      }, onRetrying(e2, t2) {
        this._log.warn("retrying to connect ".concat(e2)), e2 >= 3 && e2 % 3 == 0 && this.reGetSignalChannelUrl(), t2 && (this._stopConnectRetry = t2, (this.room.isDestroyed || this.destroyed) && t2());
      } })], BV.prototype, "connect", 1);
      var HV = nb(lb()), jV = 0, GV = false, WV = /* @__PURE__ */ new Set(), JV = false, KV = class {
        constructor(e2) {
          sb(this, "userId"), sb(this, "tinyId"), sb(this, "_sdpSemantics"), sb(this, "_isUplink"), sb(this, "_room"), sb(this, "_log"), sb(this, "_signalChannel"), sb(this, "_isErrorObserved", false), sb(this, "_waitForPeerConnectionConnectedPromise"), sb(this, "_waitForPeerConnectionConnectedPromiseReject", null), sb(this, "_peerConnection", null), sb(this, "_emitter", new HV.default()), sb(this, "_currentState", "DISCONNECTED"), sb(this, "_isReconnecting", false), sb(this, "_reconnectionCount", 0), sb(this, "_reconnectionTimer", -1), sb(this, "_isFirstConnection", true), sb(this, "_prevTime", -1), sb(this, "_enableSEI"), sb(this, "_sei"), sb(this, "_localAddress"), sb(this, "_remoteAddress"), this.userId = e2.userId, this.tinyId = e2.tinyId, this._room = e2.room, this._sdpSemantics = e2.room.sdpSemantics, this._isUplink = e2.isUplink, this._log = EO.createLogger({ id: "n-mpc", userId: this._room.userId, remoteUserId: this.userId, sdkAppId: this._room.sdkAppId, isLocal: this._isUplink }), this._signalChannel = e2.signalChannel, this._enableSEI = e2.enableSEI;
        }
        beforeConnect() {
          this._prevTime < 0 && (this._prevTime = zw());
        }
        afterConnect(e2) {
          return cb(this, null, function* () {
            try {
              yield e2, this._isFirstConnection ? (this._isFirstConnection = false, mM.addSuccessEvent({ key: 521705, cost: Math.min(zw() - this._prevTime, 3e4) })) : this._isReconnecting && mM.addSuccessEvent({ key: 521706, cost: zw() - this._prevTime }), this._prevTime = -1;
            } catch (wb2) {
              throw this._isFirstConnection ? (this._isFirstConnection = false, mM.addFailedEvent({ key: 521705, error: wb2 })) : this._isReconnecting && this._reconnectionCount >= 3 && mM.addFailedEvent({ key: 521706, error: wb2 }), wb2;
            }
          });
        }
        initialize() {
          let e2 = { encodedInsertableStreams: this._enableSEI && iP, iceServers: this._room.getIceServers(), iceTransportPolicy: this._room.getIceTransportPolicy(), sdpSemantics: this._sdpSemantics, bundlePolicy: "max-bundle", rtcpMuxPolicy: "require", tcpCandidatePolicy: "disable", IceTransportsType: "nohost" };
          this._peerConnection = new RTCPeerConnection(e2), this._peerConnection.onconnectionstatechange = this.onConnectionStateChange.bind(this);
        }
        close(e2) {
          this._log.info("close connection"), this._emitter.emit("closed", e2), this._isReconnecting && this.stopReconnection(), this.closePeerConnection(), this._sei && (this._sei.destroy(), this._sei = null), WV.delete(this);
        }
        closePeerConnection() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          this._peerConnection && (this._log.info("close pc"), this._peerConnection.onconnectionstatechange = null, this._peerConnection.close(), this._peerConnection = null, e2 && this.emitConnectionStateChangedEvent("DISCONNECTED")), this._waitForPeerConnectionConnectedPromiseReject && this._waitForPeerConnectionConnectedPromiseReject(new vb({ code: Sb.API_CALL_ABORTED, message: "connection closed" }));
        }
        getDTLSTransportState() {
          if (!this._peerConnection)
            return Ck;
          let e2 = null;
          if (this._isUplink) {
            if (!zO() || 0 === this._peerConnection.getSenders().length)
              return Ck;
            e2 = this._peerConnection.getSenders()[0].transport;
          } else {
            if (!KO() || 0 === this._peerConnection.getReceivers().length)
              return Ck;
            e2 = this._peerConnection.getReceivers()[0].transport;
          }
          return e2 ? e2.state : Ck;
        }
        onConnectionStateChange(e2) {
          let t2 = this._peerConnection.iceConnectionState, i2 = this.getDTLSTransportState();
          if (this._log.info("connectionState: ".concat(e2.target.connectionState, ", ICE: ").concat(t2, ", DTLS: ").concat(i2)), e2.target.connectionState === bk.CONNECTING && this.emitConnectionStateChangedEvent("CONNECTING"), e2.target.connectionState === bk.FAILED || e2.target.connectionState === bk.CLOSED) {
            let r2 = "connection ".concat(e2.target.connectionState, ". ICE Transport state: ").concat(t2, ", DTLS Transport state: ").concat(i2), n2 = new vb({ message: r2, code: Sb.ICE_TRANSPORT_ERROR });
            this.emitConnectionStateChangedEvent("DISCONNECTED"), this.startReconnection(), this._isErrorObserved || this._emitter.emit("error", n2);
          }
          (e2.target.connectionState === bk.CONNECTED || e2.target.connectionState === bk.COMPLETED) && (this.logSelectedCandidate(), iw.logSuccessEvent({ userId: this._room.userId, eventType: Pk.ICE_CONNECTION_STATE }), this.emitConnectionStateChangedEvent("CONNECTED"));
        }
        emitConnectionStateChangedEvent(e2) {
          return e2 !== this._currentState && ("CONNECTED" === e2 ? (jV = 0, GV = false, JV = true, WV.add(this)) : WV.delete(this), ew.emit(gO.PEER_CONNECTION_STATE_CHANGED, { room: this._room, prevState: this._currentState, state: e2, remoteUserId: this._isUplink ? void 0 : this.userId }), this._emitter.emit("connection-state-changed", { prevState: this._currentState, state: e2 }), this._currentState = e2, true);
        }
        getPeerConnection() {
          return this._peerConnection;
        }
        getRoom() {
          return this._room;
        }
        getUserId() {
          return this.userId;
        }
        getTinyId() {
          return this.tinyId;
        }
        logSelectedCandidate() {
          return cb(this, null, function* () {
            if (!this._peerConnection)
              return;
            let e2 = yield this._peerConnection.getStats();
            for (let [, t2] of e2)
              if (FO(t2)) {
                let i2 = e2.get(t2.localCandidateId), r2 = e2.get(t2.remoteCandidateId);
                i2 && (this._log.info("local candidate: ".concat(i2.candidateType, " ").concat(i2.protocol, ":").concat(i2.ip || i2.address, ":").concat(i2.port, " ").concat(i2.networkType || "", " ").concat("relay" === i2.candidateType ? "relayProtocol:".concat(i2.relayProtocol) : "")), this._localAddress = "".concat(i2.ip || i2.address, ":").concat(i2.port)), r2 && (this._log.info("remote candidate: ".concat(r2.candidateType, " ").concat(r2.protocol, ":").concat(r2.ip || r2.address, ":").concat(r2.port)), this._remoteAddress = "".concat(r2.protocol, ":").concat(r2.ip || r2.address));
                break;
              }
          });
        }
        getCurrentState() {
          return this._currentState;
        }
        waitForPeerConnectionConnected() {
          return this._waitForPeerConnectionConnectedPromise || (this._waitForPeerConnectionConnectedPromise = new Promise((e2, t2) => {
            if ("CONNECTED" === this._currentState)
              return e2();
            this._waitForPeerConnectionConnectedPromiseReject = t2;
            let i2 = (t3) => {
              "CONNECTED" === t3.state && (clearTimeout(o2), n2(), e2());
            }, r2 = (e3) => {
              let { room: i3 } = e3;
              i3 === this._room && (clearTimeout(o2), n2(), t2(new vb({ code: Sb.API_CALL_ABORTED, message: XD({ key: uN.CONNECTION_ABORTED, data: "leave room" }) })));
            }, n2 = () => {
              ew.off(gO.LEAVE_SUCCESS, r2, this), this._emitter.off("connection-state-changed", i2, this);
            }, o2 = setTimeout(() => {
              n2();
              let e3 = new vb({ code: Sb.API_CALL_TIMEOUT, message: "connection timeout" });
              var i3;
              jV += 1, i3 = this._signalChannel.isConnected, jV > 2 && !GV && 0 === WV.size && i3 && (this._log.warn("firewall restriction"), GV = true, this._emitter.emit("firewall-restriction")), t2(e3);
            }, Jk);
            ew.on(gO.LEAVE_SUCCESS, r2, this), this._emitter.on("connection-state-changed", i2, this);
          }), this._waitForPeerConnectionConnectedPromise = this._waitForPeerConnectionConnectedPromise.finally(() => {
            this._waitForPeerConnectionConnectedPromise = null, this._waitForPeerConnectionConnectedPromiseReject = null;
          })), this._waitForPeerConnectionConnectedPromise;
        }
        getReconnectionCount() {
          return this._reconnectionCount;
        }
        startReconnection() {
          this._isReconnecting = true, this.reconnect();
        }
        clearReconnectionTimer() {
          -1 !== this._reconnectionTimer && (clearTimeout(this._reconnectionTimer), this._reconnectionTimer = -1);
        }
        stopReconnection() {
          this._log.info("stop reconnection"), this._isReconnecting = false, this._reconnectionCount = 0, this.clearReconnectionTimer(), this._signalChannel.off(rV, this.reconnect, this);
        }
        beforeReconnect() {
          if (-1 !== this._reconnectionTimer)
            return this._log.warn("reconnect() is reconnecting, ignore"), -1;
          if (this._reconnectionCount >= Dk()) {
            this._log.warn("SDK has tried reconnect for ".concat(this._reconnectionCount, " times, but all failed, please check your network")), this.stopReconnection();
            let e2 = new vb({ code: this._isUplink ? Sb.UPLINK_RECONNECTION_FAILED : Sb.DOWNLINK_RECONNECTION_FAILED, message: XD({ key: this._isUplink ? uN.UPLINK_RECONNECTION_FAILED : uN.DOWNLINK_RECONNECTION_FAILED }) });
            return this.emitConnectionStateChangedEvent("DISCONNECTED"), this._emitter.emit("error", e2), -1;
          }
          return this._signalChannel.isConnected ? (this._reconnectionCount += 1, this._log.warn("reconnect() trying [".concat(this._reconnectionCount, "]")), 1) : (this._log.warn("reconnect() signal channel is not connected, suspend reconnection until signal is connected"), this._signalChannel.once(rV, this.reconnect, this), -1);
        }
        on(e2, t2, i2) {
          this._emitter.on(e2, t2, i2);
        }
        off(e2, t2, i2) {
          this._emitter.off(e2, t2, i2);
        }
        getIsReconnecting() {
          return this._isReconnecting;
        }
        get isH264() {
          var e2, t2;
          return !(null == (t2 = null == (e2 = this._peerConnection) ? void 0 : e2.remoteDescription) || !t2.sdp.includes("H264"));
        }
      }, zV = nb(gb()), qV = function(e2) {
        return zV.default.parse(e2);
      }, YV = function(e2) {
        return zV.default.write(e2);
      };
      function QV(e2) {
        return Object.keys(e2).filter((t2) => e2[t2]);
      }
      var XV = class extends KV {
        constructor(e2) {
          super(tb(eb({}, e2), { isUplink: false })), sb(this, "_flag", 0), sb(this, "role", "anchor"), sb(this, "remoteAudioTrack"), sb(this, "remoteVideoTrack"), sb(this, "remoteAuxiliaryTrack"), sb(this, "ssrc", { audio: 0, video: 0, auxiliary: 0 }), sb(this, "_isSDPExchanging", false), this.flag = e2.flag, this.remoteAudioTrack = e2.remoteAudioTrack || new EL(this._room, this), this.remoteVideoTrack = e2.remoteVideoTrack || new SL(this._room, this), this.remoteAuxiliaryTrack = e2.remoteAuxiliaryTrack || new IL(this._room, this);
        }
        get subscribeState() {
          let e2 = { audio: false, video: false, auxiliary: false, smallVideo: false };
          return this.remoteVideoTrack.isSubscribed && (8 & this.remoteVideoTrack.mediaType ? e2.smallVideo = true : e2.video = true), this.remoteAudioTrack.isSubscribed && (e2.audio = true), this.remoteAuxiliaryTrack.isSubscribed && (e2.auxiliary = true), e2;
        }
        get muteState() {
          return $w(this.flag, this.userId);
        }
        get flag() {
          return this._flag;
        }
        set flag(e2) {
          var t2, i2, r2;
          e2 !== this._flag && (this._flag = e2, null == (t2 = this.remoteAudioTrack) || t2.onFlagChanged(), null == (i2 = this.remoteVideoTrack) || i2.onFlagChanged(), null == (r2 = this.remoteAuxiliaryTrack) || r2.onFlagChanged());
        }
        get hasMainStream() {
          return this.muteState.hasAudio || this.muteState.hasVideo || this.muteState.hasSmall;
        }
        get hasAuxStream() {
          return this.muteState.hasAuxiliary;
        }
        get isMainStreamSubscribed() {
          return (this.subscribeState.audio || this.subscribeState.video || this.subscribeState.smallVideo) && (this.muteState.hasAudio || this.muteState.hasVideo || this.muteState.hasSmall);
        }
        get isAuxStreamSubscribed() {
          return this.subscribeState.auxiliary && this.muteState.hasAuxiliary;
        }
        get isSmallStreamSubscribed() {
          return this.subscribeState.smallVideo && this.muteState.hasSmall;
        }
        get isBigStreamSubscribed() {
          return this.subscribeState.video && this.muteState.hasVideo;
        }
        isStreamUnpublished(e2) {
          return e2 === ok.MAIN ? !this.muteState.hasAudio && !this.muteState.hasVideo : !this.muteState.hasAuxiliary;
        }
        initialize() {
          super.initialize(), this.installEvents(), this._peerConnection.ontrack = this.onTrack.bind(this);
        }
        close(e2) {
          super.close(e2), this.emitConnectionStateChangedEvent("DISCONNECTED"), this.remoteAudioTrack.close(), this.remoteVideoTrack.close(), this.remoteAuxiliaryTrack.close(), this.uninstallEvents();
        }
        installEvents() {
        }
        uninstallEvents() {
          this._emitter.removeAllListeners();
        }
        emitConnectionStateChangedEvent(e2) {
          var t2, i2;
          let r2 = this._currentState, n2 = super.emitConnectionStateChangedEvent(e2);
          return n2 && r2 !== e2 && (null == (t2 = this.remoteVideoTrack) || t2.emit("connection-state-changed", { prevState: r2, state: e2 }), null == (i2 = this.remoteAuxiliaryTrack) || i2.emit("connection-state-changed", { prevState: r2, state: e2 })), n2;
        }
        onTrack(e2) {
          let t2 = e2.streams[0], { track: i2 } = e2, r2 = t2.id === _k ? ok.MAIN : ok.AUXILIARY;
          this._log.debug("ontrack ".concat(r2, " ").concat(i2.kind));
          let n2 = ok.AUDIO;
          i2.kind === ok.VIDEO && (n2 = r2 === ok.MAIN ? ok.VIDEO : ok.AUXILIARY);
          let o2 = this.remoteAudioTrack;
          n2 === ok.VIDEO ? o2 = this.remoteVideoTrack : n2 === ok.AUXILIARY && (o2 = this.remoteAuxiliaryTrack), o2.setInputMediaStreamTrack(i2);
        }
        addRRTRLine(e2) {
          let t2 = e2.split("\r\n"), i2 = /* @__PURE__ */ new Map();
          t2.forEach((e3, r3) => {
            /^a=rtcp-fb:/.test(e3) && t2[r3 + 1] && !/^a=rtcp-fb:/.test(t2[r3 + 1]) && i2.set(r3 + 1, "".concat(e3.match(/^a=rtcp-fb:\d+/)[0], " rrtr"));
          });
          let r2 = [...i2];
          for (let n2 = 0; n2 < r2.length; n2++) {
            let [e3, i3] = r2[n2];
            t2.splice(e3 + n2, 0, i3);
          }
          return t2.join("\r\n");
        }
        addSPSDescription(e2) {
          let t2 = qV(e2);
          return t2.media.forEach((e3) => {
            e3.type === ok.VIDEO && e3.fmtp.forEach((e4) => {
              e4.config += ";sps-pps-idr-in-keyframe=1";
            });
          }), YV(t2);
        }
        removeSDESDescription(e2) {
          let t2 = ["urn:ietf:params:rtp-hdrext:sdes:mid", "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id", "urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id"], i2 = qV(e2);
          return i2.media.forEach((e3) => {
            !e3.ext || (e3.ext = e3.ext.filter((e4) => !t2.includes(e4.uri)));
          }), YV(i2);
        }
        isSubscriptionStateNotChanged(e2) {
          return JSON.stringify(e2) === JSON.stringify(this.subscribeState);
        }
        subscribe(e2, t2) {
          return cb(this, null, function* () {
            var i2, r2;
            try {
              if (((null == (i2 = this._peerConnection) ? void 0 : i2.connectionState) === bk.NEW || (null == (r2 = this._peerConnection) ? void 0 : r2.connectionState) === bk.CONNECTING) && (yield this.waitForPeerConnectionConnected()), this.isSubscriptionStateNotChanged(e2))
                return void (this._peerConnection || (this.initialize(), yield this.connect(e2)));
              if (this._log.info("subscribe ".concat(t2, " ").concat(JSON.stringify(e2))), this._peerConnection || this._isSDPExchanging) {
                let t3 = "subscribe_change";
                Object.values(e2).find((e3) => true === e3) || (t3 = "unsubscribe"), yield this.sendSubscription(t3, e2);
              } else
                this.initialize(), yield this.connect(e2);
            } catch (Pb2) {
              throw this._room.isJoined && this.isStreamUnpublished(t2) ? (this._log.warn("".concat(Pb2.message, " ").concat(JSON.stringify(this.muteState))), new vb({ code: Sb.REMOTE_STREAM_NOT_EXIST, message: "remote user ".concat(this.userId, " unpublished stream") })) : Pb2;
            }
          });
        }
        unsubscribe(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { remoteTracks: i2, streamType: r2 } = e3;
            return function* () {
              if ("CONNECTED" === t2._currentState && ("main" === r2 && !t2.isMainStreamSubscribed || "auxiliary" === r2 && !t2.isAuxStreamSubscribed))
                return void t2._log.info("".concat(r2, " stream already unsubscribed"));
              let e4 = eb({}, t2.subscribeState);
              i2.forEach((t3) => {
                switch (t3.mediaType) {
                  case 1:
                    e4.audio = false;
                    break;
                  case 4:
                    e4.video = false;
                    break;
                  case 8:
                    e4.smallVideo = false;
                    break;
                  case 2:
                    e4.auxiliary = false;
                }
              });
              let n2 = "subscribe_change";
              Object.values(e4).find((e5) => true === e5) || (n2 = "unsubscribe"), t2._log.info("".concat("unsubscribe" === n2 ? n2 : "subscribe", " ").concat(r2, " [").concat(QV(e4), "]")), yield t2.sendSubscription(n2, e4), "unsubscribe" === n2 && (t2.closePeerConnection(), t2.emitConnectionStateChangedEvent("DISCONNECTED"));
            }();
          });
        }
        sendSubscription(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.subscribeState, i2 = { srcTinyId: this.tinyId, srcUserId: this.userId }, r2 = TV, n2 = cV.UNSUBSCRIBE_RESULT;
          return "subscribe_change" === e2 && (i2 = { audio: t2.audio, bigVideo: t2.video, auxVideo: t2.auxiliary, smallVideo: t2.smallVideo, srcTinyId: this.tinyId }, r2 = EV, n2 = cV.SUBSCRIBE_CHANGE_RESULT), this._signalChannel.sendWaitForResponse({ command: r2, data: i2, responseCommand: n2, timeout: 1e4 }).then((t3) => {
            let { data: i3 } = t3;
            if (0 !== i3.code) {
              let t4 = new vb({ code: i3.code, message: XD({ key: uN.ERROR_MESSAGE, data: { type: e2, message: i3.message } }) });
              throw this._log.error(t4), t4;
            }
          });
        }
        connect() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.subscribeState;
            return function* () {
              try {
                yield e2.exchangeSDP(t2), yield e2.waitForPeerConnectionConnected();
              } catch (wk2) {
                throw e2.closePeerConnection(true), wk2;
              }
            }();
          });
        }
        exchangeSDP(e2) {
          return cb(this, null, function* () {
            try {
              this._isSDPExchanging = true, yield this.createOffer(), this._log.info("createOffer success, sending offer");
              let { type: t2, sdp: i2 } = this._peerConnection.localDescription, r2 = { type: t2, sdp: i2, srcUserId: this.userId, srcTinyId: this.tinyId, audio: e2.audio, bigVideo: e2.video, auxVideo: e2.auxiliary, smallVideo: e2.smallVideo }, n2 = yield this._signalChannel.sendWaitForResponse({ command: gV, commandDesc: "exchange sdp", data: r2, responseCommand: cV.SUBSCRIBE_RESULT, timeout: xk });
              if (!this._peerConnection) {
                let e3 = new vb({ code: Sb.INVALID_OPERATION, message: XD({ key: uN.CONNECTION_CLOSED }) });
                throw this._log.warn(e3), e3;
              }
              yield this.onSubscribeResult(n2), this._isSDPExchanging = false;
            } catch (wk2) {
              throw this._isSDPExchanging = false, wk2;
            }
          });
        }
        createOffer() {
          return cb(this, null, function* () {
            let e2 = { voiceActivityDetection: false };
            YO() && this._sdpSemantics === Vk ? (this._peerConnection.addTransceiver(ok.AUDIO, { direction: sk.RECVONLY }), this._peerConnection.addTransceiver(ok.VIDEO, { direction: sk.RECVONLY }), this._peerConnection.addTransceiver(ok.VIDEO, { direction: sk.RECVONLY })) : (e2.offerToReceiveAudio = true, e2.offerToReceiveVideo = true);
            let t2 = yield this._peerConnection.createOffer(e2);
            if (t2.sdp) {
              let { isH264DecodeSupported: e3 } = yield MO();
              e3 || (this._log.warn("remove h264 desc from sdp"), t2.sdp = function(e4) {
                let t3 = qV(e4);
                return t3.media.forEach((e5) => {
                  var t4, i2;
                  if (e5.type === ok.VIDEO) {
                    let r2 = /* @__PURE__ */ new Set();
                    e5.rtp.forEach((e6) => {
                      let { payload: t5, codec: i3 } = e6;
                      return "H264" === i3 && r2.add(t5);
                    }), e5.fmtp.forEach((e6) => {
                      let { payload: t5, config: i3 } = e6, n3 = i3.match(/apt=(\d+)/);
                      n3 && n3[1] && r2.has(Number(n3[1])) && r2.add(t5);
                    });
                    let n2 = (e6) => {
                      let { payload: t5 } = e6;
                      return !r2.has(t5);
                    };
                    e5.rtp = e5.rtp.filter(n2), e5.rtcpFb = null == (t4 = e5.rtcpFb) ? void 0 : t4.filter(n2), e5.fmtp = e5.fmtp.filter(n2), e5.payloads = null == (i2 = e5.payloads) ? void 0 : i2.split(" ").filter((e6) => !r2.has(Number(e6))).join(" ");
                  }
                }), YV(t3);
              }(t2.sdp)), t2.sdp = this.addRRTRLine(t2.sdp), t2.sdp = this.addSPSDescription(t2.sdp), t2.sdp = function(e4) {
                let t3 = qV(e4);
                return t3.media.forEach((e5) => {
                  e5.type === ok.AUDIO && e5.fmtp.forEach((e6) => {
                    e6.config += ";sprop-stereo=1;stereo=1";
                  });
                }), YV(t3);
              }(t2.sdp), this._sdpSemantics === Vk && (t2.sdp = this.removeSDESDescription(t2.sdp));
            }
            yield this._peerConnection.setLocalDescription(t2);
          });
        }
        onSubscribeResult(e2) {
          return cb(this, null, function* () {
            let { code: t2, message: i2 = "" } = e2 && e2.data || {}, { type: r2, sdp: n2 } = e2 && e2.data && e2.data.data || {};
            if (t2 === Fk)
              throw new vb({ code: Sb.NOT_SUPPORTED_H264, message: XD({ key: uN.NOT_SUPPORTED_H264DECODE }) });
            try {
              if (0 !== t2)
                throw new vb({ code: t2, message: XD({ key: uN.EXCHANGE_SDP_FAILED, data: { errMsg: i2 } }) });
              this._log.debug("accept remote answer: ".concat(n2)), yield this._peerConnection.setRemoteDescription({ type: r2, sdp: n2 }), this._sei && (this._sei.handleEncodedStreams(), this._sei.onSEIMessage = (e3) => {
                this._emitter.emit("sei-message", tb(eb({}, e3), { userId: this.userId }));
              }), this.updateSSRC(n2);
            } catch (o2) {
              throw this._log.error(o2), o2;
            }
          });
        }
        updateSSRC(e2) {
          try {
            qV(e2).media.forEach((e3) => {
              if (e3.ssrcs)
                if (e3.type === ok.AUDIO) {
                  let t2 = e3.ssrcs.find((e4) => {
                    var t3;
                    return null == (t3 = e4.value) ? void 0 : t3.includes(_k);
                  });
                  t2 && (this.ssrc.audio = Number(t2.id));
                } else {
                  let t2 = e3.ssrcs.find((e4) => {
                    var t3;
                    return null == (t3 = e4.value) ? void 0 : t3.includes(_k);
                  }), i2 = e3.ssrcs.find((e4) => {
                    var t3;
                    return null == (t3 = e4.value) ? void 0 : t3.includes(fk);
                  });
                  t2 && (this.ssrc.video = Number(t2.id)), i2 && (this.ssrc.auxiliary = Number(i2.id));
                }
            });
          } catch (wk2) {
          }
        }
        getMainStreamVideoTrackId() {
          return this.remoteVideoTrack && this.remoteVideoTrack.mediaTrack ? this.remoteVideoTrack.mediaTrack.id : "";
        }
        getAuxStreamVideoTrackId() {
          return this.remoteAuxiliaryTrack && this.remoteAuxiliaryTrack.mediaTrack ? this.remoteAuxiliaryTrack.mediaTrack.id : "";
        }
        reconnect() {
          return cb(this, null, function* () {
            if (!(ab(XV.prototype, this, "beforeReconnect").call(this) < 0))
              try {
                this.closePeerConnection(), this.initialize(), yield this.connect(), this.stopReconnection(), this._log.warn("reconnect() success");
              } catch (wk2) {
                let t2 = ww(this._reconnectionCount);
                this._log.warn("reconnect() timeout, try again after ".concat(t2 / 1e3, "s")), this._reconnectionTimer = setTimeout(() => {
                  this.clearReconnectionTimer(), this.reconnect();
                }, t2);
              }
          });
        }
        getIsReconnecting() {
          return this._isReconnecting;
        }
        clearReconnectionTimer() {
          -1 !== this._reconnectionTimer && (clearTimeout(this._reconnectionTimer), this._reconnectionTimer = -1);
        }
        getCurrentState() {
          return this._currentState;
        }
        setDelay(e2) {
          let { audioDelay: t2, videoDelay: i2 } = e2;
          this.remoteAudioTrack.stat.end2EndDelay = t2, this.remoteVideoTrack.stat.end2EndDelay = i2;
        }
      }, $V = XV;
      ob([XM((e2) => function() {
        for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
          i2[r2] = arguments[r2];
        return new Promise((t3, r3) => {
          let n2 = (e3) => {
            this._emitter.off("closed", n2), r3(new vb({ code: Sb.API_CALL_ABORTED, message: XD({ key: uN.CONNECTION_ABORTED, data: e3 }) }));
          };
          this._emitter.on("closed", n2), e2.apply(this, i2).then(t3, r3).finally(() => {
            this._emitter.off("closed", n2);
          });
        });
      })], $V.prototype, "subscribe", 1), ob([QM(KV.prototype.afterConnect), YM(KV.prototype.beforeConnect)], $V.prototype, "connect", 1);
      var ZV = $V, eU = { voiceActivityDetection: false }, tU = class extends KV {
        constructor(e2) {
          super(tb(eb({}, e2), { isUplink: true })), sb(this, "localMainAudioTrack", null), sb(this, "localMainVideoTrack", null), sb(this, "localAuxAudioTrack", null), sb(this, "localAuxVideoTrack", null), sb(this, "ssrc", { audio: 0, video: 0, small: 0, auxiliary: 0 }), sb(this, "_isPublishingAux", false), sb(this, "_publishingLocalAudioTrack"), sb(this, "_publishingLocalVideoTrack"), sb(this, "_mediaSettings", { videoCodec: "", videoWidth: 0, videoHeight: 0, videoBps: 0, videoFps: 0, audioCodec: "opus", audioFs: 0, audioChannel: 0, audioBps: 0, smallVideoWidth: 0, smallVideoHeight: 0, smallVideoFps: 0, smallVideoBps: 0, auxVideoWidth: 0, auxVideoHeight: 0, auxVideoFps: 0, auxVideoBps: 0 }), sb(this, "flag", 0);
        }
        get isMainStreamPublished() {
          return !(!this.localMainAudioTrack && !this.localMainVideoTrack);
        }
        get isAuxStreamPublished() {
          return !(!this.localAuxVideoTrack && !this.localAuxAudioTrack);
        }
        get publishState() {
          var e2, t2, i2, r2;
          let n2 = { audio: false, bigVideo: false, smallVideo: false, auxVideo: false };
          if (this._peerConnection) {
            let o2 = this._peerConnection.getSenders();
            o2 && (qO() ? (n2.audio = !(null == (e2 = o2[0]) || !e2.track), n2.bigVideo = !(null == (t2 = o2[1]) || !t2.track), n2.smallVideo = !(null == (i2 = o2[2]) || !i2.track), n2.auxVideo = !(null == (r2 = o2[3]) || !r2.track)) : o2.forEach((e3) => {
              e3.track && (e3.track.kind === ok.AUDIO ? n2.audio = true : (n2.bigVideo = true, this._room.videoManager.hasSmall && (n2.smallVideo = true)));
            }));
          }
          return n2;
        }
        initialize() {
          super.initialize(), this.installEvents();
        }
        reset() {
          this._isReconnecting && this.stopReconnection(), this.closePeerConnection(), this.uninstallEvents();
        }
        close(e2) {
          super.close(e2), this.reset(), this.emitConnectionStateChangedEvent("DISCONNECTED");
        }
        installEvents() {
          this._emitter.listeners("connection-state-changed").includes(this.handleConnectionStateChange) || this._emitter.on("connection-state-changed", this.handleConnectionStateChange, this);
        }
        uninstallEvents() {
          this._emitter.off("connection-state-changed", this.handleConnectionStateChange, this);
        }
        emitConnectionStateChangedEvent(e2, t2) {
          var i2, r2, n2;
          let o2 = this._currentState, s2 = super.emitConnectionStateChangedEvent(e2);
          return s2 && o2 !== e2 && (t2 ? t2.emit("connection-state-changed", { prevState: o2, state: e2 }) : (null == (i2 = this.localMainVideoTrack) || i2.emit("connection-state-changed", { prevState: o2, state: e2 }), null == (r2 = this.localAuxVideoTrack) || r2.emit("connection-state-changed", { prevState: o2, state: e2 }), null == (n2 = this._publishingLocalVideoTrack) || n2.emit("connection-state-changed", { prevState: o2, state: e2 }))), s2;
        }
        publish(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { localAudioTrack: i2, localVideoTrack: r2, isAuxiliary: n2 } = e3;
            return function* () {
              var e4;
              let o2;
              t2._peerConnection || t2.initialize(), i2 && (t2._publishingLocalAudioTrack = i2), r2 && (t2._publishingLocalVideoTrack = r2), t2._isPublishingAux = n2, r2 && !n2 && r2.small && (o2 = t2._room.videoManager.smallTrack), t2.sendMediaSettings(), YO() ? yield t2.publishByTransceiver({ localAudioTrack: i2, localVideoTrack: r2, smallTrack: o2, isAuxiliary: n2 }) : yield t2.publishByAddTrack({ localAudioTrack: i2, localVideoTrack: r2, smallTrack: o2 }), t2._publishingLocalAudioTrack = null, t2._publishingLocalVideoTrack = null, t2._isPublishingAux = false, n2 ? (r2 && (t2.localAuxVideoTrack = r2), i2 && (t2.localAuxAudioTrack = i2)) : (r2 && (t2.localMainVideoTrack = r2), i2 && (t2.localMainAudioTrack = i2)), null == (e4 = t2._sei) || e4.handleEncodedStreams(), t2.installTrackMuteEvents(i2, r2), t2.sendMutedFlag();
            }();
          });
        }
        publishByTransceiver(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { localAudioTrack: i2, localVideoTrack: r2, smallTrack: n2, isAuxiliary: o2 } = e3;
            return function* () {
              t2._log.info("publish by transceiver");
              let e4 = new MediaStream(), s2 = null == r2 ? void 0 : r2.outMediaTrack, a2 = null == i2 ? void 0 : i2.outMediaTrack;
              a2 && e4.addTrack(a2), s2 && e4.addTrack(s2);
              let c2 = t2._peerConnection.getTransceivers();
              if (0 === c2.length)
                t2._peerConnection.addTransceiver(a2 || ok.AUDIO, { direction: sk.SENDONLY, streams: [e4] }), t2._peerConnection.addTransceiver(o2 ? ok.VIDEO : s2 || ok.VIDEO, { direction: sk.SENDONLY, streams: [e4] }), t2._peerConnection.addTransceiver(n2 || ok.VIDEO, { direction: sk.SENDONLY, streams: [e4] }), t2._peerConnection.addTransceiver(o2 && s2 || ok.VIDEO, { direction: sk.SENDONLY, streams: [e4] }), yield t2.connect();
              else {
                let e5 = [];
                if (a2 && (c2[0].sender.track || e5.push(0), yield c2[0].sender.replaceTrack(a2), yield t2.setBandwidth({ bandwidth: (null == i2 ? void 0 : i2.profile.bitrate) || 40, type: ok.AUDIO })), s2) {
                  let i3 = o2 ? 3 : 1;
                  yield c2[i3].sender.replaceTrack(s2), yield t2.setBandwidth({ bandwidth: r2.profile.bitrate, type: ok.VIDEO, videoType: o2 ? ok.AUXILIARY : ok.BIG }), e5.push(i3), n2 && (yield c2[2].sender.replaceTrack(n2), yield t2.setBandwidth({ bandwidth: r2.small.bitrate, type: ok.VIDEO, videoType: ok.SMALL }), e5.push(2));
                }
                yield t2.setTransceiverDirection(sk.SENDONLY, e5), yield t2.doPublishChange(), null == r2 || r2.emit("connection-state-changed", { prevState: "DISCONNECTED", state: "CONNECTING" }), null == r2 || r2.emit("connection-state-changed", { prevState: "CONNECTING", state: "CONNECTED" });
              }
            }();
          });
        }
        publishByAddTrack(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { localAudioTrack: i2, localVideoTrack: r2, smallTrack: n2 } = e3;
            return function* () {
              t2._log.info("publish by addtrack");
              let e4 = null == r2 ? void 0 : r2.outMediaTrack, o2 = null == i2 ? void 0 : i2.outMediaTrack;
              if (t2._peerConnection && "new" !== t2._peerConnection.connectionState)
                return i2 && o2 && (yield t2.addTrack(i2)), void (e4 && (yield t2.addTrack(r2)));
              let s2 = new MediaStream();
              if (o2 && s2.addTrack(o2), e4 && s2.addTrack(e4), o2 && t2._peerConnection.addTrack(o2, s2), e4 && (t2._peerConnection.addTrack(e4, s2), n2)) {
                let e5 = new MediaStream();
                e5.addTrack(n2), t2._peerConnection.addTrack(n2, e5);
              }
              yield t2.connect();
            }();
          });
        }
        enableSmall(e2) {
          return cb(this, null, function* () {
            let t2 = this._peerConnection.getTransceivers();
            e2 ? this._room.videoManager.smallTrack && (yield t2[2].sender.replaceTrack(this._room.videoManager.smallTrack), yield this.setTransceiverDirection(sk.SENDONLY, [2])) : (yield t2[2].sender.replaceTrack(null), yield this.setTransceiverDirection(sk.INACTIVE, [2])), this.updateMediaSettings(), yield this.doPublishChange();
          });
        }
        installTrackMuteEvents() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          t2.forEach((e3) => {
            e3 && (null == e3 || e3.on("mute", this.sendMutedFlag, this), null == e3 || e3.on("unmute", this.sendMutedFlag, this));
          });
        }
        uninstallTrackMuteEvents() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          t2.forEach((e3) => {
            e3 && (null == e3 || e3.off("mute", this.sendMutedFlag, this), null == e3 || e3.off("unmute", this.sendMutedFlag, this));
          });
        }
        unpublish(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { localAudioTrack: i2, localVideoTrack: r2 } = e3;
            return function* () {
              if (!qO())
                return i2 && i2.outMediaTrack && !r2 && t2.localMainVideoTrack ? (yield t2.removeTrack(i2), void (t2.localMainAudioTrack = null)) : r2 && r2.outMediaTrack && !i2 && t2.localMainAudioTrack ? (yield t2.removeTrack(r2), void (t2.localMainVideoTrack = null)) : (yield t2.doUnpublish(), t2.uninstallTrackMuteEvents(i2, r2), void t2.emitConnectionStateChangedEvent("DISCONNECTED", r2));
              let e4 = r2 && r2 === t2.localAuxVideoTrack, n2 = null == r2 ? void 0 : r2.outMediaTrack, o2 = t2._peerConnection.getSenders(), s2 = [];
              i2 && (yield o2[0].replaceTrack(null), s2.push(0), e4 ? t2.localAuxAudioTrack = null : t2.localMainAudioTrack = null), n2 && (e4 ? (yield o2[3].replaceTrack(null), t2.localAuxVideoTrack = null, t2._mediaSettings = tb(eb({}, t2._mediaSettings), { auxVideoBps: 0, auxVideoFps: 0, auxVideoWidth: 0, auxVideoHeight: 0 }), s2.push(3)) : (yield o2[1].replaceTrack(null), yield o2[2].replaceTrack(null), t2.localMainVideoTrack = null, t2._mediaSettings = tb(eb({}, t2._mediaSettings), { videoWidth: 0, videoHeight: 0, videoBps: 0, videoFps: 0, audioFs: 0, audioChannel: 0, audioBps: 0, smallVideoWidth: 0, smallVideoHeight: 0, smallVideoFps: 0, smallVideoBps: 0 }), s2.push(1, 2))), t2.isMainStreamPublished || t2.isAuxStreamPublished ? (yield t2.setTransceiverDirection(sk.INACTIVE, s2), yield t2.doPublishChange(false)) : yield t2.doUnpublish(), t2.uninstallTrackMuteEvents(i2, r2), null == r2 || r2.emit("connection-state-changed", { prevState: t2._currentState, state: "DISCONNECTED" });
            }();
          });
        }
        doPublishChange() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          return cb(this, null, function* () {
            let t2 = { state: this.publishState, constraintConfig: this._mediaSettings }, i2 = yield this._signalChannel.sendWaitForResponse({ command: _V, data: t2, responseCommand: cV.PUBLISH_STATE_CHANGE_RESULT, enableLog: e2 });
            this.checkPublishResultCode(i2.data.code, i2.data.message);
          });
        }
        doUnpublish() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return this._signalChannel.sendWaitForResponse({ command: fV, commandDesc: "unpublish", responseCommand: cV.UNPUBLISH_RESULT, enableLog: e2 }).catch((e3) => {
            if (e3.getCode() === Sb.API_CALL_TIMEOUT)
              return Promise.resolve();
            throw e3;
          });
        }
        updateMediaSettings() {
          let { detail: { isH264EncodeSupported: e2, isVp8EncodeSupported: t2 } } = this._room.checkSystemResult;
          e2 ? this._mediaSettings.videoCodec = "H264" : t2 && (this._mediaSettings.videoCodec = "VP8");
          let i2 = this._publishingLocalAudioTrack || this.localMainAudioTrack || this.localAuxAudioTrack, { localMainVideoTrack: r2, localAuxVideoTrack: n2 } = this;
          if (this._publishingLocalVideoTrack && (this._isPublishingAux ? n2 = this._publishingLocalVideoTrack : r2 = this._publishingLocalVideoTrack), eP) {
            if (i2 && i2.outMediaTrack) {
              let e3 = i2.outMediaTrack.getSettings();
              this._mediaSettings.audioChannel = e3.channelCount || 1, this._mediaSettings.audioBps = 1e3 * i2.profile.bitrate, this._mediaSettings.audioFs = e3.sampleRate || 0;
            }
            if (r2 && r2.outMediaTrack) {
              let e3 = r2.outMediaTrack.getSettings();
              this._mediaSettings.videoWidth = e3.width || 0, this._mediaSettings.videoHeight = e3.height || 0, this._mediaSettings.videoFps = e3.frameRate || 0, this._mediaSettings.videoBps = 1e3 * r2.profile.bitrate, r2.small && (this._mediaSettings.smallVideoWidth = r2.small.width, this._mediaSettings.smallVideoHeight = r2.small.height, this._mediaSettings.smallVideoFps = r2.small.frameRate, this._mediaSettings.smallVideoBps = 1e3 * r2.small.bitrate);
            }
            if (n2 && n2.outMediaTrack) {
              let e3 = n2.outMediaTrack.getSettings();
              this._mediaSettings.auxVideoWidth = e3.width || 0, this._mediaSettings.auxVideoHeight = e3.height || 0, this._mediaSettings.auxVideoFps = e3.frameRate || 0, this._mediaSettings.auxVideoBps = 1e3 * n2.profile.bitrate;
            }
          } else
            i2 && i2.outMediaTrack && (this._mediaSettings.audioChannel = i2.profile.channelCount, this._mediaSettings.audioBps = 1e3 * i2.profile.bitrate, this._mediaSettings.audioFs = i2.profile.sampleRate), r2 && r2.outMediaTrack && (this._mediaSettings.videoWidth = r2.profile.width, this._mediaSettings.videoHeight = r2.profile.height, this._mediaSettings.videoFps = r2.profile.frameRate, this._mediaSettings.videoBps = 1e3 * r2.profile.bitrate);
          this._log.info("updateMediaSettings: ".concat(JSON.stringify(this._mediaSettings)));
        }
        sendMediaSettings() {
          this.updateMediaSettings(), this._signalChannel.sendWaitForResponse({ command: kV, data: this._mediaSettings, responseCommand: cV.UPDATE_CONSTRAINT_CONFIG_RES }).then((e2) => {
            0 !== e2.data.code && this._log.warn(e2.data.message);
          }).catch(() => {
          });
        }
        addTrack(e2) {
          return cb(this, null, function* () {
            var t2;
            if (!this._peerConnection)
              return;
            let i2 = e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack;
            this._log.info("is adding ".concat(e2.kind, " track to current published local ").concat(i2 ? ok.AUXILIARY : ok.MAIN, " stream")), null == (t2 = this._sei) || t2.handleEncodedStreams(), YO() ? yield this.addTrackByTransceiver(e2, i2) : yield this.addTrackBySender(e2);
          });
        }
        addTrackByTransceiver(e2, t2) {
          return cb(this, null, function* () {
            var i2;
            if (!e2.mediaTrack)
              return;
            let r2 = this._peerConnection.getTransceivers();
            if (e2.kind === ok.AUDIO)
              yield r2[0].sender.replaceTrack(e2.outMediaTrack);
            else {
              let n2 = t2 ? 3 : 1;
              yield r2[n2].sender.replaceTrack(e2.outMediaTrack), 1 === n2 && (null == (i2 = this.localMainVideoTrack) ? void 0 : i2.small) && (yield r2[2].sender.replaceTrack(this._room.videoManager.smallTrack)), r2[n2].direction === sk.INACTIVE && (yield this.setTransceiverDirection(sk.SENDONLY, [n2]));
            }
            this.updateMediaSettings(), yield this.doPublishChange();
          });
        }
        addTrackBySender(e2) {
          return cb(this, null, function* () {
            if (!e2.outMediaTrack)
              return;
            let t2 = e2.outMediaTrack;
            qO() && this._peerConnection.getTransceivers().findIndex((e3) => "stopped" === e3.direction) >= 0 && (this._log.warn("transceiver is stopping, negotiate sdp first"), yield this.updateOffer("remove", t2));
            let i2 = this._peerConnection.getSenders().find((e3) => e3.track && e3.track.kind === t2.kind);
            if (i2 && i2.track) {
              this._log.warn("sender already exists, remove sender first");
              let e3 = i2.track;
              this.removeSender(i2), yield this.updateOffer("remove", e3);
            }
            if (t2 && this._peerConnection.addTrack(t2, new MediaStream([t2])), t2.kind === ok.VIDEO && e2 instanceof lL && e2.small) {
              let e3 = new MediaStream(), { smallTrack: t3 } = this._room.videoManager;
              e3.addTrack(t3), this._peerConnection.addTrack(t3, e3);
            }
            yield this.updateOffer("add", t2);
          });
        }
        isNeedToResetOfferOrder() {
          if (this._sdpSemantics === Uk || !this._peerConnection || !this._peerConnection.localDescription)
            return false;
          let { sdp: e2 } = this._peerConnection.localDescription, t2 = qV(e2);
          for (let i2 = 0; i2 < t2.media.length; i2++)
            if (0 === Number(t2.media[i2].mid) && t2.media[i2].type === ok.VIDEO)
              return true;
          return false;
        }
        removeSender(e2) {
          let t2 = null;
          qO() && (t2 = this._peerConnection.getTransceivers().find((t3) => t3.sender && t3.sender.track === e2.track)), this._peerConnection.removeTrack(e2), t2 && Pw(t2.stop) && (this._log.info("stop transceiver"), t2.stop());
        }
        removeTrack(e2) {
          return cb(this, null, function* () {
            if (!this._peerConnection)
              return;
            let t2 = e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack;
            this._log.info("is removing ".concat(e2.kind, " track from current published local ").concat(t2 ? ok.AUXILIARY : ok.MAIN, " stream")), YO() ? yield this.removeTrackByTransceiver(e2, t2) : yield this.removeTrackBySender(e2);
          });
        }
        removeTrackByTransceiver(e2, t2) {
          return cb(this, null, function* () {
            if (!e2.outMediaTrack)
              return;
            let i2 = this._peerConnection.getTransceivers();
            if (e2.kind === ok.AUDIO)
              yield i2[0].sender.replaceTrack(null);
            else {
              let r2 = t2 ? 3 : 1;
              yield i2[r2].sender.replaceTrack(null), 1 === r2 && e2.small && (yield i2[2].sender.replaceTrack(null)), yield this.setTransceiverDirection(sk.INACTIVE, [r2]);
            }
            this.updateMediaSettings(), yield this.doPublishChange();
          });
        }
        setTransceiverDirection(e2, t2) {
          return cb(this, null, function* () {
            if (!NN)
              return;
            let i2 = false, r2 = false;
            this._log.info("setting transceiver ".concat(t2.join(","), " direction to ").concat(e2));
            let n2 = this._peerConnection.getTransceivers();
            if (t2.forEach((t3) => {
              n2[t3].direction !== e2 && (n2[t3].direction = e2, i2 = true);
            }), i2) {
              this._log.info("updating offer");
              let e3 = yield this._peerConnection.createOffer();
              yield this._peerConnection.setLocalDescription(e3);
            }
            let o2 = -1, s2 = this._peerConnection.remoteDescription.sdp.split("\r\n").map((i3) => {
              if (i3.match(new RegExp("a=(".concat(sk.INACTIVE, "|").concat(sk.RECVONLY, "|").concat(sk.SENDONLY, ")"))) && o2++, t2.includes(o2)) {
                if (e2 === sk.INACTIVE && i3.includes("a=".concat(sk.RECVONLY)))
                  return r2 = true, "a=".concat(e2);
                if (e2 === sk.SENDONLY && i3.includes("a=".concat(sk.INACTIVE)))
                  return r2 = true, "a=".concat(sk.RECVONLY);
              }
              return i3;
            }).join("\r\n");
            r2 && (this._log.info("updating answer"), yield this._peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
          });
        }
        removeTrackBySender(e2) {
          return cb(this, null, function* () {
            if (!e2.outMediaTrack)
              return;
            if (e2.kind === ok.VIDEO && this.isNeedToResetOfferOrder() && this.localMainAudioTrack)
              return this.reset(), this.initialize(), void (yield this.publish({ localAudioTrack: this.localMainAudioTrack, isAuxiliary: false }));
            let t2 = this._peerConnection.getSenders().find((t3) => t3.track === e2.outMediaTrack);
            t2 && (this.removeSender(t2), e2.kind === ok.VIDEO && e2.small && this._peerConnection.getSenders().forEach((e3) => {
              e3.track && e3.track.kind === ok.VIDEO && this.removeSender(e3);
            })), yield this.updateOffer("remove", e2.outMediaTrack);
          });
        }
        replaceTrack(e2) {
          return cb(this, null, function* () {
            var t2;
            let i2, r2 = null == (t2 = this._peerConnection) ? void 0 : t2.getSenders();
            if (!r2 || 0 === r2.length || !e2.mediaTrack)
              return;
            if (i2 = YO() ? e2.kind === ok.AUDIO ? r2[0] : r2[1] : r2.find((t3) => t3.track && t3.track.kind === e2.kind), !i2)
              return;
            let n2 = e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack;
            this._log.info("is replacing ".concat(e2.kind, " track on ").concat(n2 ? ok.AUXILIARY : ok.MAIN, " stream")), e2.kind === ok.AUDIO ? yield i2.replaceTrack(e2.outMediaTrack) : e2.kind === ok.VIDEO && (n2 ? r2[3] && (yield r2[3].replaceTrack(e2.outMediaTrack)) : yield i2.replaceTrack(e2.outMediaTrack));
          });
        }
        updateOffer(e2, t2) {
          return cb(this, null, function* () {
            try {
              let i2 = yield this._peerConnection.createOffer(eU);
              NN && i2.sdp && (i2.sdp = this.setSDPDirection(i2.sdp, "sendrecv")), yield this._peerConnection.setLocalDescription(i2);
              let r2 = this.updateMediaSettings(), n2 = { action: e2, trackId: t2.id, kind: t2.kind === ok.VIDEO ? "bigVideo" : t2.kind, type: "offer", sdp: this._peerConnection.localDescription.sdp, constraintConfig: r2, state: this.publishState };
              this._log.info("createOffer success, sending updated offer to remote server"), this._log.debug("updatedOffer: ".concat(n2.sdp));
              let o2 = yield this._signalChannel.sendWaitForResponse({ command: lV, data: n2, responseCommand: cV.UPDATE_OFFER_RESULT, timeout: Lk, commandDesc: "update offer" }), { code: s2, message: a2 } = o2.data;
              0 !== s2 && this.checkPublishResultCode(s2, a2), yield this.acceptAnswer(o2.data.data), i2.sdp && this.updateSSRC(i2.sdp);
            } catch (Ob2) {
              throw this._log.error(Ob2), Ob2;
            }
          });
        }
        setBandwidth(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { bandwidth: i2, type: r2, videoType: n2, sdp: o2 } = e3;
            return function* () {
              if (!ZO())
                return o2 ? r2 === ok.VIDEO ? t2.updateVideoBandwidthRestriction(o2, i2, n2) : t2.updateAudioBandwidthRestriction(o2, i2) : void 0;
              let e4, s2 = t2._peerConnection.getSenders();
              if (YO()) {
                let t3 = 0;
                r2 === ok.VIDEO && (t3 = n2 === ok.SMALL ? 2 : n2 === ok.AUXILIARY ? 3 : 1), e4 = s2[t3];
              } else
                e4 = s2.find((e5) => e5.track && e5.track.kind === r2);
              if (e4) {
                let s3 = e4.getParameters();
                (!s3.encodings || 0 === s3.encodings.length) && (s3.encodings = [{}]), s3.encodings[0].maxBitrate = 1e3 * i2;
                try {
                  return yield e4.setParameters(s3), t2._log.info("".concat(n2 || "").concat(r2, " bandwidth ").concat(i2, " kbps")), o2;
                } catch (a2) {
                  if (t2._log.info("failed to set bandwidth by setting maxBitrate: ".concat(a2)), o2)
                    return r2 === ok.VIDEO ? t2.updateVideoBandwidthRestriction(o2, i2, n2) : t2.updateAudioBandwidthRestriction(o2, i2);
                }
              }
              return o2;
            }();
          });
        }
        updateVideoBandwidthRestriction(e2, t2, i2) {
          let r2 = "AS";
          NN && (r2 = "TIAS", t2 *= 1e3);
          let n2 = 0, o2 = -1;
          return i2 === ok.SMALL ? n2 = 1 : i2 === ok.AUXILIARY && (n2 = 2), e2 = e2.replace(/m=video (.*)\r\nc=IN (.*)\r\n/g, (e3) => (o2 += 1, o2 === n2 ? "".concat(e3, "b=").concat(r2, ":").concat(t2, "\r\n") : e3));
        }
        updateAudioBandwidthRestriction(e2, t2) {
          let i2 = "AS";
          return NN && (i2 = "TIAS", t2 *= 1e3), e2 = e2.replace(/m=audio (.*)\r\nc=IN (.*)\r\n/, "m=audio $1\r\nc=IN $2\r\nb=".concat(i2, ":").concat(t2, "\r\n"));
        }
        removeBandwidthRestriction(e2) {
          return e2.replace(/b=AS:.*\r\n/, "").replace(/b=TIAS:.*\r\n/, "");
        }
        removeVideoOrientation(e2) {
          return e2.replace(/urn:3gpp:video-orientation/, "");
        }
        connect() {
          return cb(this, null, function* () {
            try {
              yield this.exchangeSDP(), yield this.waitForPeerConnectionConnected();
            } catch (wb2) {
              throw this.closePeerConnection(true), this.uninstallEvents(), wb2;
            }
          });
        }
        exchangeSDP() {
          return cb(this, null, function* () {
            try {
              yield this.createOffer(), this._log.info("createOffer success, sending offer to remote server"), yield this.doExchangeSDP();
            } catch (wb2) {
              throw wb2;
            }
          });
        }
        createOffer() {
          return cb(this, null, function* () {
            try {
              let e2 = yield this._peerConnection.createOffer(eU);
              yield this._peerConnection.setLocalDescription(e2), e2.sdp && this.updateSSRC(e2.sdp);
            } catch (wb2) {
              throw wb2;
            }
          });
        }
        doExchangeSDP() {
          let e2 = { command: mV, responseCommand: cV.PUBLISH_RESULT, data: { type: this._peerConnection.localDescription.type, sdp: this.removeVideoOrientation(this._peerConnection.localDescription.sdp), screen: this.localMainVideoTrack instanceof pL || this.localAuxVideoTrack instanceof pL, state: this.publishState, constraintConfig: this._mediaSettings }, enableLog: false };
          return this._log.debug("sending sdp offer: ".concat(e2.data.sdp)), this._signalChannel.sendWaitForResponse(e2).then((e3) => {
            let { code: t2, message: i2, data: r2 } = e3.data;
            return 0 === t2 ? this.acceptAnswer(r2) : this.checkPublishResultCode(t2, i2);
          });
        }
        setSDPDirection(e2, t2) {
          let i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "all", r2 = qV(e2);
          return r2.media.forEach((e3) => {
            ("all" === i2 || e3.type === i2) && (e3.direction = t2);
          }), YV(r2);
        }
        acceptAnswer(e2) {
          return cb(this, null, function* () {
            var t2, i2, r2, n2, o2;
            try {
              let s2;
              if (this._publishingLocalAudioTrack || this._publishingLocalVideoTrack || this.isMainStreamPublished) {
                let e3 = (null == (t2 = this._publishingLocalVideoTrack) ? void 0 : t2.profile.bitrate) || (null == (i2 = this.localMainVideoTrack) ? void 0 : i2.profile.bitrate), o3 = (null == (r2 = this._publishingLocalAudioTrack) ? void 0 : r2.profile.bitrate) || (null == (n2 = this.localMainAudioTrack) ? void 0 : n2.profile.bitrate);
                if (e3) {
                  let t3 = this._isPublishingAux ? ok.AUXILIARY : ok.BIG;
                  s2 = yield this.setBandwidth({ bandwidth: e3, type: ok.VIDEO, sdp: s2, videoType: t3 });
                }
                o3 && (s2 = yield this.setBandwidth({ bandwidth: o3, type: ok.AUDIO, sdp: s2 }));
              }
              if (s2 = this.removeVideoOrientation(e2.sdp), null != (o2 = this._publishingLocalVideoTrack) && o2.small) {
                let { smallStreamConfig: e3 } = this._room;
                s2 = yield this.setBandwidth({ bandwidth: this._publishingLocalVideoTrack.small.bitrate || e3.bitrate, type: ok.VIDEO, videoType: ok.SMALL, sdp: s2 });
              }
              let a2 = { type: e2.type, sdp: s2 };
              yield this._peerConnection.setRemoteDescription(a2), this._log.debug("accepted answer: ".concat(s2));
            } catch (WU2) {
              throw this._log.error("failed to accept remote answer ".concat(WU2)), WU2;
            }
          });
        }
        sendMutedFlag(e2) {
          var t2, i2, r2;
          if (e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack)
            return;
          let n2 = { audio: !(null == (t2 = this.localMainAudioTrack) || !t2.muted), bigVideo: !(null == (i2 = this.localMainVideoTrack) || !i2.muted), auxVideo: !(null == (r2 = this.localAuxVideoTrack) || !r2.muted) };
          this._log.info("send muted state: ".concat(JSON.stringify(n2))), this._signalChannel.send(pV, n2);
        }
        getIsReconnecting() {
          return this._isReconnecting;
        }
        reconnect() {
          return cb(this, null, function* () {
            if (!(ab(tU.prototype, this, "beforeReconnect").call(this) < 0))
              try {
                yield this._signalChannel.sendWaitForResponse({ command: fV, responseCommand: cV.UNPUBLISH_RESULT, enableLog: false }), this.closePeerConnection(), this.initialize(), this.isMainStreamPublished && (yield this.publish({ localAudioTrack: this.localMainAudioTrack, localVideoTrack: this.localMainVideoTrack, isAuxiliary: false })), this.isAuxStreamPublished && (yield this.publish({ localAudioTrack: this.localAuxAudioTrack, localVideoTrack: this.localAuxVideoTrack, isAuxiliary: true })), this._log.warn("reconnect() uplink reconnect successfully"), this.stopReconnection();
              } catch (wk2) {
                let t2 = ww(this._reconnectionCount);
                this._log.warn("reconnect() timeout, try again after ".concat(t2 / 1e3, "s")), this._reconnectionTimer = setTimeout(() => {
                  this.clearReconnectionTimer(), this.reconnect();
                }, t2);
              }
          });
        }
        handleConnectionStateChange(e2) {
          "CONNECTED" === e2.state && (this.localMainVideoTrack || this._publishingLocalVideoTrack && !this._isPublishingAux) && ew.emit(gO.SEND_FIRST_VIDEO_FRAME, { room: this._room });
        }
        updateSSRC(e2) {
          try {
            qV(e2).media.forEach((e3, t2) => {
              if (e3.type === ok.AUDIO) {
                let t3 = e3.ssrcs && e3.ssrcs[0];
                t3 && (this.ssrc.audio = Number(t3.id));
              } else {
                if (this._sdpSemantics === Uk && e3.ssrcGroups)
                  return void e3.ssrcGroups.forEach((e4, t3) => {
                    let i3 = Number(e4.ssrcs.split(" ")[0]);
                    0 === t3 ? this.ssrc.video = i3 : 1 === t3 && (this.ssrc.small = i3);
                  });
                let i2 = e3.ssrcs && e3.ssrcs[0];
                if (!i2)
                  return;
                switch (t2) {
                  case 1:
                    this.ssrc.video = Number(i2.id);
                    break;
                  case 2:
                    this.ssrc.small = Number(i2.id);
                    break;
                  case 3:
                    this.ssrc.auxiliary = Number(i2.id);
                }
              }
            });
          } catch (wk2) {
          }
        }
        getVideoTrackId() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ok.VIDEO;
          if (this._peerConnection) {
            let t2 = this._peerConnection.getSenders();
            if (e2 === ok.AUXILIARY && t2[3] && t2[3].track)
              return t2[3].track.id;
            if (e2 === ok.VIDEO && t2[1] && t2[1].track)
              return t2[1].track.id;
          }
          if (this.localMainVideoTrack && e2 === ok.VIDEO) {
            let e3 = this.localMainVideoTrack.mediaTrack;
            if (e3)
              return e3.id;
          }
          if (this.localAuxVideoTrack && e2 === ok.AUXILIARY) {
            let e3 = this.localAuxVideoTrack.mediaTrack;
            if (e3)
              return e3.id;
          }
          return "";
        }
        getSSRC() {
          return this.ssrc;
        }
        checkPublishResultCode(e2, t2) {
          if (0 !== e2)
            throw e2 === Fk ? (this._log.error(hN.NOT_SUPPORTED_H264ENCODE), new vb({ code: Sb.NOT_SUPPORTED_H264, message: XD({ key: uN.NOT_SUPPORTED_H264ENCODE }) })) : new vb({ code: Sb.UNKNOWN, message: XD({ key: uN.SIGNAL_RESPONSE_FAILED, data: { signalResponse: cV.PUBLISH_RESULT, code: e2, message: t2 } }) });
        }
        sendSEI(e2, t2) {
          var i2;
          null == (i2 = this._sei) || i2.push(e2, t2);
        }
      }, iU = tU;
      ob([XM((e2) => function() {
        for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
          i2[r2] = arguments[r2];
        return new Promise((t3, r3) => {
          let n2 = (e3) => {
            this._emitter.off("closed", n2), r3(new vb({ code: Sb.API_CALL_ABORTED, message: XD({ key: uN.CONNECTION_ABORTED, data: e3 }) }));
          };
          this._emitter.on("closed", n2), e2.apply(this, i2).then(t3, r3).finally(() => {
            this._emitter.off("closed", n2);
          });
        });
      })], iU.prototype, "publish", 1), ob([QM(KV.prototype.afterConnect), YM(KV.prototype.beforeConnect)], iU.prototype, "connect", 1);
      var rU = iU, nU = class {
        constructor(e2, t2) {
          this.room = e2, sb(this, "_log"), sb(this, "_prevReportTime"), sb(this, "_prevReport", {}), sb(this, "_prevEncoderImplementation"), sb(this, "_prevQualityLimitationReason"), sb(this, "_prevAuxQualityLimitationReason"), sb(this, "_prevDecoderImplementationMap", /* @__PURE__ */ new Map()), sb(this, "totalBytesSent", 0), sb(this, "totalBytesReceived", 0), sb(this, "_spcStats", null), this._log = t2, this._prevReportTime = 0, this._prevEncoderImplementation = "", this._prevQualityLimitationReason = "", this._prevAuxQualityLimitationReason = "";
        }
        get statInterval() {
          return 0 === this._prevReportTime ? 2 : (Date.now() - this._prevReportTime) / 1e3;
        }
        getSenderStats(e2) {
          return cb(this, null, function* () {
            let t2 = { audio: { bytesSent: 0, packetsSent: 0, audioLevel: 0, totalAudioEnergy: 0 }, video: { bytesSent: 0, packetsSent: 0, framesEncoded: 0, frameWidth: 0, frameHeight: 0, framesSent: 0, fpsCapture: 0 }, small: { bytesSent: 0, packetsSent: 0, framesEncoded: 0, frameWidth: 0, frameHeight: 0, framesSent: 0, fpsCapture: 0 }, auxiliary: { bytesSent: 0, packetsSent: 0, framesEncoded: 0, frameWidth: 0, frameHeight: 0, framesSent: 0, fpsCapture: 0 }, rtt: 0 }, i2 = e2.getPeerConnection(), r2 = e2.getSSRC();
            if (i2)
              try {
                if ((this._spcStats || (yield i2.getStats())).forEach((i3) => {
                  var n2;
                  if ("outbound-rtp" === i3.type)
                    if ((i3.mediaType || i3.kind) === ok.VIDEO) {
                      let n3, o2;
                      if (i3.ssrc === r2.video ? (n3 = ok.VIDEO, o2 = e2.localMainVideoTrack) : i3.ssrc === r2.small ? n3 = ok.SMALL : i3.ssrc === r2.auxiliary && (o2 = e2.localAuxVideoTrack, n3 = ok.AUXILIARY), !n3)
                        return;
                      t2[n3].bytesSent = i3.bytesSent, t2[n3].packetsSent = i3.packetsSent, t2[n3].framesEncoded = i3.framesEncoded, Mw(i3.keyFramesEncoded) || (t2[n3].keyFramesEncoded = i3.keyFramesEncoded), Mw(i3.nackCount) || (t2[n3].nackCount = i3.nackCount), Mw(i3.pliCount) || (t2[n3].pliCount = i3.pliCount), Mw(i3.retransmittedPacketsSent) || (t2[n3].retransmittedPacketsSent = i3.retransmittedPacketsSent), Mw(i3.totalEncodeTime) || (t2[n3].totalEncodeTime = i3.totalEncodeTime), Mw(i3.totalPacketSendDelay) || (t2[n3].totalPacketSendDelay = i3.totalPacketSendDelay), i3.ssrc === r2.video ? (!Mw(i3.encoderImplementation) && this._prevEncoderImplementation !== i3.encoderImplementation && (this._log.info("encoderImplementation change to ".concat(i3.encoderImplementation)), this._prevEncoderImplementation = i3.encoderImplementation), !Mw(i3.qualityLimitationReason) && 0 !== i3.bytesSent && this._prevQualityLimitationReason !== i3.qualityLimitationReason && (this._log.info("qualityLimitationReason change to ".concat(i3.qualityLimitationReason)), this._prevQualityLimitationReason = i3.qualityLimitationReason)) : i3.ssrc === r2.auxiliary && !Mw(i3.qualityLimitationReason) && 0 !== i3.bytesSent && this._prevAuxQualityLimitationReason !== i3.qualityLimitationReason && (this._log.info("aux qualityLimitationReason change to ".concat(i3.qualityLimitationReason)), this._prevAuxQualityLimitationReason = i3.qualityLimitationReason);
                    } else
                      t2.audio.bytesSent = i3.bytesSent, t2.audio.packetsSent = i3.packetsSent;
                  else
                    "candidate-pair" === i3.type ? FO(i3) && xw(i3.currentRoundTripTime) && (t2.rtt = Math.floor(1e3 * i3.currentRoundTripTime), this.totalBytesSent = i3.bytesSent) : "media-source" === i3.type && (i3.kind === ok.AUDIO ? (t2.audio.audioLevel = i3.audioLevel || 0, t2.audio.totalAudioEnergy = i3.totalAudioEnergy || 0) : i3.kind === ok.VIDEO && (i3.trackIdentifier === e2.getVideoTrackId(ok.VIDEO) ? t2.video.fpsCapture = i3.framesPerSecond : i3.trackIdentifier === e2.getVideoTrackId(ok.AUXILIARY) ? t2.auxiliary.fpsCapture = i3.framesPerSecond : t2.small.fpsCapture = i3.framesPerSecond));
                  if (!Mw(i3.audioLevel) && (null == (n2 = e2.localMainAudioTrack) ? void 0 : n2.mediaTrack) && i3.trackIdentifier === e2.localMainAudioTrack.mediaTrack.id && (t2.audio.audioLevel = i3.audioLevel || 0), !Mw(i3.frameWidth)) {
                    let n3 = ok.SMALL;
                    i3.trackIdentifier === e2.getVideoTrackId(ok.VIDEO) || i3.ssrc === r2.video ? n3 = ok.VIDEO : (i3.trackIdentifier === e2.getVideoTrackId(ok.AUXILIARY) || i3.ssrc === r2.auxiliary) && (n3 = ok.AUXILIARY), t2[n3].frameWidth = i3.frameWidth, t2[n3].frameHeight = i3.frameHeight, t2[n3].framesSent = i3.framesSent;
                  }
                }), e2.localMainAudioTrack) {
                  let i3 = e2.localMainAudioTrack.getInternalAudioLevel();
                  t2.audio.micAudioLevel = i3, 0 === t2.audio.audioLevel && (t2.audio.audioLevel = i3);
                }
                this.totalBytesSent || (this.totalBytesSent += t2.audio.bytesSent + t2.video.bytesSent + t2.auxiliary.bytesSent);
              } catch (tM2) {
                this._log.warn("failed to getStats on sender connection ".concat(tM2));
              }
            return t2;
          });
        }
        getReceiverStats(e2) {
          return cb(this, null, function* () {
            let t2 = { tinyId: e2.tinyId, userId: e2.userId, rtt: 0, hasAudio: false, hasVideo: false, hasAuxiliary: false, isSmallSubscribed: false, audio: { bytesReceived: 0, packetsReceived: 0, packetsLost: 0, p2pDelay: 0, totalJitter: 0, totalJitterCount: 0, audioLevel: 0, totalAudioEnergy: 0, insertedSamplesForDeceleration: 0, removedSamplesForAcceleration: 0 }, video: { bytesReceived: 0, packetsReceived: 0, packetsLost: 0, framesReceived: 0, framesDecoded: 0, frameWidth: 0, frameHeight: 0, fpsDecoded: 0 }, auxiliary: { bytesReceived: 0, packetsReceived: 0, packetsLost: 0, framesReceived: 0, framesDecoded: 0, frameWidth: 0, frameHeight: 0, fpsDecoded: 0 } }, i2 = e2.getPeerConnection();
            if (i2)
              try {
                let { ssrc: r2 } = e2, { muteState: n2, subscribeState: o2 } = e2;
                (this._spcStats || (yield i2.getStats())).forEach((i3) => {
                  if ("inbound-rtp" === i3.type)
                    if ((i3.mediaType || i3.kind) === ok.AUDIO) {
                      if (i3.ssrc !== r2.audio || !n2.hasAudio)
                        return;
                      t2.audio.packetsReceived = i3.packetsReceived, t2.audio.bytesReceived = i3.bytesReceived, t2.audio.packetsLost = i3.packetsLost, i3.insertedSamplesForDeceleration && (t2.audio.insertedSamplesForDeceleration = i3.insertedSamplesForDeceleration), i3.removedSamplesForAcceleration && (t2.audio.removedSamplesForAcceleration = i3.removedSamplesForAcceleration);
                      let { remoteAudioTrack: o3 } = e2;
                      o3.stat.packetsReceived = i3.packetsReceived, o3.stat.bytesReceived = i3.bytesReceived, o3.stat.packetsLost = i3.packetsLost, t2.audio.p2pDelay = o3.stat.end2EndDelay, i3.jitterBufferDelay && (t2.audio.totalJitter = i3.jitterBufferDelay, t2.audio.totalJitterCount = i3.jitterBufferEmittedCount), t2.hasAudio = true;
                    } else {
                      if (NN && 0 === i3.bytesReceived)
                        return;
                      let s2;
                      i3.ssrc === r2.video && n2.hasVideo && (t2.video.packetsReceived = i3.packetsReceived, t2.video.bytesReceived = i3.bytesReceived, t2.video.packetsLost = i3.packetsLost, t2.video.framesReceived = i3.framesReceived, t2.video.framesDecoded = i3.framesDecoded, t2.video.fpsDecoded = i3.framesPerSecond, t2.hasVideo = true, s2 = e2.remoteVideoTrack, n2.hasSmall && o2.smallVideo && (t2.isSmallSubscribed = true), i3.decoderImplementation && (!this._prevDecoderImplementationMap.has(t2.userId) || this._prevDecoderImplementationMap.get(t2.userId) !== i3.decoderImplementation) && (this._log.info("".concat(t2.userId, " decoderImplementation change to ").concat(i3.decoderImplementation)), this._prevDecoderImplementationMap.set(t2.userId, i3.decoderImplementation))), i3.ssrc === r2.auxiliary && n2.hasAuxiliary && (t2.auxiliary.packetsReceived = i3.packetsReceived, t2.auxiliary.bytesReceived = i3.bytesReceived, t2.auxiliary.packetsLost = i3.packetsLost, t2.auxiliary.framesReceived = i3.framesReceived, t2.auxiliary.framesDecoded = i3.framesDecoded, t2.auxiliary.fpsDecoded = i3.framesPerSecond, s2 = e2.remoteAuxiliaryTrack, t2.hasAuxiliary = true), s2 && (s2.stat.packetsReceived = i3.packetsReceived, s2.stat.bytesReceived = i3.bytesReceived, s2.stat.packetsLost = i3.packetsLost, s2.stat.framesReceived = i3.framesReceived, s2.stat.framesDecoded = i3.framesDecoded, i3.jitterBufferDelay && (s2.stat.jitterBufferDelay = Math.floor(i3.jitterBufferDelay / i3.jitterBufferEmittedCount * 1e3)));
                    }
                  else
                    "candidate-pair" === i3.type && FO(i3) && xw(i3.currentRoundTripTime) && (t2.rtt = Math.floor(1e3 * i3.currentRoundTripTime), this.totalBytesReceived = i3.bytesReceived);
                  Mw(i3.frameWidth) || ((i3.trackIdentifier === e2.getMainStreamVideoTrackId() || i3.ssrc === r2.video) && (t2.video.frameWidth = i3.frameWidth, t2.video.frameHeight = i3.frameHeight, e2.remoteVideoTrack.stat.frameWidth = i3.frameWidth, e2.remoteVideoTrack.stat.frameHeight = i3.frameHeight), (i3.trackIdentifier === e2.getAuxStreamVideoTrackId() || i3.ssrc === r2.auxiliary) && (t2.auxiliary.frameWidth = i3.frameWidth, t2.auxiliary.frameHeight = i3.frameHeight, e2.remoteAuxiliaryTrack.stat.frameWidth = i3.frameWidth, e2.remoteAuxiliaryTrack.stat.frameHeight = i3.frameHeight)), !Mw(i3.audioLevel) && e2.muteState.audioAvailable && e2.remoteAudioTrack.mediaTrack && i3.trackIdentifier === e2.remoteAudioTrack.mediaTrack.id && (t2.audio.audioLevel = i3.audioLevel || 0, t2.audio.totalAudioEnergy = i3.totalAudioEnergy || 0);
                }), 0 === t2.audio.audioLevel && e2.muteState.audioAvailable && (t2.audio.audioLevel = e2.remoteAudioTrack.getInternalAudioLevel() || 0), this.totalBytesReceived || (this.totalBytesReceived += t2.audio.bytesReceived + t2.video.bytesReceived + t2.auxiliary.bytesReceived);
              } catch (Ob2) {
                this._log.warn("failed to getStats on receiver connection ".concat(Ob2));
              }
            return t2;
          });
        }
        getStats(e2, t2) {
          return cb(this, null, function* () {
            let i2 = {}, r2 = [];
            if (this.room.singlePC) {
              let e3 = this.room.singlePC.getPeerConnection();
              if (!e3)
                return { senderStats: i2, receiverStats: r2 };
              let t3 = yield e3.getStats(), n2 = [], o2 = /* @__PURE__ */ new Set(["inbound-rtp", "outbound-rtp", "track", "candidate-pair", "media-source"]);
              t3.forEach((e4) => o2.has(e4.type) && n2.push(e4)), this._spcStats = n2;
            }
            e2 && (i2 = yield this.getSenderStats(e2));
            for (let [e3, n2] of t2) {
              let e4 = yield this.getReceiverStats(n2);
              r2.push(e4);
            }
            return { senderStats: i2, receiverStats: r2 };
          });
        }
        getDifferenceValue(e2, t2) {
          if (GM(e2))
            return t2;
          let i2 = t2 - e2;
          return i2 < 0 ? 0 : i2;
        }
        prepareReport(e2) {
          let { stats: t2, report: i2, freezeMap: r2 } = e2;
          if (!GM(t2.senderStats)) {
            let e3 = { uint32_audio_level: t2.senderStats.audio.audioLevel * dN, uint32_audio_energy: 1e6 * t2.senderStats.audio.totalAudioEnergy, uint32_audio_codec_bitrate: t2.senderStats.audio.bytesSent };
            t2.senderStats.audio.micAudioLevel && (e3.uint32_mic_audio_level = t2.senderStats.audio.micAudioLevel * dN);
            let r3 = [];
            if (t2.senderStats.video.bytesSent) {
              let e4 = { uint32_video_stream_type: 2, uint32_video_codec_fps: t2.senderStats.video.framesSent, uint32_video_capture_fps: t2.senderStats.video.fpsCapture, uint32_video_width: t2.senderStats.video.frameWidth, uint32_video_height: t2.senderStats.video.frameHeight, uint32_video_codec_bitrate: t2.senderStats.video.bytesSent, uint32_video_enc_fps: t2.senderStats.video.framesEncoded, uint32_key_frame_count: t2.senderStats.video.keyFramesEncoded, uint32_nack_count: t2.senderStats.video.nackCount, uint32_pli_count: t2.senderStats.video.pliCount, uint32_encode_cost: 1e3 * (t2.senderStats.video.totalEncodeTime || 0), uint32_send_packet_cost: 1e3 * (t2.senderStats.video.totalPacketSendDelay || 0), uint32_video_arq_packets: t2.senderStats.video.retransmittedPacketsSent };
              r3.push(e4);
            }
            if (t2.senderStats.small.bytesSent) {
              let e4 = { uint32_video_stream_type: 3, uint32_video_codec_fps: t2.senderStats.small.framesSent || 0, uint32_video_capture_fps: t2.senderStats.small.fpsCapture || 0, uint32_video_width: t2.senderStats.small.frameWidth || 0, uint32_video_height: t2.senderStats.small.frameHeight || 0, uint32_video_codec_bitrate: t2.senderStats.small.bytesSent, uint32_video_enc_fps: t2.senderStats.small.framesEncoded || 0, uint32_key_frame_count: t2.senderStats.small.keyFramesEncoded, uint32_nack_count: t2.senderStats.small.nackCount, uint32_pli_count: t2.senderStats.small.pliCount, uint32_encode_cost: 1e3 * (t2.senderStats.small.totalEncodeTime || 0), uint32_send_packet_cost: 1e3 * (t2.senderStats.small.totalPacketSendDelay || 0), uint32_video_arq_packets: t2.senderStats.small.retransmittedPacketsSent };
              r3.push(e4);
            }
            if (t2.senderStats.auxiliary.bytesSent) {
              let e4 = { uint32_video_stream_type: 7, uint32_video_codec_fps: t2.senderStats.auxiliary.framesSent || 0, uint32_video_capture_fps: t2.senderStats.auxiliary.fpsCapture || 0, uint32_video_width: t2.senderStats.auxiliary.frameWidth || 0, uint32_video_height: t2.senderStats.auxiliary.frameHeight || 0, uint32_video_codec_bitrate: t2.senderStats.auxiliary.bytesSent, uint32_video_enc_fps: t2.senderStats.auxiliary.framesEncoded || 0, uint32_key_frame_count: t2.senderStats.auxiliary.keyFramesEncoded, uint32_nack_count: t2.senderStats.auxiliary.nackCount, uint32_pli_count: t2.senderStats.auxiliary.pliCount, uint32_encode_cost: 1e3 * (t2.senderStats.auxiliary.totalEncodeTime || 0), uint32_send_packet_cost: 1e3 * (t2.senderStats.auxiliary.totalPacketSendDelay || 0), uint32_video_arq_packets: t2.senderStats.auxiliary.retransmittedPacketsSent };
              r3.push(e4);
            }
            let n3 = { uint32_bitrate: 0, uint32_lost: 0, uint32_rtt: t2.senderStats.rtt };
            i2.msg_up_stream_info = { msg_audio_status: e3, msg_video_status: r3, msg_network_status: n3 };
          }
          let { statInterval: n2 } = this;
          i2.msg_down_stream_info = [], t2.receiverStats.forEach((e3) => {
            let t3 = { msg_user_info: { str_identifier: e3.userId, uint64_tinyid: e3.tinyId }, msg_network_status: { uint32_rtt: e3.rtt, uint32_bitrate: 0, uint32_lost: 0 }, msg_audio_status: {}, msg_video_status: [] };
            if (e3.hasAudio) {
              let i3 = { uint32_audio_p2p_delay: e3.audio.p2pDelay, uint32_audio_cache_ms: e3.audio.totalJitter, uint32_audio_cache_ms_count: e3.audio.totalJitterCount, uint32_audio_codec_bitrate: e3.audio.bytesReceived, uint32_audio_total_bitrate: e3.audio.bytesReceived, uint32_audio_level: 1e8 * e3.audio.audioLevel, uint32_audio_energy: 1e6 * e3.audio.totalAudioEnergy, uint32_audio_receive: e3.audio.packetsReceived, uint32_audio_origin_lost: e3.audio.packetsLost };
              t3.msg_audio_status = i3;
            }
            if (e3.hasVideo) {
              let i3 = r2.get("".concat(e3.userId, "_").concat(gk)), n3 = i3 ? i3.duration : 0, o3 = { uint32_video_stream_type: e3.isSmallSubscribed ? 3 : 2, uint32_video_receive_fps: e3.video.framesReceived, uint32_video_width: e3.video.frameWidth, uint32_video_height: e3.video.frameHeight, uint32_video_codec_bitrate: e3.video.bytesReceived, uint32_video_receive: e3.video.packetsReceived, uint32_video_origin_lost: e3.video.packetsLost, uint32_video_block_time: n3, uint32_video_dec_fps: e3.video.framesDecoded };
              t3.msg_video_status.push(o3);
            }
            if (e3.hasAuxiliary) {
              let i3 = r2.get("".concat(e3.userId, "_").concat(Tk)), n3 = i3 ? i3.duration : 0, o3 = { uint32_video_stream_type: 7, uint32_video_receive_fps: e3.auxiliary.framesReceived, uint32_video_width: e3.auxiliary.frameWidth, uint32_video_height: e3.auxiliary.frameHeight, uint32_video_codec_bitrate: e3.auxiliary.bytesReceived, uint32_video_receive: e3.auxiliary.packetsReceived + e3.auxiliary.packetsLost, uint32_video_origin_lost: e3.auxiliary.packetsLost, uint32_video_block_time: n3, uint32_video_dec_fps: e3.auxiliary.framesDecoded };
              t3.msg_video_status.push(o3);
            }
            i2.msg_down_stream_info.push(t3);
          });
          let o2 = this._prevReport;
          if (this._prevReport = JSON.parse(JSON.stringify(i2)), i2.msg_up_stream_info.msg_audio_status && o2.msg_up_stream_info.msg_audio_status) {
            let e3 = o2.msg_up_stream_info.msg_audio_status, t3 = i2.msg_up_stream_info.msg_audio_status;
            if (0 === e3.uint32_audio_codec_bitrate)
              t3.uint32_audio_codec_bitrate = 0;
            else {
              let r3 = this.getDifferenceValue(e3.uint32_audio_codec_bitrate, t3.uint32_audio_codec_bitrate);
              t3.uint32_audio_codec_bitrate = Math.round(8 * r3 / n2), i2.msg_up_stream_info.msg_network_status.uint32_bitrate += t3.uint32_audio_codec_bitrate;
            }
          }
          let s2 = o2.msg_up_stream_info.msg_video_status;
          i2.msg_up_stream_info.msg_video_status.forEach((e3) => {
            let t3 = s2.find((t4) => t4.uint32_video_stream_type === e3.uint32_video_stream_type);
            if (!t3 || 0 === t3.uint32_video_codec_bitrate)
              return e3.uint32_video_codec_bitrate = 0, e3.uint32_video_enc_fps = 0, void (e3.uint32_video_codec_fps = 0);
            let r3 = 0, o3 = 0, a3 = 0;
            t3 && e3.uint32_video_codec_bitrate >= t3.uint32_video_codec_bitrate && (r3 = t3.uint32_video_codec_bitrate, o3 = t3.uint32_video_enc_fps, a3 = t3.uint32_video_codec_fps);
            let c2 = this.getDifferenceValue(r3, e3.uint32_video_codec_bitrate);
            e3.uint32_video_codec_bitrate = Math.round(8 * c2 / n2), i2.msg_up_stream_info.msg_network_status.uint32_bitrate += e3.uint32_video_codec_bitrate, e3.uint32_video_enc_fps = Math.round(this.getDifferenceValue(o3, e3.uint32_video_enc_fps) / n2), e3.uint32_video_codec_fps = Math.round(this.getDifferenceValue(a3, e3.uint32_video_codec_fps) / n2), oD && 115 === yD() && 0 === t3.uint32_video_width && 0 === t3.uint32_video_height && 0 === t3.uint32_video_codec_fps && (e3.uint32_video_codec_fps = e3.uint32_video_enc_fps), Mw(t3.uint32_key_frame_count) || (e3.uint32_key_frame_count = Math.round(this.getDifferenceValue(t3.uint32_key_frame_count, e3.uint32_key_frame_count))), Mw(t3.uint32_nack_count) || (e3.uint32_nack_count = Math.round(this.getDifferenceValue(t3.uint32_nack_count, e3.uint32_nack_count))), Mw(t3.uint32_pli_count) || (e3.uint32_pli_count = Math.round(this.getDifferenceValue(t3.uint32_pli_count, e3.uint32_pli_count))), Mw(t3.uint32_video_arq_packets) || (e3.uint32_video_arq_packets = Math.round(this.getDifferenceValue(t3.uint32_video_arq_packets, e3.uint32_video_arq_packets))), Mw(t3.uint32_encode_cost) || (e3.uint32_encode_cost = Math.round(this.getDifferenceValue(t3.uint32_encode_cost, e3.uint32_encode_cost) / n2)), Mw(t3.uint32_send_packet_cost) || (e3.uint32_send_packet_cost = Math.round(this.getDifferenceValue(t3.uint32_send_packet_cost, e3.uint32_send_packet_cost) / n2));
          });
          let a2 = o2.msg_down_stream_info;
          return i2.msg_down_stream_info = i2.msg_down_stream_info.filter((e3) => a2.find((t3) => t3.msg_user_info.uint64_tinyid === e3.msg_user_info.uint64_tinyid)), i2.msg_down_stream_info.forEach((e3) => {
            let t3 = a2.find((t4) => t4.msg_user_info.uint64_tinyid === e3.msg_user_info.uint64_tinyid);
            if (GM(e3.msg_audio_status) || GM(t3.msg_audio_status))
              e3.msg_audio_status = {};
            else {
              let i3 = e3.msg_audio_status, r3 = t3.msg_audio_status, o3 = this.getDifferenceValue(r3.uint32_audio_cache_ms_count, i3.uint32_audio_cache_ms_count);
              delete i3.uint32_audio_cache_ms_count, i3.uint32_audio_cache_ms = Math.floor(1e3 * this.getDifferenceValue(r3.uint32_audio_cache_ms, i3.uint32_audio_cache_ms) / o3) || 0;
              let s3 = this.room.remotePublishedUserMap.get(e3.msg_user_info.str_identifier);
              s3 && (s3.remoteAudioTrack.stat.jitterBufferDelay = i3.uint32_audio_cache_ms), i3.uint32_audio_origin_lost = this.getDifferenceValue(r3.uint32_audio_origin_lost, i3.uint32_audio_origin_lost), i3.uint32_audio_receive = this.getDifferenceValue(r3.uint32_audio_receive, i3.uint32_audio_receive), i3.uint32_audio_receive += i3.uint32_audio_origin_lost;
              let a3 = this.getDifferenceValue(r3.uint32_audio_codec_bitrate, i3.uint32_audio_codec_bitrate);
              i3.uint32_audio_codec_bitrate = Math.round(8 * a3 / n2), i3.uint32_audio_total_bitrate = Math.round(8 * a3 / n2);
            }
            if (e3.msg_video_status && t3.msg_video_status) {
              let i3 = t3.msg_video_status;
              e3.msg_video_status = e3.msg_video_status.filter((e4) => i3.find((t4) => t4.uint32_video_stream_type === e4.uint32_video_stream_type)), e3.msg_video_status.forEach((e4) => {
                let t4 = i3.find((t5) => t5.uint32_video_stream_type === e4.uint32_video_stream_type), r3 = t4.uint32_video_receive, o3 = t4.uint32_video_origin_lost, s3 = t4.uint32_video_codec_bitrate, a3 = t4.uint32_video_receive_fps, c2 = t4.uint32_video_dec_fps;
                e4.uint32_video_origin_lost = this.getDifferenceValue(o3, e4.uint32_video_origin_lost), e4.uint32_video_receive = this.getDifferenceValue(r3, e4.uint32_video_receive) + e4.uint32_video_origin_lost;
                let l2 = this.getDifferenceValue(s3, e4.uint32_video_codec_bitrate);
                e4.uint32_video_codec_bitrate = Math.round(8 * l2 / n2);
                let d2 = this.getDifferenceValue(a3, e4.uint32_video_receive_fps);
                e4.uint32_video_receive_fps = Math.round(d2 / n2), e4.uint32_video_dec_fps = Math.round(this.getDifferenceValue(c2, e4.uint32_video_dec_fps) / n2);
              });
            }
          }), i2;
        }
        getStatsReport(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { uplinkConnection: i2, downlinkConnections: r2, freezeMap: n2 } = e3;
            return function* () {
              let e4 = { msg_up_stream_info: { msg_audio_status: { uint32_audio_format: 11, uint32_audio_sample_rate: 0, uint32_audio_codec_bitrate: 0, uint32_audio_receive: 0, uint32_audio_origin_lost: 0, uint32_audio_level: 0, uint32_audio_energy: 0 }, msg_video_status: [], msg_network_status: { uint32_bitrate: 0, uint32_rtt: 0, uint32_lost: 0 } }, msg_down_stream_info: [{ msg_user_info: { str_identifier: "", uint64_tinyid: 0 }, msg_audio_status: { uint32_audio_cache_ms: 0, uint32_audio_format: 11, uint32_audio_sample_rate: 0, uint32_audio_codec_bitrate: 0, uint32_audio_total_bitrate: 0, uint32_audio_level: 0, uint32_audio_energy: 0, uint32_audio_receive: 0, uint32_audio_origin_lost: 0, uint32_audio_final_lost: 0 }, msg_video_status: [{ uint32_video_stream_type: 0, uint32_video_receive_fps: 0, uint32_video_width: 0, uint32_video_height: 0, uint32_video_codec_bitrate: 0, uint32_video_receive: 0, uint32_video_origin_lost: 0, uint32_video_block_time: 0, uint32_video_dec_fps: 0 }], msg_network_status: { uint32_bitrate: 0, uint32_rtt: 0, uint32_lost: 0 } }] }, o2 = yield t2.getStats(i2, r2);
              return "{}" === JSON.stringify(t2._prevReport) && (t2._prevReport = JSON.parse(JSON.stringify(e4))), t2.prepareReport({ stats: o2, report: e4, freezeMap: n2 }), t2._prevReportTime = Date.now(), e4;
            }();
          });
        }
        reset() {
          this._prevReportTime = 0, this._prevReport = {}, this._prevEncoderImplementation = "", this._prevQualityLimitationReason = "", this._prevDecoderImplementationMap = /* @__PURE__ */ new Map();
        }
      }, oU = nb(lb()), sU = class extends oU.default {
        constructor(e2) {
          let { signalChannel: t2, room: i2 } = e2;
          super(), sb(this, "_room"), sb(this, "_signalChannel"), sb(this, "_log"), sb(this, "_uplinkRTT", 0), sb(this, "_uplinkLoss", 0), sb(this, "_downlinkRTT", 0), sb(this, "_downlinkLoss", 0), sb(this, "_downlinkPrevStatMap", /* @__PURE__ */ new Map()), sb(this, "_downlinkLossAndRTTMap", /* @__PURE__ */ new Map()), sb(this, "_interval", -1), sb(this, "_uplinkNetworkQuality", 0), sb(this, "_downlinkNetworkQuality", 0), this._room = i2, this._signalChannel = t2, this._log = EO.createLogger({ id: "q", userId: this._room.userId, sdkAppId: this._room.sdkAppId }), this.initialize();
        }
        get uplinkNetworkQuality() {
          return this._uplinkNetworkQuality;
        }
        set uplinkNetworkQuality(e2) {
          e2 !== this._uplinkNetworkQuality && this._log.info("uplink ".concat(this.uplinkNetworkQuality, " -> ").concat(e2, ", rtt: ").concat(this._uplinkRTT, ", loss: ").concat(this._uplinkLoss)), this._uplinkNetworkQuality = e2;
        }
        get downlinkNetworkQuality() {
          return this._downlinkNetworkQuality;
        }
        set downlinkNetworkQuality(e2) {
          if (e2 !== this._downlinkNetworkQuality) {
            let { rtt: t2, loss: i2 } = this.getAverageLossAndRTT([...this._downlinkLossAndRTTMap.values()]);
            this._log.info("downlink ".concat(this.downlinkNetworkQuality, " -> ").concat(e2, ", rtt: ").concat(t2, ", loss: ").concat(i2));
          }
          this._downlinkNetworkQuality = e2;
        }
        initialize() {
          this._signalChannel.on(cV.UPLINK_NETWORK_STATS, (e2) => {
            this.handleUplinkNetworkQuality(e2);
          }), this._signalChannel.on(iV, this.handleSignalConnectionStateChange.bind(this)), this.start();
        }
        handleUplinkNetworkQuality(e2) {
          var t2, i2;
          if (0 !== e2.data.code)
            return;
          let r2 = e2.data.data;
          if (r2.delay && this.updateDelay(r2.delay), !this._room.uplinkConnection)
            return this.uplinkNetworkQuality = 0, this._uplinkLoss = 0, void (this._uplinkRTT = 0);
          let n2 = null == (i2 = null == (t2 = this._room) ? void 0 : t2.uplinkConnection) ? void 0 : i2.getPeerConnection();
          if (n2 && this.isPeerConnectionDisconnected(n2))
            return this.uplinkNetworkQuality = 6, this._uplinkLoss = 0, void (this._uplinkRTT = 0);
          let o2 = r2.expectAudPkg + r2.expectVidPkg, s2 = r2.recvAudPkg + r2.recvVidPkg, a2 = o2 - s2;
          0 === o2 && 0 === s2 || (this._uplinkLoss = a2 <= 0 ? 0 : Math.round(a2 / o2 * 100), this._uplinkRTT = r2.rtt, this.uplinkNetworkQuality = this.getNetworkQuality(this._uplinkLoss, this._uplinkRTT));
        }
        handleDownlinkNetworkQuality() {
          return cb(this, null, function* () {
            if (0 === this._room.remotePublishedUserMap.size)
              return void (this.downlinkNetworkQuality = 0);
            let e2 = [...this._room.remotePublishedUserMap.values()], t2 = e2.filter((e3) => {
              var t3;
              return (null == (t3 = e3.getPeerConnection()) ? void 0 : t3.connectionState) === bk.CONNECTED;
            });
            if (e2.filter((e3) => this.isPeerConnectionDisconnected(e3.getPeerConnection())).length === e2.length)
              return void (this.downlinkNetworkQuality = 6);
            for (let n2 = 0; n2 < t2.length; n2++) {
              let e3 = t2[n2].getPeerConnection();
              if (!e3)
                return;
              let { rtt: i3, totalPacketsLost: r3, totalPacketsReceived: o2 } = yield this.getStat(e3);
              if (!this._downlinkPrevStatMap.has(e3)) {
                this._downlinkPrevStatMap.set(e3, { totalPacketsLost: r3, totalPacketsReceived: o2 });
                continue;
              }
              let s2 = 0, a2 = this._downlinkPrevStatMap.get(e3), c2 = r3 - a2.totalPacketsLost, l2 = o2 - a2.totalPacketsReceived;
              s2 = c2 <= 0 || l2 < 0 ? 0 : Math.round(c2 / (c2 + l2) * 100), this._downlinkPrevStatMap.set(e3, { totalPacketsLost: r3, totalPacketsReceived: o2 }), this._downlinkLossAndRTTMap.set(e3, { rtt: i3, loss: s2, userId: t2[n2].getUserId(), audioDelay: t2[n2].remoteAudioTrack.stat.end2EndDelay, videoDelay: t2[n2].remoteVideoTrack.stat.end2EndDelay });
            }
            if ([...this._downlinkPrevStatMap.keys()].forEach((e3) => {
              this.isPeerConnectionDisconnected(e3) && (this._downlinkPrevStatMap.delete(e3), this._downlinkLossAndRTTMap.delete(e3));
            }), 0 === this._downlinkLossAndRTTMap.size)
              return;
            let { rtt: i2, loss: r2 } = this.getAverageLossAndRTT([...this._downlinkLossAndRTTMap.values()]);
            this._downlinkRTT = i2, this._downlinkLoss = r2, this.downlinkNetworkQuality = this.getNetworkQuality(r2, i2);
          });
        }
        getStat(e2) {
          return cb(this, null, function* () {
            let t2 = { rtt: 0, totalPacketsLost: 0, totalPacketsReceived: 0 };
            if (!e2 || !KO())
              return t2;
            let i2 = e2.getReceivers();
            try {
              for (let e3 = 0; e3 < i2.length; e3++)
                (yield i2[e3].getStats()).forEach((e4) => {
                  "candidate-pair" === e4.type && xw(e4.currentRoundTripTime) && (t2.rtt = Math.round(1e3 * e4.currentRoundTripTime)), "inbound-rtp" === e4.type && (e4.mediaType === ok.AUDIO || e4.mediaType === ok.VIDEO) && (t2.totalPacketsLost += e4.packetsLost, t2.totalPacketsReceived += e4.packetsReceived);
                });
              return t2;
            } catch (tM2) {
              return t2;
            }
          });
        }
        getAverageLossAndRTT(e2) {
          let t2 = { rtt: 0, loss: 0 };
          return Array.isArray(e2) && e2.length > 0 && (e2.forEach((e3) => {
            t2.rtt += e3.rtt, t2.loss += e3.loss;
          }), Object.keys(t2).forEach((i2) => {
            t2[i2] = Math.round(t2[i2] / e2.length);
          })), t2;
        }
        getNetworkQuality(e2, t2) {
          return e2 > 50 || t2 > 500 ? 5 : e2 > 30 || t2 > 350 ? 4 : e2 > 20 || t2 > 200 ? 3 : e2 > 10 || t2 > 100 ? 2 : e2 >= 0 || t2 >= 0 ? 1 : 0;
        }
        handleSignalConnectionStateChange(e2) {
          "DISCONNECTED" === e2.state ? (this._uplinkRTT = 0, this._uplinkLoss = 0, this.uplinkNetworkQuality = 6) : "CONNECTED" === e2.state && 6 === this.uplinkNetworkQuality && (this.uplinkNetworkQuality = 5);
        }
        handleUplinkConnectionStateChange(e2) {
          let { state: t2 } = e2;
          "DISCONNECTED" === t2 ? (this._uplinkLoss = 0, this._uplinkRTT = 0, this.uplinkNetworkQuality = 6) : "CONNECTED" === t2 && 6 === this.uplinkNetworkQuality && (this.uplinkNetworkQuality = 5);
        }
        isPeerConnectionDisconnected(e2) {
          return !(!e2 || e2.connectionState !== bk.DISCONNECTED && e2.connectionState !== bk.FAILED && e2.connectionState !== bk.CLOSED);
        }
        setUplinkConnection(e2) {
          this._room.uplinkConnection = e2, this._room.uplinkConnection ? this._room.uplinkConnection.on("connection-state-changed", this.handleUplinkConnectionStateChange.bind(this)) : (this.uplinkNetworkQuality = 0, this._uplinkRTT = 0, this._uplinkLoss = 0);
        }
        start() {
          -1 === this._interval ? (this._log.debug("start network quality calculating"), this._interval = yP.run(rN, () => {
            this.handleDownlinkNetworkQuality();
            let e2 = [...this._downlinkLossAndRTTMap.values()];
            ew.emit(gO.NETWORK_QUALITY, { room: this._room, uplink: { rtt: this._uplinkRTT, loss: this._uplinkLoss }, downlinks: e2 }), this.emit(sU.EVENT_NETWORK_QUALITY, { uplinkNetworkQuality: this.uplinkNetworkQuality, downlinkNetworkQuality: this.downlinkNetworkQuality, uplinkRTT: this._uplinkRTT, uplinkLoss: this._uplinkLoss, downlinkRTT: this._downlinkRTT, downlinkLoss: this._downlinkLoss, downlinkInfo: e2 });
          }, { delay: 2e3 })) : this._log.info("network quality calculating is already started");
        }
        stop() {
          this._log.debug("stopped"), -1 !== this._interval && (yP.clearTask(this._interval), this._interval = -1), this._downlinkLossAndRTTMap.clear(), this._downlinkPrevStatMap.clear();
        }
        updateDelay(e2) {
          let { tinyIdToUserIdMap: t2 } = this._room;
          e2.forEach((e3) => {
            let { srcTinyId: i2, videoDelay: r2, audioDelay: n2 } = e3, o2 = t2.get(i2);
            if (o2) {
              let e4 = this._room.remotePublishedUserMap.get(o2);
              null == e4 || e4.setDelay({ videoDelay: r2, audioDelay: n2 });
            }
          });
        }
      }, aU = sU;
      sb(aU, "EVENT_NETWORK_QUALITY", "0");
      var cU = class {
        constructor(e2) {
          this._signalInfo = { tinyId: void 0, clientIp: "", signalIp: "", relayIp: "", relayInnerIp: "", relayPort: 0 }, this._eventMap = /* @__PURE__ */ new Map(), this._frameWorkType = e2.frameWorkType || 30, this._component = e2.component || 0, this.connectionType = e2.connectionType || 1, this._language = e2.language || 0, this._room = e2.room, this._keyPrefix = "key_point", this._log = EO.createLogger({ id: "kpm", userId: this._room.userId, sdkAppId: this._room.sdkAppId }), Object.getOwnPropertyNames(this.__proto__).forEach((e3) => {
            e3.startsWith("handle") && Pw(this[e3]) && (this[e3] = function(e4) {
              let { fn: t2, context: i2 } = e4;
              return function() {
                try {
                  for (var e5 = arguments.length, r2 = new Array(e5), n2 = 0; n2 < e5; n2++)
                    r2[n2] = arguments[n2];
                  let o2 = t2.apply(i2, r2);
                  return jw(o2) ? o2.catch((e6) => EO.error("".concat(t2.name, "() error observed ").concat(e6))) : o2;
                } catch (wk2) {
                  EO.error("".concat(t2.name, "() error observed ").concat(wk2));
                }
              };
            }({ fn: this[e3], context: this }));
          }), this.initData(), this.installEvents(), this._intervalId = yP.run(rN, this.setStorage.bind(this), { delay: 2e4 });
        }
        get _storageKey() {
          return "".concat(this._keyPrefix, "_").concat(this._room.userId);
        }
        initData() {
          this._firstPublishedUserList = [], this._networkQuality = { totalUplinkRTT: 0, totalUplinkLoss: 0, count: 0, totalDownlinkRTTAndLossMap: /* @__PURE__ */ new Map() }, this._basicInfo = { string_sdk_version: Nb, uint32_os_type: 15, string_device_name: "", string_http_user_agent: navigator.userAgent, string_os_version: "", uint32_avg_rtt: 0, uint32_avg_up_loss: 0, uint32_scene: "live" === this._room.scene ? 1 : 0, uint32_joining_duration: 0, uint32_networkType: 0, uint32_framework: this._frameWorkType, uint32_component: this._component, uint32_connection_type: this.connectionType, uint32_caller_coding_language: this._language, string_domain: location.hostname }, this._pathJoinRoom = { uint64_start_time: 0, uint64_send_request_acc_ip_cmd_start_time: 0, uint64_send_request_acc_ip_cmd_end_time: 0, uint64_send_request_enter_room_cmd_start_time: 0, uint64_send_request_enter_room_cmd_end_time: 0, uint64_send_first_video_frame_time: 0, uint64_recv_userlist_time: 0, uint64_end_time: 0, int32_send_request_acc_ip_cmd_ret: 0, int32_send_request_enter_room_cmd_ret: 0, int32_end_ret: 0 }, this._pathLeaveRoom = { uint64_start_time: 0, uint64_send_request_exit_room_cmd_start_time: 0, uint64_send_request_exit_room_cmd_end_time: 0, uint64_end_time: 0, int32_send_request_exit_room_cmd_ret: 0, int32_end_ret: 0 }, this._localStreamStat = { totalVideoBitrate: 0, totalVideoFPS: 0, totalVideoHeight: 0, totalVideoWidth: 0, totalAudioLevel: 0, videoCount: 0, audioLevelCount: 0, publishStartTime: 0, statsToReport: { uint32_audio_capture_db: 0, uint32_video_big_capture_fps: 0, uint32_video_big_bitrate: 0, uint32_video_big_resolution: 0 } }, this._pathMainVideoMap = /* @__PURE__ */ new Map(), this._pathMainAudioMap = /* @__PURE__ */ new Map(), this._pathAuxiliaryMap = /* @__PURE__ */ new Map(), this._remoteStreamStatMap = /* @__PURE__ */ new Map(), GD().then((e2) => {
            this._basicInfo.string_os_version = KD(), this._basicInfo.string_device_name = e2 && e2.mobile ? e2.model : this._basicInfo.string_os_version;
          });
        }
        addEvent(e2, t2) {
          return this._eventMap.set(e2, t2), ew.on(e2, t2), this;
        }
        installEvents() {
          this.handleUnload = this.handleUnload.bind(this), window.addEventListener("unload", this.handleUnload), this._room.once("banned", () => this.handleLeaveSuccess({ room: this._room, roomId: this._room.roomId })), this.addEvent(gO.JOIN_START, this.handleJoinStart).addEvent(gO.JOIN_SCHEDULE_SUCCESS, this.handleJoinScheduleSuccess).addEvent(gO.JOIN_SIGNAL_CONNECTION_START, this.handleSignalConnectionStart).addEvent(gO.JOIN_SIGNAL_CONNECTION_END, this.handleSignalConnectionEnd).addEvent(gO.JOIN_SEND_CMD, this.handleJoinSendCMD).addEvent(gO.JOIN_RECEIVED_CMD_RES, this.handleJoinReceivedCMDResponce).addEvent(gO.JOIN_SUCCESS, this.handleJoinSuccess).addEvent(gO.JOIN_FAILED, this.handleJoinFailed).addEvent(gO.LEAVE_START, this.handleLeaveStart).addEvent(gO.LEAVE_SUCCESS, this.handleLeaveSuccess).addEvent(gO.LEAVE_SEND_CMD, this.handleLeaveSendCMD).addEvent(gO.LOCAL_TRACK_CAPTURE_START, this.handleTrackCaptureStart).addEvent(gO.LOCAL_TRACK_CAPTURE_SUCCESS, this.handleTrackCaptureSuccess).addEvent(gO.LOCAL_TRACK_CAPTURE_FAILED, this.handleTrackCaptureFailed).addEvent(gO.PUBLISH_START, this.handlePublishStart).addEvent(gO.SEND_FIRST_VIDEO_FRAME, this.handleSendFirstVideoFrame).addEvent(gO.SUBSCRIBE_START, this.handleSubscribeStart).addEvent(gO.SUBSCRIBE_SUCCESS, this.handleSubscribed).addEvent(gO.PLAY_TRACK_START, this.handlePlayStart).addEvent(gO.VIDEO_LOADED_DATA, this.handleVideoLoadedData).addEvent(gO.PLAYER_STATE_CHANGED, (e2) => {
            let { track: t2, state: i2, type: r2 } = e2;
            !Hw(t2) || !this.hitTest(t2.room) || "PLAYING" === i2 && (r2 === ok.AUDIO ? this.handleAudioPlaying(t2) : this.handleVideoPlaying(t2));
          }).addEvent(gO.NETWORK_QUALITY, this.handleNetworkQuality).addEvent(gO.HEARTBEAT_REPORT, this.handleHeartbeatStats).addEvent(gO.RECEIVED_PUBLISHED_USER_LIST, this.handleReceivedPublishUserList).addEvent(gO.REMOTE_PUBLISH_STATE_CHANGED, (e2) => {
            let { room: t2, prevMuteState: i2, muteState: r2 } = e2;
            if (!this.hitTest(t2))
              return;
            let n2 = i2.hasAudio || i2.hasVideo || i2.hasSmall, o2 = i2.hasAuxiliary, s2 = r2.hasAudio || r2.hasVideo || r2.hasSmall, a2 = r2.hasAuxiliary;
            !n2 && s2 && this.handleRemoteStreamAdded(r2.userId, "main"), !o2 && a2 && this.handleRemoteStreamAdded(r2.userId, "auxiliary");
          }).addEvent(gO.SINGLE_CONNECTION_STAT, (e2) => {
            let { room: t2, stat: i2 } = e2;
            this.hitTest(t2) && (this._pathJoinRoom.int32_ice_cost = i2.ice, this._pathJoinRoom.int32_dtls_cost = i2.dtls, this._pathJoinRoom.int32_peer_connection_cost = i2.peerConnection);
          });
        }
        uninstallEvents() {
          window.removeEventListener("unload", this.handleUnload), this._eventMap.forEach((e2, t2) => ew.off(t2, e2)), this._eventMap.clear();
        }
        destroy() {
          this.uninstallEvents(), yP.clearTask(this._intervalId);
        }
        handleUnload() {
          this._room.isJoined && this.handleLeaveSuccess({ room: this._room, roomId: this._room.roomId });
        }
        handleJoinStart(e2) {
          this.hitTest(e2.room) && (0 === this._pathJoinRoom.uint64_start_time && (this._pathJoinRoom.uint64_start_time = Date.now(), this.checkStorage()), e2.params && (Mw(e2.params.frameWorkType) || (this._frameWorkType = e2.params.frameWorkType, this._basicInfo.uint32_framework = this._frameWorkType), Mw(e2.params.component) || (this._component = e2.params.component, this._basicInfo.uint32_component = this._component), Mw(e2.params.language) || (this._language = e2.params.language, this._basicInfo.uint32_caller_coding_language = this._language)));
        }
        handleJoinScheduleSuccess(e2) {
          let { room: t2, detailCost: i2 } = e2;
          if (this.hitTest(t2) && i2) {
            let { totalCost: e3, local: t3, dns: r2, tcp: n2, tls: o2, request: s2, response: a2 } = i2;
            this._pathJoinRoom.int32_schedule_cost = e3, this._pathJoinRoom.int32_schedule_local = t3, this._pathJoinRoom.int32_schedule_dns = r2, this._pathJoinRoom.int32_schedule_tcp = n2, this._pathJoinRoom.int32_schedule_tls = o2, this._pathJoinRoom.int32_schedule_request = s2, this._pathJoinRoom.int32_schedule_response = a2;
          }
        }
        handleSignalConnectionStart(e2) {
          let { room: t2 } = e2;
          this.hitTest(t2) && 0 === this._pathJoinRoom.uint64_send_request_acc_ip_cmd_start_time && (this._pathJoinRoom.uint64_send_request_acc_ip_cmd_start_time = Date.now());
        }
        handleSignalConnectionEnd(e2) {
          let { room: t2, error: i2 } = e2;
          this.hitTest(t2) && 0 === this._pathJoinRoom.uint64_send_request_acc_ip_cmd_end_time && (this._pathJoinRoom.uint64_send_request_acc_ip_cmd_end_time = Date.now(), i2 && (this._pathJoinRoom.int32_send_request_acc_ip_cmd_ret = i2 instanceof vb ? Number(i2.getExtraCode() || i2.getCode()) : Sb.UNKNOWN, this._pathJoinRoom.int32_end_ret = this._pathJoinRoom.int32_send_request_acc_ip_cmd_ret));
        }
        handleJoinSendCMD(e2) {
          this.hitTest(e2.room) && 0 === this._pathJoinRoom.uint64_send_request_enter_room_cmd_start_time && (this._pathJoinRoom.uint64_send_request_enter_room_cmd_start_time = Date.now());
        }
        handleJoinReceivedCMDResponce(e2) {
          this.hitTest(e2.room) && 0 === this._pathJoinRoom.uint64_send_request_enter_room_cmd_end_time && (this._pathJoinRoom.uint64_send_request_enter_room_cmd_end_time = Date.now(), this._pathJoinRoom.int32_send_request_enter_room_cmd_ret = e2.code, 0 !== e2.code && (this._pathJoinRoom.int32_end_ret = this._pathJoinRoom.int32_send_request_enter_room_cmd_ret));
        }
        handleJoinSuccess(e2) {
          this.hitTest(e2.room) && 0 === this._pathJoinRoom.uint64_end_time && (this._pathJoinRoom.uint64_end_time = Date.now(), this._pathJoinRoom.int32_end_ret = 0, this._signalInfo = e2.room.getSignalInfo());
        }
        handleJoinFailed(e2) {
          let { room: t2, error: i2 } = e2;
          this.hitTest(t2) && (this._pathJoinRoom.uint64_end_time = Date.now(), 0 === this._pathJoinRoom.int32_end_ret && (this._pathJoinRoom.int32_end_ret = i2.code || this._pathJoinRoom.int32_send_request_enter_room_cmd_ret || this._pathJoinRoom.int32_send_request_acc_ip_cmd_ret), setTimeout(() => {
            this.report();
          }));
        }
        handleReceivedPublishUserList(e2) {
          this.hitTest(e2.room) && 0 === this._pathJoinRoom.uint64_recv_userlist_time && (this._pathJoinRoom.uint64_recv_userlist_time = Date.now(), this._firstPublishedUserList = e2.publishedUserList || []);
        }
        handleSendFirstVideoFrame(e2) {
          let { room: t2 } = e2;
          !this.hitTest(t2) || 0 === this._pathJoinRoom.uint64_send_first_video_frame_time && 0 !== this._pathJoinRoom.uint64_start_time && (this._pathJoinRoom.uint64_send_first_video_frame_time = Date.now());
        }
        handleLeaveStart(e2) {
          this.hitTest(e2.room) && (this._pathLeaveRoom.uint64_start_time = Date.now());
        }
        handleLeaveSuccess(e2) {
          this.hitTest(e2.room) && 0 === this._pathLeaveRoom.uint64_end_time && (this._pathLeaveRoom.uint64_end_time = Date.now(), 0 !== this._pathJoinRoom.uint64_end_time ? this._basicInfo.uint32_joining_duration = this._pathLeaveRoom.uint64_end_time - this._pathJoinRoom.uint64_end_time : this._log.warn("pathJoinRoom endTime is 0"), this.report());
        }
        handleLeaveSendCMD(e2) {
          this.hitTest(e2.room) && (this._pathLeaveRoom.uint64_send_request_exit_room_cmd_start_time = Date.now(), this._pathLeaveRoom.uint64_send_request_exit_room_cmd_end_time = Date.now());
        }
        handleRemoteStreamAdded(e2, t2) {
          var i2;
          let r2 = "".concat(e2, "_").concat(t2);
          if (!this._remoteStreamStatMap.has(r2)) {
            let n2 = { userId: e2, totalVideoFPS: 0, totalVideoBitrate: 0, totalAudioLevel: 0, totalAudioBitrate: 0, totalLoss: 0, audioCount: 0, audioLevelCount: 0, videoCount: 0, networkQualityCount: 0, streamAddedTime: Date.now(), subscribeStartTime: 0, subscribedTime: 0, playStreamTime: 0, statsToReport: tb(eb({}, dU), { msg_user_info: new uU({ userId: e2, tinyId: null == (i2 = this._room.remotePublishedUserMap.get(e2)) ? void 0 : i2.tinyId, role: 20 }) }) };
            n2.statsToReport.uint32_stream_type = "main" === t2 ? 2 : 7, this._remoteStreamStatMap.set(r2, n2);
          }
        }
        handleSubscribeStart(e2) {
          let { room: t2, remotePublishedUser: i2, streamType: r2, subscribeState: n2 } = e2;
          if (!this.hitTest(t2))
            return;
          let { userId: o2, tinyId: s2, role: a2 } = i2, c2 = new uU({ userId: o2, tinyId: s2, role: "anchor" === a2 ? 20 : 21 }), l2 = Date.now(), d2 = "".concat(o2, "_").concat(r2), u2 = this._remoteStreamStatMap.get(d2);
          u2 && 0 === u2.subscribeStartTime && (u2.subscribeStartTime = l2), "main" === r2 ? (i2.muteState.hasVideo && (n2.video || n2.smallVideo) && !this._pathMainVideoMap.has(d2) && this._pathMainVideoMap.set(d2, { statsToReport: { msg_user_info: c2, uint64_start_enter_time: this._pathJoinRoom.uint64_start_time, uint64_render_first_frame_time: 0, uint64_combine_first_frame_time: 0 }, userId: o2, sendSubscribeCMDTime: l2 }), i2.muteState.hasAudio && n2.audio && !this._pathMainAudioMap.has(d2) && this._pathMainAudioMap.set(d2, { statsToReport: { msg_user_info: c2, uint64_start_enter_time: this._pathJoinRoom.uint64_start_time, uint64_play_first_frame_time: 0 }, userId: o2, sendSubscribeCMDTime: l2 })) : i2.muteState.hasAuxiliary && n2.auxiliary && !this._pathAuxiliaryMap.has(d2) && this._pathAuxiliaryMap.set(d2, { sendSubscribeCMDTime: l2 });
        }
        handleSubscribed(e2) {
          let { room: t2, remotePublishedUser: i2, streamType: r2 } = e2;
          if (this.hitTest(t2)) {
            let e3 = "".concat(i2.userId, "_").concat(r2), t3 = this._remoteStreamStatMap.get(e3);
            t3 && 0 === t3.subscribedTime && (t3.subscribedTime = Date.now());
          }
        }
        handlePlayStart(e2) {
          let { track: t2 } = e2;
          if (!Hw(t2) || !this.hitTest(t2.room))
            return;
          let i2 = "".concat(t2.userId, "_").concat(t2.streamType), r2 = this._remoteStreamStatMap.get(i2);
          0 === (null == r2 ? void 0 : r2.playStreamTime) && (r2.playStreamTime = Date.now());
        }
        handleVideoLoadedData(e2) {
          let { track: t2 } = e2;
          if (!Hw(t2) || !this.hitTest(t2.room))
            return;
          let i2 = "".concat(t2.userId, "_").concat(t2.streamType), r2 = this._pathMainVideoMap.get(i2);
          r2 && 0 === r2.statsToReport.uint64_combine_first_frame_time && (r2.statsToReport.uint64_combine_first_frame_time = Date.now());
        }
        handleVideoPlaying(e2) {
          let t2 = "".concat(e2.userId, "_").concat(e2.streamType), i2 = Date.now(), r2 = this._pathMainVideoMap.get(t2), n2 = this._remoteStreamStatMap.get(t2);
          if (r2 && (0 === r2.statsToReport.uint64_render_first_frame_time && (r2.statsToReport.uint64_render_first_frame_time = i2), n2)) {
            let { statsToReport: e3, playStreamTime: t3, subscribedTime: o3 } = n2;
            0 === e3.uint32_video_render_first && t3 - o3 <= 100 && (e3.uint32_video_render_first = i2 - r2.sendSubscribeCMDTime);
          }
          let o2 = this._pathAuxiliaryMap.get(t2);
          if (o2 && n2) {
            let { statsToReport: e3, playStreamTime: t3, subscribedTime: r3 } = n2;
            0 === e3.uint32_video_render_first && t3 - r3 <= 100 && (e3.uint32_video_render_first = i2 - o2.sendSubscribeCMDTime);
          }
        }
        handleAudioPlaying(e2) {
          let t2 = "".concat(e2.userId, "_").concat(e2.streamType), i2 = this._pathMainAudioMap.get(t2);
          i2 && 0 === i2.statsToReport.uint64_play_first_frame_time && (i2.statsToReport.uint64_play_first_frame_time = Date.now());
        }
        handleNetworkQuality(e2) {
          this.hitTest(e2.room) && (this._networkQuality.totalUplinkLoss += e2.uplink.loss, this._networkQuality.totalUplinkRTT += e2.uplink.rtt, this._networkQuality.count++, e2.downlinks.forEach((e3) => {
            let { rtt: t2, loss: i2, userId: r2, videoDelay: n2, audioDelay: o2 } = e3, s2 = this._networkQuality.totalDownlinkRTTAndLossMap.get(r2);
            if (s2)
              s2.totalRTT += t2, s2.totalLoss += i2, n2 && (s2.totalVideoDelay = (s2.totalVideoDelay || 0) + n2, s2.videoDelayCount = (s2.videoDelayCount || 0) + 1), o2 && (s2.totalAudioDelay = (s2.totalAudioDelay || 0) + o2, s2.audioDelayCount = (s2.audioDelayCount || 0) + 1), s2.count++;
            else {
              let e4, s3, a2, c2;
              n2 && (s3 = n2, a2 = 1), o2 && (e4 = o2, c2 = 1), this._networkQuality.totalDownlinkRTTAndLossMap.set(r2, { totalRTT: t2, totalLoss: i2, count: 1, totalAudioDelay: e4, totalVideoDelay: s3, audioDelayCount: c2, videoDelayCount: a2 });
            }
          }));
        }
        handleHeartbeatStats(e2) {
          if (this.hitTest(e2.room)) {
            let { msg_up_stream_info: t2, msg_down_stream_info: i2 } = e2.report;
            if (t2.msg_video_status[0]) {
              let { uint32_video_codec_bitrate: e3, uint32_video_enc_fps: i3, uint32_video_width: r2, uint32_video_height: n2 } = t2.msg_video_status[0];
              this._localStreamStat.totalVideoBitrate += e3, this._localStreamStat.totalVideoFPS += i3, this._localStreamStat.totalVideoWidth += r2, this._localStreamStat.totalVideoHeight += n2, this._localStreamStat.videoCount++;
            }
            if (t2.msg_audio_status) {
              let { uint32_audio_level: e3 } = t2.msg_audio_status;
              Math.floor(e3 / dN * 100) > 0 && (this._localStreamStat.totalAudioLevel += e3 / dN, this._localStreamStat.audioLevelCount++);
            }
            i2.forEach((e3) => {
              let { msg_user_info: t3, msg_audio_status: i3, msg_video_status: r2 } = e3, n2 = t3.str_identifier, o2 = this._room.remotePublishedUserMap.get(n2);
              if (r2.forEach((e4) => {
                let t4 = 2 === e4.uint32_video_stream_type, i4 = 7 === e4.uint32_video_stream_type, r3 = "".concat(n2, "_").concat(t4 ? "main" : "auxiliary"), s2 = this._remoteStreamStatMap.get(r3);
                if (s2 && (t4 && (null == o2 ? void 0 : o2.remoteVideoTrack.isSubscribed) || i4 && (null == o2 ? void 0 : o2.remoteAuxiliaryTrack))) {
                  s2.totalVideoFPS += e4.uint32_video_receive_fps, s2.totalVideoBitrate += e4.uint32_video_codec_bitrate, s2.videoCount++, 0 === s2.statsToReport.uint32_video_width && (s2.statsToReport.uint32_video_width = e4.uint32_video_width), 0 === s2.statsToReport.uint32_video_height && (s2.statsToReport.uint32_video_height = e4.uint32_video_height);
                  let i5 = t4 ? o2.remoteVideoTrack : o2.remoteAuxiliaryTrack;
                  i5.stat.jitterBufferDelay && (s2.videoJitterBufferDelay = i5.stat.jitterBufferDelay), i5.stat.framesReceived && (s2.statsToReport.uint32_video_consume_render_rate = Math.floor(i5.stat.framesDecoded / i5.stat.framesReceived * $C(10, 6)));
                }
              }), i3) {
                let e4 = "".concat(n2, "_", "main"), t4 = this._remoteStreamStatMap.get(e4);
                this._remoteStreamStatMap.has(e4) && t4 && (null == o2 ? void 0 : o2.remoteAudioTrack.isSubscribed) && (t4.totalAudioBitrate += i3.uint32_audio_codec_bitrate, t4.audioCount++, o2.remoteAudioTrack.stat.jitterBufferDelay && (t4.audioJitterBufferDelay = o2.remoteAudioTrack.stat.jitterBufferDelay), Math.floor(i3.uint32_audio_level / dN * 100) > 0 && (t4.totalAudioLevel += i3.uint32_audio_level / dN, t4.audioLevelCount++));
              }
            });
          }
        }
        handlePublishStart(e2) {
          let { room: t2 } = e2;
          this.hitTest(t2) && 0 === this._localStreamStat.publishStartTime && (this._localStreamStat.publishStartTime = Date.now());
        }
        handleTrackCaptureStart(e2) {
          let { track: t2 } = e2;
          1 === t2.mediaType && !this._pathJoinRoom.uint64_init_audio_start_time && (this._pathJoinRoom.uint64_init_audio_start_time = Date.now()), 4 === t2.mediaType && !this._pathJoinRoom.uint64_init_camera_start_time && (this._pathJoinRoom.uint64_init_camera_start_time = Date.now());
        }
        handleTrackCaptureSuccess(e2) {
          let { track: t2 } = e2;
          1 === t2.mediaType && !this._pathJoinRoom.uint64_init_audio_end_time && (this._pathJoinRoom.int32_init_audio_ret = 0, this._pathJoinRoom.uint64_init_audio_end_time = Date.now()), 4 === t2.mediaType && !this._pathJoinRoom.uint64_init_camera_end_time && (this._pathJoinRoom.int32_init_camera_ret = 0, this._pathJoinRoom.uint64_init_camera_end_time = Date.now());
        }
        handleTrackCaptureFailed(e2) {
          let { track: t2, error: i2 } = e2, r2 = { NotFoundError: 1, NotAllowedError: 2, NotReadableError: 3, OverConstrainedError: 4, AbortError: 5, InvalidStateError: 6, SecurityError: 7, TypeError: 8 }[i2.name] || (i2 instanceof vb ? i2.getExtraCode() || i2.getCode() : Sb.UNKNOWN);
          1 === t2.mediaType && !this._pathJoinRoom.uint64_init_audio_end_time && (this._pathJoinRoom.int32_init_audio_ret = r2, this._pathJoinRoom.uint64_init_audio_end_time = Date.now()), 4 === t2.mediaType && !this._pathJoinRoom.uint64_init_camera_end_time && (this._pathJoinRoom.int32_init_camera_ret = r2, this._pathJoinRoom.uint64_init_camera_end_time = Date.now());
        }
        hasVideoFlag(e2) {
          return this._firstPublishedUserList.findIndex((t2) => t2.userId === e2 && t2.flag & lk) >= 0;
        }
        hasAudioFlag(e2) {
          return this._firstPublishedUserList.findIndex((t2) => t2.userId === e2 && t2.flag & hk) >= 0;
        }
        hasAuxFlag(e2) {
          return this._firstPublishedUserList.findIndex((t2) => t2.userId === e2 && t2.flag & uk) >= 0;
        }
        hitTest(e2) {
          return e2 === this._room;
        }
        checkStorage() {
          return cb(this, null, function* () {
            try {
              let e2 = IO.getItem(this._storageKey);
              e2 && (yield this.upload(e2), IO.deleteItem(this._storageKey));
            } catch (rM2) {
              this._log.warn(rM2);
            }
          });
        }
        setStorage() {
          this.prepareReport();
          let e2 = this.getReportData();
          0 !== e2.msg_path_enter_room.uint64_start_time && IO.setItem(this._storageKey, e2);
        }
        prepareReport() {
          if (this._networkQuality.count > 0 && (this._basicInfo.uint32_avg_rtt = Math.floor(this._networkQuality.totalUplinkRTT / this._networkQuality.count), this._basicInfo.uint32_avg_up_loss = Math.floor(this._networkQuality.totalUplinkLoss / this._networkQuality.count)), this._localStreamStat.videoCount > 0) {
            this._localStreamStat.statsToReport.uint32_video_big_capture_fps = Math.floor(this._localStreamStat.totalVideoFPS / this._localStreamStat.videoCount), this._localStreamStat.statsToReport.uint32_video_big_bitrate = Math.floor(this._localStreamStat.totalVideoBitrate / this._localStreamStat.videoCount);
            let e2 = Math.floor(this._localStreamStat.totalVideoWidth / this._localStreamStat.videoCount), t2 = Math.floor(this._localStreamStat.totalVideoHeight / this._localStreamStat.videoCount);
            this._localStreamStat.statsToReport.uint32_video_big_resolution = e2 << 16 | t2;
          }
          this._localStreamStat.audioLevelCount > 0 && (this._localStreamStat.statsToReport.uint32_audio_capture_db = Math.floor(this._localStreamStat.totalAudioLevel / this._localStreamStat.audioLevelCount * 100)), this._remoteStreamStatMap.forEach((e2, t2) => {
            let { userId: i2 } = e2, r2 = this._networkQuality.totalDownlinkRTTAndLossMap.get(i2);
            if (r2) {
              let { totalLoss: t3, count: i3, audioDelayCount: n3, videoDelayCount: o3, totalAudioDelay: s3, totalVideoDelay: a3 } = r2;
              e2.statsToReport.uint32_avg_down_loss = Math.floor(t3 / i3), n3 && s3 && (e2.statsToReport.uint32_audio_network_p2p_delay = Math.floor(s3 / n3), e2.audioJitterBufferDelay && (e2.statsToReport.uint32_p2p_delay = Math.floor(e2.statsToReport.uint32_audio_network_p2p_delay + e2.audioJitterBufferDelay))), o3 && a3 && (e2.statsToReport.uint32_video_network_p2p_delay = Math.floor(a3 / o3));
            }
            e2.videoCount > 0 && (e2.statsToReport.uint32_video_avg_fps = Math.floor(e2.totalVideoFPS / e2.videoCount), e2.statsToReport.uint32_video_avg_bitrate = Math.floor(e2.totalVideoBitrate / e2.videoCount)), e2.audioCount > 0 && (e2.statsToReport.uint32_audio_recv_bitrate = e2.statsToReport.uint32_audio_bitrate = Math.floor(e2.totalAudioBitrate / e2.audioCount)), e2.audioLevelCount > 0 && (e2.statsToReport.uint32_audio_play_db = Math.floor(e2.totalAudioLevel / e2.audioLevelCount * 100));
            let { callDurationCalculator: n2 } = this._room;
            n2 && (e2.statsToReport.uint32_audio_play_time = n2.getDuration(t2, ok.AUDIO), e2.statsToReport.uint32_video_play_time = n2.getDuration(t2, ok.VIDEO)), e2.statsToReport.uint32_video_render_first = Math.min(e2.statsToReport.uint32_video_render_first, lU);
            let { badCaseDetector: o2 } = this._room, { dataFreeze: s2, count: a2 } = o2.getDataFreezeDuration(t2), { renderFreeze: c2 } = o2.getRenderFreezeDuration(t2);
            e2.statsToReport.uint32_video_block_count = a2, e2.statsToReport.uint32_video_block_time = Math.min(s2, e2.statsToReport.uint32_video_play_time), e2.statsToReport.uint32_video_external_block_time = Math.min(c2, e2.statsToReport.uint32_video_play_time), o2.isBlackStream(t2) && 0 === e2.statsToReport.uint32_video_avg_fps ? e2.statsToReport.uint32_video_black_screen_subjective = 1 : e2.statsToReport.uint32_video_black_screen_subjective = 0, (0 === e2.subscribeStartTime || e2.subscribeStartTime - e2.streamAddedTime > 100 || 0 === e2.playStreamTime) && (this._pathMainAudioMap.delete(t2), this._pathMainVideoMap.delete(t2), e2.statsToReport.uint32_video_render_first = 0);
          }), this._pathMainAudioMap.forEach((e2, t2) => {
            this.hasAudioFlag(e2.userId) ? e2.statsToReport.uint64_play_first_frame_time - e2.statsToReport.uint64_start_enter_time > lU && (e2.statsToReport.uint64_play_first_frame_time = e2.statsToReport.uint64_start_enter_time + lU) : this._pathMainAudioMap.delete(t2);
          }), this._pathMainVideoMap.forEach((e2, t2) => {
            this.hasVideoFlag(e2.userId) ? e2.statsToReport.uint64_render_first_frame_time - e2.statsToReport.uint64_start_enter_time > lU && (e2.statsToReport.uint64_render_first_frame_time = e2.statsToReport.uint64_start_enter_time + lU) : this._pathMainVideoMap.delete(t2);
          }), this._pathJoinRoom.uint64_end_time - this._pathJoinRoom.uint64_start_time > lU && (this._pathJoinRoom.uint64_end_time = this._pathJoinRoom.uint64_start_time + lU);
        }
        getReportData() {
          this._basicInfo.uint32_networkType = Iw();
          let e2 = { uint32_sdk_app_id: Number(this._room.sdkAppId), msg_user_info: new uU({ userId: this._room.userId, tinyId: this._room.tinyId, role: "anchor" === this._room.role ? 20 : 21 }), msg_basic_info: this._basicInfo, uint32_acc_ip: eO(this._signalInfo.relayIp), uint32_client_ip: eO(this._signalInfo.clientIp, false), uint32_acc_port: this._signalInfo.relayPort || 0, uint64_timestamp: Date.now(), uint32_seq: Math.floor(Math.random() * $C(2, 31)), msg_path_enter_room: this._pathJoinRoom, msg_path_exit_room: this._pathLeaveRoom, msg_path_recv_video: [...this._pathMainVideoMap.values()].map((e3) => e3.statsToReport), msg_quality_statistics: [...this._remoteStreamStatMap.values()].map((e3) => e3.statsToReport), str_room_name: String(this._room.roomId || 0), msg_path_recv_audio: [...this._pathMainAudioMap.values()].map((e3) => e3.statsToReport), uint32_info_client_ip: eO(this._signalInfo.clientIp, false), error_code: [], msg_local_statistics: this._localStreamStat.statsToReport };
          return pO(e2), e2;
        }
        report() {
          return cb(this, null, function* () {
            try {
              this.prepareReport();
              let e2 = this.getReportData();
              yield this.upload(e2), IO.deleteItem(this._storageKey), this.initData();
            } catch (rM2) {
              this._log.warn(rM2);
            }
          });
        }
        upload(e2) {
          return cb(this, null, function* () {
            if (UD && !uD || 0 === e2.msg_path_enter_room.uint64_start_time || [Fb, Bb, Hb].findIndex((e3) => e3 === location.host) >= 0)
              return;
            let t2 = Number(this._room.sdkAppId), i2 = yield lN(e2), r2 = i2 instanceof ArrayBuffer, n2 = "".concat(fw(t2, qb.KEY_POINT), "&gzip=").concat(+r2), o2 = false;
            navigator.sendBeacon && (o2 = navigator.sendBeacon(n2, i2)), o2 || cN({ url: n2, body: i2 }), this.uploadKVStat(mM), this.uploadKVStat(pM);
          });
        }
        setConnectionType(e2) {
          this.connectionType = e2, this._basicInfo.uint32_connection_type = e2;
        }
        uploadKVStat(e2) {
          return cb(this, null, function* () {
            let t2 = e2.getReportData();
            if (0 === t2.stats_count.length && 0 === t2.stats_distribution.length)
              return;
            t2.msg_sdk_basic_info = tb(eb({}, t2.msg_sdk_basic_info), { bytes_device_name: this._basicInfo.string_device_name || "", bytes_os_version: this._basicInfo.string_os_version || "", uint32_framework: this._frameWorkType, uint32_network_type: this._basicInfo.uint32_networkType || 0 }), this._log.debug(t2);
            let i2 = yield lN(t2), r2 = "".concat(fw(+this._room.sdkAppId, qb.KV_STAT), "&gzip=").concat(+(i2 instanceof ArrayBuffer)), n2 = false;
            navigator.sendBeacon && (n2 = navigator.sendBeacon(r2, i2)), n2 || cN({ url: r2, body: i2 });
          });
        }
      };
      ob([VV({ settings: { timeout: 500, retries: 3 } })], cU.prototype, "upload", 1);
      var lU = 5e3, dU = { msg_user_info: null, uint32_video_avg_fps: 0, uint32_video_width: 0, uint32_video_height: 0, uint32_video_avg_bitrate: 0, uint32_video_block_time: 0, uint32_video_play_time: 0, uint32_audio_block_time: 0, uint32_audio_play_time: 0, uint32_audio_play_db: 0, uint32_avg_down_loss: 0, uint32_stream_type: 0, uint32_video_render_first: 0, uint32_video_block_count: 0, uint32_audio_block_count: 0, uint32_audio_bitrate: 0, uint32_video_black_screen_subjective: 0, uint32_audio_recv_bitrate: 0, uint32_video_external_block_time: 0, uint32_video_consume_render_rate: 0 }, uU = class {
        constructor(e2) {
          this.str_identifier = String(e2.userId), this.str_tinyid = String(e2.tinyId || 0), this.uint32_role = e2.role;
        }
      }, hU = cU, pU = class {
        constructor() {
          sb(this, "_startTime"), sb(this, "_endTime"), this._startTime = 0, this._endTime = 0, this.start();
        }
        start() {
          0 === this._startTime && (this._startTime = zw());
        }
        stop() {
          0 === this._endTime && (this._endTime = zw());
        }
        getDuration() {
          return 0 === this._endTime ? zw() - this._startTime : this._endTime - this._startTime;
        }
        get endTime() {
          return this._endTime;
        }
      }, mU = class {
        constructor(e2) {
          sb(this, "_room", null), sb(this, "_durationMap"), sb(this, "_eventMap", /* @__PURE__ */ new Map()), this._room = e2.room, this._durationMap = /* @__PURE__ */ new Map(), this.installEvents();
        }
        installEvents() {
          this._eventMap.set(gO.SUBSCRIBE_SUCCESS, this.handleSubscribed).set(gO.UNSUBSCRIBE_SUCCESS, this.handleStreamStopped).set(gO.REMOTE_PUBLISH_STATE_CHANGED, (e2) => {
            let { room: t2, prevMuteState: i2, muteState: r2 } = e2;
            var n2;
            let { userId: o2 } = r2;
            if (!this.hitTest(t2))
              return;
            i2.hasAudio && !r2.hasAudio && this.stopDurationItem("".concat(o2, "_", "main"), ok.AUDIO), i2.hasVideo && !r2.hasVideo && this.stopDurationItem("".concat(o2, "_", "main"), ok.VIDEO), i2.hasAuxiliary && !r2.hasAuxiliary && this.stopDurationItem("".concat(o2, "_", "auxiliary"), ok.VIDEO);
            let s2 = null == (n2 = this._room) ? void 0 : n2.remotePublishedUserMap.get(o2);
            !s2 || (!i2.hasAudio && r2.hasAudio && s2.remoteAudioTrack.isSubscribed && this.addDuractionItem(o2, ok.AUDIO, "main"), !i2.hasVideo && r2.hasVideo && s2.remoteVideoTrack.isSubscribed && this.addDuractionItem(o2, ok.VIDEO, "main"), !i2.hasAuxiliary && r2.hasAuxiliary && s2.remoteAuxiliaryTrack.isSubscribed && this.addDuractionItem(o2, ok.VIDEO, "auxiliary"));
          }), this._eventMap.forEach((e2, t2) => ew.on(t2, e2, this));
        }
        uninstallEvents() {
          this._eventMap.forEach((e2, t2) => ew.off(t2, e2, this)), this._eventMap.clear();
        }
        handleSubscribed(e2) {
          let { room: t2, streamType: i2, remotePublishedUser: r2 } = e2;
          if (!this.hitTest(t2))
            return;
          let { userId: n2 } = r2, o2 = "".concat(n2, "_").concat(i2);
          if (r2.muteState.hasAudio && "main" === i2)
            if (r2.remoteAudioTrack.isSubscribed) {
              let e3 = new pU(), t3 = this._durationMap.get(o2);
              t3 ? this.isRecording(t3.audio) || t3.audio.push(e3) : this._durationMap.set(o2, { userId: n2, type: i2, audio: [e3], video: [] });
            } else
              this.stopDurationItem(o2, ok.AUDIO);
          if (r2.muteState.hasVideo || r2.muteState.hasAuxiliary)
            if (r2.remoteVideoTrack.isSubscribed || r2.remoteAuxiliaryTrack.isSubscribed) {
              let e3 = new pU(), t3 = this._durationMap.get(o2);
              t3 ? this.isRecording(t3.video) || t3.video.push(e3) : this._durationMap.set(o2, { userId: n2, type: i2, audio: [], video: [e3] });
            } else
              this.stopDurationItem(o2, ok.VIDEO);
        }
        handleStreamStopped(e2) {
          let { room: t2, streamType: i2, remotePublishedUser: r2 } = e2;
          if (!this.hitTest(t2))
            return;
          let { userId: n2 } = r2, o2 = "".concat(n2, "_").concat(i2);
          this.stopDurationItem(o2, ok.AUDIO), this.stopDurationItem(o2, ok.VIDEO);
        }
        isRecording(e2) {
          return e2.findIndex((e3) => 0 === e3.endTime) >= 0;
        }
        addDuractionItem(e2, t2, i2) {
          let r2 = "".concat(e2, "_").concat(i2), n2 = new pU(), o2 = this._durationMap.get(r2);
          o2 ? this.isRecording(o2[t2]) || o2[t2].push(n2) : this._durationMap.set(r2, { userId: e2, type: i2, audio: t2 === ok.AUDIO ? [n2] : [], video: t2 === ok.AUDIO ? [] : [n2] });
        }
        stopDurationItem(e2, t2) {
          if (this._durationMap.has(e2)) {
            let i2 = this._durationMap.get(e2)[t2].find((e3) => 0 === e3.endTime);
            i2 && i2.stop();
          }
        }
        hitTest(e2) {
          return this._room === e2;
        }
        getDuration(e2, t2) {
          return this._durationMap.has(e2) ? this._durationMap.get(e2)[t2].reduce((e3, t3) => e3 + t3.getDuration(), 0) : 0;
        }
        getDurationMap() {
          return this._durationMap;
        }
        reset() {
          this._durationMap.clear();
        }
        destroy() {
          this._room = null, this.uninstallEvents();
        }
      }, _U = class {
        constructor(e2) {
          sb(this, "_room"), sb(this, "_renderFreezeMap", /* @__PURE__ */ new Map()), sb(this, "_isVideoPlayingEventFiredMap", /* @__PURE__ */ new Map()), sb(this, "_dataFreezeMap", /* @__PURE__ */ new Map()), sb(this, "_monitorFreezeData", /* @__PURE__ */ new Map()), sb(this, "_eventMap", /* @__PURE__ */ new Map()), this._room = e2.room, this.installEvents();
        }
        installEvents() {
          this._eventMap.set(gO.LEAVE_SUCCESS, (e2) => {
            let { room: t2 } = e2;
            this.hitTest(t2) && this.stop();
          }).set(gO.PLAY_TRACK_START, this.onPlayTrackStart).set(gO.UNSUBSCRIBE_SUCCESS, (e2) => {
            let { room: t2, streamType: i2, remotePublishedUser: r2 } = e2;
            if (!this.hitTest(t2))
              return;
            let { userId: n2 } = r2, o2 = "".concat(n2, "_").concat(i2);
            this.stopDataFreeze({ key: o2, userId: n2, type: i2 });
          }).set(gO.REMOTE_PUBLISH_STATE_CHANGED, (e2) => {
            let { room: t2, prevMuteState: i2, muteState: r2 } = e2;
            if (!this.hitTest(t2))
              return;
            let { userId: n2 } = r2;
            if (i2.hasVideo && !r2.hasVideo) {
              let e3 = "main", t3 = "".concat(r2.userId, "_").concat(e3);
              this.stopDataFreeze({ key: t3, userId: n2, type: e3 });
            }
            if (i2.hasAuxiliary && !r2.hasAuxiliary) {
              let e3 = "auxiliary", t3 = "".concat(r2.userId, "_").concat(e3);
              this.stopDataFreeze({ key: t3, userId: n2, type: e3 });
            }
          }).set(gO.PLAYER_STATE_CHANGED, (e2) => {
            let { track: t2, state: i2, reason: r2, type: n2 } = e2;
            if (Hw(t2) && this.hitTest(t2.room) && n2 === ok.VIDEO) {
              if ("PLAYING" === i2) {
                let e3 = "".concat(t2.userId, "_").concat(t2.streamType);
                this._isVideoPlayingEventFiredMap.set(e3, true);
              }
              r2 === ok.MUTE ? this.onVideoTrackMuted(t2) : r2 === ok.UNMUTE && this.onVideoTrackUnmuted(t2);
            }
          }).set(gO.HEARTBEAT_REPORT, this.onHearBeatReport), this._eventMap.forEach((e2, t2) => ew.on(t2, e2, this));
        }
        uninstallEvents() {
          this._eventMap.forEach((e2, t2) => ew.off(t2, e2, this)), this._eventMap.clear();
        }
        stop() {
          this._renderFreezeMap.clear(), this._dataFreezeMap.clear(), this._isVideoPlayingEventFiredMap.clear();
        }
        onVideoTrackMuted(e2) {
          if (!e2.isSubscribed)
            return;
          let { userId: t2, streamType: i2 } = e2, r2 = "".concat(t2, "_").concat(i2), n2 = this._dataFreezeMap.get(r2), o2 = new pU();
          n2 ? n2.durationItemList.push(o2) : this._dataFreezeMap.set(r2, { userId: t2, type: i2, durationItemList: [o2], isFreezing() {
            let e3 = this.durationItemList[this.durationItemList.length - 1];
            return e3 && 0 === e3.endTime;
          } });
        }
        onVideoTrackUnmuted(e2) {
          if (!e2.isSubscribed)
            return;
          let { userId: t2, streamType: i2 } = e2, r2 = "".concat(t2, "_").concat(i2);
          this.stopDataFreeze({ key: r2, userId: t2, type: i2 });
        }
        onHearBeatReport(e2) {
          let { room: t2, report: i2 } = e2;
          !this.hitTest(t2) || i2.msg_down_stream_info.forEach((e3) => {
            let t3 = this._room.remotePublishedUserMap.get(e3.msg_user_info.str_identifier);
            if (!t3)
              return;
            let { userId: i3, muteState: r2 } = t3;
            e3.msg_video_status.forEach((e4) => {
              2 === e4.uint32_video_stream_type && r2.hasVideo && !r2.videoMuted && t3.remoteVideoTrack.isSubscribed && this.handleRenderFreeze({ userId: i3, fps: e4.uint32_video_dec_fps, type: "main" }), 7 === e4.uint32_video_stream_type && r2.hasAuxiliary && t3.remoteAuxiliaryTrack.isSubscribed && this.handleRenderFreeze({ userId: i3, fps: e4.uint32_video_dec_fps, type: "auxiliary" });
            });
          });
        }
        stopDataFreeze(e2) {
          let { key: t2, userId: i2, type: r2 } = e2, n2 = this._dataFreezeMap.get(t2);
          if (!n2 || !n2.isFreezing())
            return;
          let o2 = n2.durationItemList[n2.durationItemList.length - 1];
          o2.stop();
          let s2 = o2.getDuration();
          s2 > Hk ? this._monitorFreezeData.set(t2, { userId: i2, type: r2, duration: s2 }) : n2.durationItemList.pop();
        }
        getTotalDuration(e2) {
          return e2.reduce((e3, t2) => {
            let i2 = t2.getDuration();
            return e3 + Math.min(i2, 5e3);
          }, 0);
        }
        handleRenderFreeze(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { userId: i2, fps: r2, type: n2 } = e3;
            return function* () {
              let e4 = "".concat(i2, "_").concat(n2), o2 = t2._renderFreezeMap.get(e4);
              if (r2 <= 2) {
                let r3 = zw();
                o2 && !o2.isFreeze && (o2.freezeTimeline.push({ startTime: r3, endTime: 0 }), o2.isFreeze = true), o2 || t2._renderFreezeMap.set(e4, { userId: i2, type: n2, isFreeze: true, freezeTimeline: [{ startTime: r3, endTime: 0 }], renderFreezeTotal: 0 });
              } else if (o2 && o2.isFreeze) {
                o2.isFreeze = false;
                let e5 = o2.freezeTimeline.pop();
                if (e5) {
                  e5.endTime = zw();
                  let t3 = e5.endTime - e5.startTime;
                  o2.freezeTimeline.push(e5), o2.renderFreezeTotal += Math.min(5e3, t3);
                }
              }
            }();
          });
        }
        onPlayTrackStart(e2) {
          let { track: t2 } = e2;
          if (!Hw(t2) || !this.hitTest(t2.room) || t2.kind !== ok.VIDEO || t2.hasFlag)
            return;
          let i2 = "".concat(t2.userId, "_").concat(t2.streamType);
          this._isVideoPlayingEventFiredMap.has(i2) || this._isVideoPlayingEventFiredMap.set(i2, false);
        }
        getDataFreezeDuration(e2) {
          let t2 = { dataFreeze: 0, count: 0 }, i2 = this._dataFreezeMap.get(e2);
          if (i2) {
            if (i2.isFreezing()) {
              let e3 = i2.durationItemList[i2.durationItemList.length - 1];
              e3.stop(), e3.getDuration() < Hk && i2.durationItemList.pop();
            }
            t2.dataFreeze = this.getTotalDuration(i2.durationItemList), t2.count = i2.durationItemList.length;
          }
          return t2;
        }
        getRenderFreezeDuration(e2) {
          let t2 = this._renderFreezeMap.get(e2), i2 = 0, r2 = 0;
          if (t2)
            if (t2.isFreeze) {
              let e3 = zw() - t2.freezeTimeline[t2.freezeTimeline.length - 1].startTime;
              i2 = t2.renderFreezeTotal + Math.min(e3, 5e3), r2 = t2.freezeTimeline.length;
            } else
              i2 = t2.renderFreezeTotal;
          return { renderFreeze: i2, count: r2 };
        }
        getMonitorFreeze() {
          return this._monitorFreezeData;
        }
        isBlackStream(e2) {
          return !!this._isVideoPlayingEventFiredMap.has(e2) && !this._isVideoPlayingEventFiredMap.get(e2);
        }
        resetMonitor() {
          this._monitorFreezeData.clear();
        }
        hitTest(e2) {
          return e2 === this._room;
        }
        destroy() {
          this.uninstallEvents();
        }
      }, fU = nb(lb(), 1), gU = [-1, -1, 1, -1, -1, 1, 1, 1], TU = [0, 0, 1, 0, 0, 1, 1, 1], EU = class extends TP {
        constructor(e2, t2) {
          if (super(), this.context = e2, sb(this, "name"), sb(this, "input"), sb(this, "output"), sb(this, "texture"), sb(this, "image"), sb(this, "ctx2d", null), sb(this, "fbo"), sb(this, "width", 0), sb(this, "height", 0), sb(this, "x", 0), sb(this, "y", 0), sb(this, "program"), sb(this, "vertexShader"), sb(this, "fragmentShader"), sb(this, "totalFrames", 0), sb(this, "dropFrames", 0), sb(this, "matchInputSize", true), sb(this, "texCoordBuffer"), sb(this, "positionBuffer"), sb(this, "lastInfo", { name: "", timestamp: 0, totalFrames: 0, x: 0, y: 0, width: 0, height: 0, fps: 0 }), sb(this, "cost", 0), sb(this, "_canvas", null), this.context.on("disconnect", this.close, this), this.name = t2.name, this.matchInputSize = false !== t2.matchInputSize, this.width = t2.width || e2.width, this.height = t2.height || e2.height, e2 instanceof DU) {
            if (e2.ctx && t2.create2d) {
              let e3 = document.createElement("canvas"), t3 = "function" == typeof e3.transferControlToOffscreen ? e3.transferControlToOffscreen() : e3;
              t3.width = this.width, t3.height = this.height, this.ctx2d = t3.getContext("2d"), this.image = t3, this._canvas = t3;
            }
          } else
            try {
              let i2 = e2.ctx;
              this.texCoordBuffer = this.createBuffer(TU), this.positionBuffer = this.createBuffer(gU), false !== t2.createTexture && (this.texture = i2.createTexture(), this.useTexture(), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, i2.LINEAR), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, i2.LINEAR), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, i2.CLAMP_TO_EDGE), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, i2.CLAMP_TO_EDGE), i2.pixelStorei(i2.PACK_ALIGNMENT, 1), i2.pixelStorei(i2.UNPACK_ALIGNMENT, 1)), t2.useFbo && (this.fbo = i2.createFramebuffer(), this.useBufferFrame(), this.useTexture(), i2.texImage2D(i2.TEXTURE_2D, 0, i2.RGBA, this.width, this.height, 0, i2.RGBA, i2.UNSIGNED_BYTE, null), i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, this.texture, 0)), t2.useDefaultProgram ? this.program = e2.defaultProgam : (t2.vertexShaderSource || t2.fragmentShaderSource) && (this.vertexShader = t2.vertexShaderSource ? e2.createShader(i2.VERTEX_SHADER, t2.vertexShaderSource) : e2.defaultVShader, this.fragmentShader = t2.fragmentShaderSource ? e2.createShader(i2.FRAGMENT_SHADER, t2.fragmentShaderSource) : e2.defaultFShader, this.program = e2.createProgram(this.vertexShader, this.fragmentShader));
            } catch (Ob2) {
              this.context.destroy(Ob2);
            }
        }
        createFramebuffer(e2) {
          let t2 = this.context.ctx, i2 = t2.createFramebuffer();
          return t2.bindFramebuffer(t2.FRAMEBUFFER, i2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), i2;
        }
        connect(e2) {
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
            i2[r2 - 1] = arguments[r2];
          return e2.addInput(this, ...i2), this.output = e2, e2;
        }
        addInput(e2) {
          this.input = e2, this.matchInputSize && e2.width && e2.height && this.resize(e2.width, e2.height);
        }
        requestFrame(e2) {
          let t2 = Date.now();
          return !!(this.context instanceof NU && this.render(e2) || this.context instanceof DU && this.render2d(e2)) && (this.totalFrames++, this.cost = Date.now() - t2, true);
        }
        render2d(e2) {
          var t2;
          return !(null == (t2 = this.input) || !t2.requestFrame(e2)) && this.draw2d(this.input.image, 0, 0, this.width, this.height);
        }
        disconnect() {
          for (var e2, t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
            i2[r2] = arguments[r2];
          null == (e2 = this.output) || e2.removeInput(this, ...i2), delete this.output;
        }
        removeInput(e2) {
          delete this.input;
        }
        close() {
          var e2, t2;
          if (this.context.off("disconnect", this.close, this), null == (e2 = this.output) || e2.removeInput(this), delete this.output, null == (t2 = this.input) || t2.disconnect(), this.context instanceof NU) {
            let e3 = this.context.ctx;
            e3.deleteBuffer(this.texCoordBuffer), e3.deleteBuffer(this.positionBuffer), this.fbo && e3.deleteFramebuffer(this.fbo), this.texture && e3.deleteTexture(this.texture), this.vertexShader && this.vertexShader !== this.context.defaultVShader && e3.deleteShader(this.vertexShader), this.fragmentShader && this.fragmentShader !== this.context.defaultFShader && e3.deleteShader(this.fragmentShader), this.program && this.program !== this.context.defaultProgam && e3.deleteProgram(this.program);
          }
          this._canvas && (this._canvas.width = 0, this._canvas.height = 0, this.ctx2d = null), this.removeAllListeners();
        }
        useTexture() {
          this.useTextures(this.texture);
        }
        useInputTexture() {
          var e2;
          this.useTextures(null == (e2 = this.input) ? void 0 : e2.texture);
        }
        useTextures() {
          let e2 = this.context.ctx;
          for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
            i2[r2] = arguments[r2];
          i2.forEach((t3, i3) => {
            t3 && (e2.activeTexture(e2.TEXTURE0 + i3), e2.bindTexture(e2.TEXTURE_2D, t3));
          });
        }
        useProgram() {
          this.context.ctx.useProgram(this.program);
        }
        useBufferFrame() {
          let e2 = this.context.ctx;
          e2.bindFramebuffer(e2.FRAMEBUFFER, this.fbo || null);
        }
        createBuffer(e2) {
          let t2 = this.context.ctx, i2 = t2.createBuffer();
          return t2.bindBuffer(t2.ARRAY_BUFFER, i2), t2.bufferData(t2.ARRAY_BUFFER, new Float32Array(e2), t2.STATIC_DRAW), i2;
        }
        setTexBuffer(e2) {
          let t2 = this.context.ctx;
          t2.bindBuffer(t2.ARRAY_BUFFER, this.texCoordBuffer), t2.bufferData(t2.ARRAY_BUFFER, new Float32Array(e2), t2.STATIC_DRAW);
        }
        setPosBuffer(e2) {
          let t2 = this.context.ctx;
          t2.bindBuffer(t2.ARRAY_BUFFER, this.positionBuffer), t2.bufferData(t2.ARRAY_BUFFER, new Float32Array(e2), t2.STATIC_DRAW);
        }
        changeBufferData(e2, t2) {
          let i2 = this.context.ctx;
          i2.bindBuffer(i2.ARRAY_BUFFER, e2), i2.bufferData(i2.ARRAY_BUFFER, new Float32Array(t2), i2.STATIC_DRAW);
        }
        setAttributes() {
          let e2 = this.context.ctx;
          for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
            i2[r2] = arguments[r2];
          i2.forEach((t3, i3) => {
            e2.enableVertexAttribArray(i3), e2.bindBuffer(e2.ARRAY_BUFFER, t3), e2.vertexAttribPointer(i3, 2, e2.FLOAT, false, 0, 0);
          });
        }
        getVertexPoint(e2, t2) {
          return [e2 / this.width * 2 - 1, t2 / this.height * 2 - 1];
        }
        layout2texCoords(e2) {
          return [...this.getVertexPoint(e2.x, e2.y), ...this.getVertexPoint(e2.x + e2.width, e2.y), ...this.getVertexPoint(e2.x, e2.y + e2.height), ...this.getVertexPoint(e2.x + e2.width, e2.y + e2.height)];
        }
        resize(e2, t2) {
          if (this.width !== e2 || this.height !== t2) {
            if (this.width = e2, this.height = t2, this._canvas && (this._canvas.width = e2, this._canvas.height = t2), this.texture && this.fbo) {
              this.useTexture();
              let i2 = this.context.ctx;
              i2.texImage2D(i2.TEXTURE_2D, 0, i2.RGBA, e2, t2, 0, i2.RGBA, i2.UNSIGNED_BYTE, null);
            }
            this.output && this.output.matchInputSize && this.output.resize(e2, t2);
          }
        }
        draw(e2, t2) {
          this.setAttributes(e2 || this.positionBuffer, t2 || this.texCoordBuffer);
          let i2 = this.context.ctx;
          i2.drawArrays(i2.TRIANGLE_STRIP, 0, 4);
        }
        draw2d(e2, t2, i2, r2, n2) {
          return !(!this.ctx2d || !e2) && (e2 instanceof ImageData ? this.ctx2d.putImageData(e2, t2, i2) : this.ctx2d.drawImage(e2, t2, i2, r2, n2), true);
        }
        getInfo() {
          var e2;
          let { totalFrames: t2, x: i2, y: r2, width: n2, height: o2, name: s2, cost: a2 } = this, c2 = Date.now(), l2 = (t2 - this.lastInfo.totalFrames) / ((c2 - this.lastInfo.timestamp) / 1e3) | 0;
          return this.lastInfo = { totalFrames: t2, x: i2, y: r2, width: n2, height: o2, timestamp: c2, fps: l2, name: s2, cost: a2 }, eb({ parent: null == (e2 = this.input) ? void 0 : e2.getInfo() }, this.lastInfo);
        }
        createTexture(e2) {
          let t2 = this.context.ctx, i2 = t2.createTexture();
          return this.useTextures(i2), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MIN_FILTER, t2.LINEAR), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_MAG_FILTER, t2.LINEAR), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_S, t2.CLAMP_TO_EDGE), t2.texParameteri(t2.TEXTURE_2D, t2.TEXTURE_WRAP_T, t2.CLAMP_TO_EDGE), t2.pixelStorei(t2.PACK_ALIGNMENT, 1), t2.pixelStorei(t2.UNPACK_ALIGNMENT, 1), t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, e2), i2;
        }
      };
      ob([_P(TP.INIT, "connected", { sync: true })], EU.prototype, "connect", 1), ob([_P("connected", TP.INIT, { ignoreError: true, sync: true })], EU.prototype, "disconnect", 1), ob([_P([], "closed", { sync: true })], EU.prototype, "close", 1);
      var SU = [0, 1, 1, 1, 0, 0, 1, 0], IU = class extends EU {
        constructor(e2, t2) {
          super(e2, Object.assign({ useDefaultProgram: true, createTexture: false, name: "destination" }, t2)), sb(this, "_intervalId", 0), sb(this, "_sequence", 0), sb(this, "checkGLError", false), e2 instanceof DU ? this.ctx2d = e2.ctx : e2.available && (null == t2 ? void 0 : t2.mirrorUpAndDown) && this.setTexBuffer(SU);
        }
        start(e2) {
          this._intervalId = yP.run("intervalInWorker", () => {
            if (e2 !== this.context.frameRate && (yP.clearTask(this._intervalId), this.start(this.context.frameRate)), this.requestFrame(this._sequence++), this.checkGLError && this.context instanceof NU) {
              let e3 = this.context.ctx.getError();
              e3 && this.context.destroy(new Error("".concat(this.name, " req ").concat(this._sequence, " render ").concat(this.totalFrames, " faild ").concat(e3)));
            }
          }, { fps: this.context.frameRate });
        }
        render(e2) {
          var t2;
          return !(null == (t2 = this.input) || !t2.requestFrame(e2)) && (this.useProgram(), this.useBufferFrame(), this.useInputTexture(), this.draw(), true);
        }
        addInput(e2) {
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
            i2[r2 - 1] = arguments[r2];
          super.addInput(e2, ...i2), this.start(this.context.frameRate);
        }
        removeInput(e2) {
          super.removeInput(e2), yP.clearTask(this._intervalId);
        }
        resize(e2, t2) {
          super.resize(e2, t2), this.context.setSize(e2, t2);
        }
      }, vU = class extends IU {
        constructor(e2, t2) {
          super(e2, t2), sb(this, "_videoTrack"), [this._videoTrack] = e2._canvas.captureStream(e2.frameRate).getVideoTracks();
          let i2 = (e3) => {
            var t3;
            let i3 = () => {
              var t4;
              return null == (t4 = this._videoTrack) ? void 0 : t4.removeEventListener(e3, r2);
            }, r2 = () => {
              i3(), this.context.destroy(new Error("video track ".concat(e3)));
            };
            this.once("closed", i3), null == (t3 = this._videoTrack) || t3.addEventListener(e3, r2);
          };
          e2 instanceof NU && i2("mute"), i2("ended");
        }
        get videoTrack() {
          return this._videoTrack;
        }
        close() {
          var e2;
          super.close(), null == (e2 = this._videoTrack) || e2.stop(), delete this._videoTrack;
        }
      }, yU = class extends vU {
        render(e2) {
          var t2;
          return !(null == (t2 = this.input) || !t2.requestFrame(e2));
        }
      }, AU = class extends vU {
        constructor(e2, t2) {
          super(e2, { name: "smallDestination" }), this.resolution = t2;
        }
        resize(e2, t2) {
          let i2, r2 = e2 * t2, n2 = this.resolution.width * this.resolution.height;
          EO.info("big res: ".concat(e2, "*").concat(t2, " small res: ").concat(this.resolution.width, "*").concat(this.resolution.height, " ")), r2 > n2 ? i2 = r2 / n2 : (EO.warn("Small stream resolution is not smaller than big stream, which is invalid. big: ".concat(e2, " * ").concat(t2, " small: ").concat(this.resolution.width, " * ").concat(this.resolution.height)), i2 = r2 / 19200), super.resize(e2 / Math.sqrt(i2), t2 / Math.sqrt(i2));
        }
      }, RU = class extends EU {
        constructor(e2, t2, i2) {
          super(e2, eb({ name: "imageSource" }, i2)), this.image = t2, sb(this, "_image"), sb(this, "_totalFrames", 0), sb(this, "_autoResize", false), this._autoResize = false !== (null == i2 ? void 0 : i2.autoResize);
        }
        _render(e2, t2) {
          let { width: i2, height: r2 } = this;
          if (this.image instanceof HTMLVideoElement) {
            if (Pw(this.image.getVideoPlaybackQuality) && !DD) {
              let e3 = this.image.getVideoPlaybackQuality().totalVideoFrames;
              if (this._totalFrames === e3)
                return false;
              this._totalFrames = e3, this.dropFrames = this._totalFrames - this.totalFrames;
            }
            if ({ videoWidth: i2, videoHeight: r2 } = this.image, !i2 || !r2)
              return false;
            this.image.width = i2, this.image.height = r2;
          } else if (this.image instanceof HTMLImageElement || this.image instanceof ImageData || this.image instanceof ImageBitmap) {
            if ({ width: i2, height: r2 } = this.image, this.image !== this._image)
              this._image = this.image;
            else if (i2 === this.width && r2 === this.height)
              return false;
          } else
            (this.image instanceof HTMLCanvasElement || this.image instanceof OffscreenCanvas) && ({ width: i2, height: r2 } = this.image, this._image = this.image);
          if (!this._autoResize)
            return true;
          if (this.width === i2 && this.height === r2 && this.totalFrames) {
            if (t2) {
              this.useTexture();
              let e3 = this.context.ctx;
              e3.texSubImage2D(e3.TEXTURE_2D, 0, 0, 0, e3.RGBA, e3.UNSIGNED_BYTE, this.image);
            }
          } else {
            if (t2) {
              this.useTexture();
              let e3 = this.context.ctx;
              e3.texImage2D(e3.TEXTURE_2D, 0, e3.RGBA, e3.RGBA, e3.UNSIGNED_BYTE, this.image);
            }
            this.resize(i2, r2);
          }
          return true;
        }
        render(e2) {
          return this._render(e2, true);
        }
        render2d(e2) {
          return this._render(e2, false);
        }
      }, CU = class extends RU {
        constructor(e2, t2, i2) {
          let r2 = document.createElement("video");
          r2.setAttribute("playsinline", "playsinline"), r2.setAttribute("muted", ""), super(e2, r2, i2), this._videoTrack = t2, sb(this, "_mediaStream"), this.name = "videoTrackSource", this._mediaStream = new MediaStream([t2]), this.image.srcObject = this._mediaStream, this.image.play();
        }
        replaceTrack(e2) {
          var t2, i2;
          this._videoTrack !== e2 && (null == (t2 = this._mediaStream) || t2.removeTrack(this._videoTrack), this._videoTrack = e2, null == (i2 = this._mediaStream) || i2.addTrack(this._videoTrack), this.image.play());
        }
        close() {
          var e2;
          super.close(), null == (e2 = this._mediaStream) || e2.removeTrack(this._videoTrack), delete this._mediaStream, this.image.srcObject = null;
        }
      }, bU = class extends TP {
        constructor(e2) {
          super(), sb(this, "frameRate"), sb(this, "_canvas"), sb(this, "log"), sb(this, "hasAlpha", false), sb(this, "name"), this.name = e2.name, this.log = e2.logger.createChild({ id: "vc-".concat(this.name) }), this.frameRate = e2.frameRate;
        }
        set width(e2) {
          this._canvas && (this._canvas.width = e2);
        }
        get width() {
          var e2;
          return (null == (e2 = this._canvas) ? void 0 : e2.width) || 0;
        }
        set height(e2) {
          this._canvas && (this._canvas.height = e2);
        }
        get height() {
          var e2;
          return (null == (e2 = this._canvas) ? void 0 : e2.height) || 0;
        }
        setSize(e2, t2) {
          this._canvas && (this._canvas.width = e2, this._canvas.height = t2);
        }
        createVideoTrackSource(e2) {
          return new CU(this, e2);
        }
        createVideoTrackDestination(e2) {
          return new vU(this, e2);
        }
        createVideoImageSource(e2, t2) {
          return new RU(this, e2, t2);
        }
        get available() {
          return "created" === this.state;
        }
        disconnect() {
          this.emit("disconnect");
        }
      }, kU = { alpha: true, antialias: false, premultipliedAlpha: false, preserveDrawingBuffer: false, depth: false, stencil: false, failIfMajorPerformanceCaveat: true, powerPreference: "low-power" }, NU = class extends bU {
        constructor() {
          super(...arguments), sb(this, "defaultProgam"), sb(this, "defaultVShader"), sb(this, "defaultFShader"), sb(this, "ctx");
        }
        create() {
          if (this._canvas || (this._canvas = document.createElement("canvas")), this.ctx = this._canvas.getContext("webgl2", kU), !this.ctx)
            throw new Error("webgl2 not supported");
          this.defaultVShader = this.createShader(this.ctx.VERTEX_SHADER, "\n// é¡¶ç¹çè²å¨\nattribute vec4 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  gl_Position = a_position;\n  v_texCoord = a_texCoord;\n}\n"), this.defaultFShader = this.createShader(this.ctx.FRAGMENT_SHADER, "\n// çåçè²å¨\nprecision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\n\nvoid main() {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n} "), this.defaultProgam = this.createProgram(this.defaultVShader, this.defaultFShader), this._canvas.addEventListener("webglcontextlost", () => {
            this.destroy(new Error("webgl context lost"));
          }), this.log.info("video context created use webgl");
        }
        destroy(e2) {
          return this.disconnect(), this.log.info("video context destroy ".concat(e2 ? ": ".concat(e2) : "")), this.ctx && (this.ctx.deleteShader(this.defaultVShader), this.ctx.deleteShader(this.defaultFShader), this.ctx.deleteProgram(this.defaultProgam), delete this.ctx), e2;
        }
        set width(e2) {
          var t2;
          null == (t2 = this.ctx) || t2.viewport(0, 0, e2, this.height), super.width = e2;
        }
        set height(e2) {
          var t2;
          null == (t2 = this.ctx) || t2.viewport(0, 0, this.width, e2), super.height = e2;
        }
        setSize(e2, t2) {
          var i2;
          null == (i2 = this.ctx) || i2.viewport(0, 0, e2, t2), super.setSize(e2, t2);
        }
        createShader(e2, t2) {
          let i2 = this.ctx, r2 = i2.createShader(e2);
          return i2.shaderSource(r2, t2), i2.compileShader(r2), r2;
        }
        createProgram(e2, t2) {
          let i2 = this.ctx, r2 = i2.createProgram();
          return i2.attachShader(r2, e2), i2.attachShader(r2, t2), i2.linkProgram(r2), i2.getProgramParameter(r2, i2.LINK_STATUS) || this.log.error(i2.getProgramInfoLog(r2)), r2;
        }
      };
      ob([_P(TP.INIT, "created", { sync: true })], NU.prototype, "create", 1), ob([_P("created", TP.INIT, { ignoreError: true, sync: true, success(e2) {
        e2 && this.emit("unavailable", e2), this.removeAllListeners();
      } })], NU.prototype, "destroy", 1);
      var DU = class extends bU {
        constructor() {
          super(...arguments), sb(this, "ctx");
        }
        create(e2) {
          if (this.hasAlpha = e2.alpha, this._canvas = document.createElement("canvas"), this.ctx = this._canvas.getContext("2d", { alpha: e2.alpha }), !this.ctx)
            throw new Error("2d context not supported");
          this.log.info("video context created use 2d");
        }
        destroy(e2) {
          this.disconnect(), this.log.info("video context destroy ".concat(e2 ? ": ".concat(e2) : "")), delete this.ctx, this._canvas && (this._canvas.remove(), this._canvas.width = 0, this._canvas.height = 0, delete this._canvas), this.removeAllListeners();
        }
      };
      ob([_P(TP.INIT, "created", { sync: true })], DU.prototype, "create", 1), ob([_P("created", TP.INIT, { ignoreError: true, sync: true })], DU.prototype, "destroy", 1);
      var wU = [1, 0, 0, 0, 1, 1, 0, 1], OU = class extends EU {
        constructor(e2) {
          if (super(e2, { useDefaultProgram: true, useFbo: true, create2d: true, name: "mirror" }), e2 instanceof NU)
            try {
              this.setTexBuffer(wU);
            } catch (wb2) {
              e2.destroy(wb2);
            }
        }
        draw2d(e2, t2, i2, r2, n2) {
          if (this.ctx2d) {
            this.ctx2d.save(), this.ctx2d.scale(-1, 1), this.ctx2d.translate(-this.width, 0);
            let o2 = super.draw2d(e2, t2, i2, r2, n2);
            return this.ctx2d.restore(), o2;
          }
          return false;
        }
        render(e2) {
          var t2;
          return !(null == (t2 = this.input) || !t2.requestFrame(e2)) && (this.useProgram(), this.useBufferFrame(), this.useInputTexture(), this.draw(), true);
        }
      }, PU = class {
        constructor(e2, t2) {
          this.node = e2, this.layout = t2, sb(this, "positionBuffer");
        }
        get x() {
          return this.layout.x || this.node.x;
        }
        get y() {
          return this.layout.y || this.node.y;
        }
        get width() {
          return this.layout.width || this.node.width;
        }
        get height() {
          return this.layout.height || this.node.height;
        }
        get right() {
          return this.x + this.width;
        }
        get bottom() {
          return this.y + this.height;
        }
      }, MU = class extends EU {
        constructor(e2) {
          super(e2, { useDefaultProgram: true, useFbo: true, name: "mix", create2d: true }), sb(this, "inputs", []);
        }
        addInput(e2, t2) {
          if (this.inputs[t2.zIndex])
            throw new Error("input already exists");
          let i2 = new PU(e2, t2);
          this.inputs[t2.zIndex] = i2;
        }
        resize(e2, t2) {
          let i2 = this.inputs.reduce((e3, t3) => t3 ? Object.assign(e3, { width: Math.max(e3.width, t3.right), height: Math.max(e3.height, t3.bottom) }) : e3, { width: 0, height: 0 });
          super.resize(i2.width, i2.height), this.context instanceof NU && this.inputs.forEach((e3) => {
            if (e3) {
              let t3 = this.layout2texCoords(e3);
              e3.positionBuffer ? this.changeBufferData(e3.positionBuffer, t3) : e3.positionBuffer = this.createBuffer(t3);
            }
          });
        }
        connect(e2) {
          for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++)
            i2[r2 - 1] = arguments[r2];
          return super.connect(e2, ...i2), this.resize(0, 0), e2;
        }
        removeInput(e2) {
          this.inputs[this.inputs.findIndex((t2) => (null == t2 ? void 0 : t2.node) === e2)] = void 0;
        }
        render(e2) {
          let t2 = this.context.ctx;
          if (t2.clearColor(0, 0, 0, 0), !this.inputs.reduce((t3, i2) => (!i2 || !i2.node.requestFrame(e2)) && t3, true) && t2) {
            this.useProgram(), t2.enable(t2.BLEND), t2.blendFunc(t2.SRC_ALPHA, t2.ONE_MINUS_SRC_ALPHA), this.useBufferFrame();
            for (let e3 = 0; e3 < this.inputs.length; e3++) {
              let t3 = this.inputs[e3];
              t3 && (t3.node.useTexture(), this.draw(t3.positionBuffer));
            }
            return true;
          }
          return false;
        }
        render2d(e2) {
          if (!this.inputs.reduce((t2, i2) => (!i2 || !i2.node.requestFrame(e2)) && t2, true) && this.ctx2d) {
            this.ctx2d.clearRect(0, 0, this.width, this.height);
            for (let e3 = 0; e3 < this.inputs.length; e3++) {
              let t2 = this.inputs[e3];
              t2 && this.draw2d(t2.node.image, t2.x, t2.y, t2.width, t2.height);
            }
            return true;
          }
          return false;
        }
        getInfo() {
          let { totalFrames: e2, x: t2, y: i2, width: r2, height: n2, name: o2 } = this, s2 = Date.now(), a2 = (e2 - this.lastInfo.totalFrames) / ((s2 - this.lastInfo.timestamp) / 1e3) | 0;
          return this.lastInfo = { totalFrames: e2, x: t2, y: i2, width: r2, height: n2, timestamp: s2, fps: a2, name: o2 }, eb({ parent: this.inputs.filter((e3) => e3).map((e3) => e3.node.getInfo()) }, this.lastInfo);
        }
        close() {
          super.close(), this.inputs.forEach((e2) => {
            var t2, i2;
            if (e2 && (null == (t2 = e2.node) || t2.disconnect(), e2.positionBuffer && this.context instanceof NU))
              try {
                null == (i2 = this.context.ctx) || i2.deleteBuffer(e2.positionBuffer);
              } catch (tM2) {
              }
          });
        }
      }, LU = class extends CU {
        constructor(e2, t2) {
          super(e2, t2.input, { name: "vb", create2d: false, useDefaultProgram: false, useFbo: false, createTexture: true }), sb(this, "ready", false), sb(this, "_bgTexture"), sb(this, "_waterMarkTexture"), sb(this, "_lastMaskTexture"), sb(this, "_lastMaskFbo"), sb(this, "_textureValid", false), sb(this, "_selfieTextureValid", false), sb(this, "_selfieSegmentation"), sb(this, "wasm"), sb(this, "_prePrograme"), sb(this, "_segmentationMask"), sb(this, "_weixin", false), this._selfieSegmentation = t2.selfieSegmentation, this._selfieSegmentation.onResults = this.onPredict.bind(this), this.init(t2).catch(() => this.context.destroy(new Error("selfie_segmentation init faild")));
        }
        init(e2) {
          return cb(this, null, function* () {
            let t2 = e2.Wasm, i2 = this.context.ctx;
            if (this.wasm = new t2.AllIn1(i2), this.wasm.blurRadius = e2.blurRadius || 3, this.wasm.mirror = !!e2.mirror, this.wasm.vbMode = "blur" === e2.bg ? 1 : e2.bg instanceof HTMLImageElement ? 2 : "green" === e2.bg ? 3 : 0, e2.waterMark) {
              let { x: t3, y: i3, width: r2, height: n2 } = e2.waterMark;
              this.wasm.setWaterMark(t3, i3, r2, n2);
            }
            if (this.program = this.wasm.init(), this.useProgram(), this.setAttributes(this.positionBuffer, this.texCoordBuffer), i2.uniform1i(i2.getUniformLocation(this.program, "mask"), 1), e2.bg instanceof HTMLImageElement && (i2.uniform1i(i2.getUniformLocation(this.program, "bg"), 2), this._bgTexture = this.createTexture(e2.bg)), e2.waterMark && (i2.uniform1i(i2.getUniformLocation(this.program, "waterMark"), 3), this._waterMarkTexture = this.createTexture(e2.waterMark.image)), i2.uniform1i(i2.getUniformLocation(this.program, "lastMask"), 4), this._weixin) {
              let e3 = this.context.createShader(i2.FRAGMENT_SHADER, "#version 300 es\nprecision highp float;\nuniform sampler2D u_texture;\nuniform sampler2D mask;\n\nin vec2 v_texCoord;\nout vec4 outColor;\nvoid main() {\n  outColor = vec4(texture(u_texture, v_texCoord).rgb, texture(mask, v_texCoord).a);\n}"), t3 = this.context.createShader(i2.VERTEX_SHADER, "#version 300 es\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_texCoord;\nvoid main() {\n  gl_Position = vec4(a_position.x, a_position.y, 0, 1);\n  v_texCoord = a_texCoord;\n}");
              this._prePrograme = this.context.createProgram(t3, e3), i2.useProgram(this._prePrograme), this.setAttributes(this.positionBuffer, this.texCoordBuffer), i2.uniform1i(i2.getUniformLocation(this._prePrograme, "mask"), 1);
            }
            this.ready = true;
          });
        }
        onPredict(e2) {
          let t2 = this.context.ctx;
          this._weixin && (this._lastMaskTexture || (this._lastMaskTexture = this.createTexture(this.image), this._lastMaskFbo = this.createFramebuffer(this._lastMaskTexture))), this.useProgram(), this._weixin ? this.useTexture() : this._selfieSegmentation.bindTexture(), t2.activeTexture(t2.TEXTURE1), this._selfieSegmentation.bindTexture2d(e2), t2.activeTexture(t2.TEXTURE2), t2.bindTexture(t2.TEXTURE_2D, this._bgTexture || null), t2.activeTexture(t2.TEXTURE3), t2.bindTexture(t2.TEXTURE_2D, this._waterMarkTexture || null), this.useBufferFrame(), t2.drawArrays(t2.TRIANGLE_STRIP, 0, 4), this._segmentationMask = e2, this.totalFrames++;
        }
        render(e2) {
          let t2 = this.context.ctx;
          if ("function" == typeof this.image.getVideoPlaybackQuality && !DD) {
            let e3 = this.image.getVideoPlaybackQuality().totalVideoFrames;
            if (this._totalFrames === e3)
              return false;
            this._totalFrames = e3, this.dropFrames = this._totalFrames - this.totalFrames;
          }
          let { videoWidth: i2, videoHeight: r2 } = this.image;
          this.image.width = i2, this.image.height = r2;
          let n2 = false;
          if (this.totalFrames)
            this._weixin ? this.useTexture() : this._selfieSegmentation.bindTexture(), n2 = this._selfieTextureValid, this._selfieTextureValid = true;
          else {
            if (!this.program)
              return false;
            this.useTexture(), n2 = this._textureValid, this._textureValid = true;
          }
          return this.width === i2 && this.height === r2 && n2 ? t2.texSubImage2D(t2.TEXTURE_2D, 0, 0, 0, t2.RGBA, t2.UNSIGNED_BYTE, this.image) : (this.resize(i2, r2), t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, this.image)), this.ready && (this._weixin && (t2.useProgram(this._prePrograme), this.useTexture(), this._segmentationMask && (t2.activeTexture(t2.TEXTURE1), this._selfieSegmentation.bindTexture2d(this._segmentationMask), t2.bindFramebuffer(t2.FRAMEBUFFER, this._lastMaskFbo || null)), t2.drawArrays(t2.TRIANGLE_STRIP, 0, 4), this._selfieSegmentation.bindTexture(), this._segmentationMask ? t2.copyTexSubImage2D(t2.TEXTURE_2D, 0, 0, 0, 0, 0, i2, r2) : t2.copyTexImage2D(t2.TEXTURE_2D, 0, t2.RGBA, 0, 0, i2, r2, 0)), this._selfieSegmentation.send(i2, r2)), this.totalFrames || (t2.activeTexture(t2.TEXTURE2), t2.bindTexture(t2.TEXTURE_2D, this._bgTexture || null), t2.activeTexture(t2.TEXTURE3), t2.bindTexture(t2.TEXTURE_2D, this._waterMarkTexture || null), t2.drawArrays(t2.TRIANGLE_STRIP, 0, 4)), false;
        }
        close() {
          var e2;
          super.close();
          let t2 = this.context.ctx;
          this._bgTexture && t2.deleteTexture(this._bgTexture), this._waterMarkTexture && t2.deleteTexture(this._waterMarkTexture), this._lastMaskTexture && t2.deleteTexture(this._lastMaskTexture), this._lastMaskFbo && t2.deleteFramebuffer(this._lastMaskFbo), this._prePrograme && t2.deleteProgram(this._prePrograme), null == (e2 = this.wasm) || e2.close();
        }
      }, xU = class extends fU.EventEmitter {
        constructor(e2) {
          super(), this.room = e2, sb(this, "videoContext"), sb(this, "_glVideoContext"), sb(this, "_2dVideoContext"), sb(this, "destination"), sb(this, "smallVideoContext"), sb(this, "smallDestination"), sb(this, "smallTrackSource"), sb(this, "smallImageSource"), sb(this, "_isMirror", false), sb(this, "cameraTrack"), sb(this, "cameraNode"), sb(this, "mirrorNode"), sb(this, "mixNode"), sb(this, "screenTrack"), sb(this, "screenNode"), sb(this, "selfModel", false), sb(this, "blurRadius", 3), sb(this, "arTrack"), sb(this, "Wasm"), sb(this, "waterMarkNode"), sb(this, "_waterMarkOption"), sb(this, "watermarkImageList", []), sb(this, "_isMixScreen", false), sb(this, "_virtualBackground"), sb(this, "virtualBackgroundInstance"), sb(this, "isUsingArTrack", false), sb(this, "_bgAssetPath"), sb(this, "log", EO.createLogger({ id: "vm" })), sb(this, "_checkId", 0), sb(this, "_use2d", false), sb(this, "_autoSwitchRenderMode", true), sb(this, "_selfieSegmentation"), e2 && (this.log.setUserId(e2.userId), this.log.setSdkAppId(e2.sdkAppId)), this.smallVideoContext = new DU({ frameRate: 15, logger: this.log, name: "s" }), this.enablePrintDetail();
        }
        get _hasVirtualBg() {
          return !!this._virtualBackground;
        }
        get _hasWaterMark() {
          return this.watermarkImageList.length > 0;
        }
        get renderMode() {
          return this._autoSwitchRenderMode ? "auto" : this._use2d ? "2d" : "webgl";
        }
        set renderMode(e2) {
          if (this._autoSwitchRenderMode = "auto" === e2, this._autoSwitchRenderMode)
            return;
          let t2 = "2d" === e2;
          this._use2d !== t2 && (this._use2d = t2, this.clear(), this.videoContext = this._use2d ? this.get2dVideoContext() : this.getGlVideoContext(), this.update());
        }
        get2dVideoContext() {
          return this._2dVideoContext ? this._2dVideoContext.destroy() : this._2dVideoContext = new DU({ frameRate: 15, logger: this.log, name: "m" }), this._2dVideoContext.create({ alpha: this._hasWaterMark || this._hasVirtualBg }), this.sendCreateResult("videoCtx2d", this._2dVideoContext.ctx ? void 0 : new Error("create 2d context failed")), this._2dVideoContext;
        }
        getGlVideoContext() {
          if (this._glVideoContext) {
            if (this._glVideoContext.available)
              return this._glVideoContext;
          } else
            this._glVideoContext = new NU({ frameRate: 15, logger: this.log, name: "m" });
          try {
            this._glVideoContext.create(), this.sendCreateResult(), this._glVideoContext.on("unavailable", (e2, t2) => {
              this.emit("error", { reason: e2, error: t2 }), this.log.warn("video context unavailable", e2, t2), this.sendCreateResult("videoCtxGl", t2 || new Error(e2)), this.update();
            });
          } catch (wb2) {
            this.emit("error", { reason: "create", error: wb2 }), this.sendCreateResult("videoCtxGl", wb2);
          }
          return this._glVideoContext;
        }
        enablePrintDetail() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2e3;
          this._checkId = yP.run(oN, () => {
            this.destination && this.log.debug(this.destination.getInfo());
          }, { delay: e2 });
        }
        destroy() {
          var e2, t2;
          null == (e2 = this._2dVideoContext) || e2.destroy(), null == (t2 = this._glVideoContext) || t2.destroy(), this.smallVideoContext.destroy(), yP.clearTask(this._checkId);
        }
        get needAlpha() {
          return this._hasWaterMark || this._hasVirtualBg;
        }
        get active() {
          return (DD || this._isMixScreen || this._isMirror || this._hasWaterMark || this._hasVirtualBg) && this.checkOrCreateVideoContext();
        }
        sendCreateResult() {
          let e2 = arguments.length > 1 ? arguments[1] : void 0, t2 = "videoCtxGl" === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "videoCtxGl") ? 512700 : 512701;
          e2 ? mM.addFailedEvent({ key: t2, error: e2 }) : mM.addSuccessEvent({ key: t2 });
        }
        checkOrCreateVideoContext() {
          let e2 = this._use2d;
          if (this._autoSwitchRenderMode && (this._use2d = !this._hasVirtualBg), this.videoContext)
            if (this.videoContext.available) {
              let t2 = !this.videoContext.hasAlpha && this.needAlpha;
              if (this._autoSwitchRenderMode && e2 === this._hasVirtualBg)
                this.clear();
              else {
                if (!t2)
                  return true;
                if (!this._use2d)
                  return true;
                this.clear();
              }
            } else
              this.clear(), this._use2d = true;
          return this.videoContext = this._use2d ? this.get2dVideoContext() : this.getGlVideoContext(), this.videoContext.available;
        }
        get smallTrack() {
          var e2;
          return null == (e2 = this.smallDestination) ? void 0 : e2.videoTrack;
        }
        get hasSmall() {
          return !!this.smallTrack;
        }
        get initialTrack() {
          var e2;
          return null == (e2 = this.cameraTrack) ? void 0 : e2.mediaTrack;
        }
        initVirtualBackground(e2) {
          return this._selfieSegmentation = e2, this._selfieSegmentation.changeModel();
        }
        _setMainOutput(e2) {
          var t2;
          let i2 = this.cameraTrack, { small: r2, settings: n2, player: o2 } = i2;
          r2 ? (this.smallVideoContext.available || (this.smallVideoContext.create({ alpha: false }), this.smallDestination = new AU(this.smallVideoContext, r2)), this.smallVideoContext.frameRate = r2.frameRate, this.smallDestination.resolution = r2, e2 ? (this.smallTrackSource && (this.smallTrackSource.close(), delete this.smallTrackSource), this.smallImageSource ? this.smallImageSource.image = e2 : (this.smallImageSource = this.smallVideoContext.createVideoImageSource(e2), this.smallImageSource.connect(this.smallDestination))) : (this.smallImageSource && (this.smallImageSource.close(), delete this.smallImageSource), this.smallTrackSource ? this.smallTrackSource.replaceTrack(this.initialTrack) : (this.smallTrackSource = this.smallVideoContext.createVideoTrackSource(this.initialTrack), this.smallTrackSource.width = n2.width, this.smallTrackSource.height = n2.height, this.smallTrackSource.connect(this.smallDestination)))) : this.smallVideoContext.available && (this.smallVideoContext.destroy(), delete this.smallDestination, delete this.smallTrackSource, delete this.smallImageSource), DD && o2.setCanvas(e2);
          let s2 = e2 && (null == (t2 = this.destination) ? void 0 : t2.videoTrack) || this.initialTrack;
          return this.isUsingArTrack && this.arTrack && (this.emit("output-track-changed"), s2 = this.arTrack), this._selfieSegmentation && e2 && (this._selfieSegmentation._glName || this._selfieSegmentation.setCanvas(e2)), i2.setOutputMediaStreamTrack(s2);
        }
        update() {
          return cb(this, null, function* () {
            var e2, t2;
            if (!this.cameraTrack || !this.cameraTrack.mediaTrack)
              return;
            if (!this.active)
              return this.cameraNode && this.clear(), this._setMainOutput();
            let { settings: i2, profile: r2 } = this.cameraTrack;
            if (this._use2d || !this._selfieSegmentation ? (this.destination || (this.destination = this.videoContext.createVideoTrackDestination({ name: "mainDestination" })), this.cameraNode ? this.cameraNode.replaceTrack(this.initialTrack) : (this.cameraNode = this.videoContext.createVideoTrackSource(this.initialTrack), this.cameraNode.resize(i2.width, i2.height))) : (this.cameraNode && this.cameraNode.close(), this.destination || (this.destination = new yU(this.videoContext, { name: "mainDestination" })), this.cameraNode = new LU(this.videoContext, { input: this.cameraTrack.mediaTrack, mirror: this._isMirror, bg: this._virtualBackground, selfModel: this.selfModel, waterMark: this._waterMarkOption, useTflite: true, blurRadius: this.blurRadius, assetPath: this._bgAssetPath, selfieSegmentation: this._selfieSegmentation, Wasm: this.Wasm }), this.cameraNode.connect(this.destination)), this.videoContext.frameRate = r2.frameRate, this._use2d) {
              let i3 = this.cameraNode;
              i3.disconnect(), this._isMirror && (this.mirrorNode || (this.mirrorNode = new OU(this.videoContext)), i3 = i3.connect(this.mirrorNode), i3.disconnect(), this.log.info("start mirror")), this.mixNode && this.mixNode.close(), delete this.mixNode, (this._isMixScreen || this._hasWaterMark) && (this.mixNode = new MU(this.videoContext), i3.connect(this.mixNode, { zIndex: 1 }), this._hasWaterMark && !this.waterMarkNode && this._waterMarkOption && (this.waterMarkNode = this.videoContext.createVideoImageSource(this._waterMarkOption.image, { autoResize: false }), this.waterMarkNode.resize(this._waterMarkOption.width, this._waterMarkOption.height), this.waterMarkNode.x = this._waterMarkOption.x, this.waterMarkNode.y = this._waterMarkOption.y), null == (e2 = this.waterMarkNode) || e2.connect(this.mixNode, { zIndex: 2 }), this._isMixScreen && this.screenTrack && !this.screenNode && (this.screenNode = this.videoContext.createVideoTrackSource(this.screenTrack.mediaTrack)), null == (t2 = this.screenNode) || t2.connect(this.mixNode, { zIndex: 0 }), i3 = this.mixNode, this.log.info("start mix", "".concat(this.mixNode.width, "x").concat(this.mixNode.height))), i3.connect(this.destination);
            }
            return this._setMainOutput(this.videoContext._canvas);
          });
        }
        changeInput(e2) {
          if (this.log.info("change input"), e2 instanceof pL)
            return this.setScreenTrack(e2);
          if (e2 instanceof lL)
            return this.setCameraTrack(e2);
          if (e2 instanceof SL) {
            let t2 = e2.mediaTrack;
            if (17 === MD && +PD.split(".")[1] < 4 && !e2.source && e2.player.element) {
              let t3 = new DU({ frameRate: 15, logger: this.log, name: e2.userId });
              t3.create({ alpha: false });
              let i2 = t3.createVideoImageSource(e2.player.element);
              e2.source = i2;
              let r2 = new IU(t3);
              i2.connect(r2), e2.player.setCanvas(t3._canvas);
            }
            return e2.setOutputMediaStreamTrack(t2);
          }
        }
        removeInput(e2) {
          var t2;
          e2 instanceof pL ? (null == (t2 = this.screenNode) || t2.close(), delete this.screenNode, delete this.screenTrack, this.update()) : e2 instanceof lL ? (this.clear(), delete this.cameraTrack, this.smallImageSource && (this.smallImageSource.close(), delete this.smallImageSource), this.smallTrackSource && (this.smallTrackSource.close(), delete this.smallTrackSource)) : e2 instanceof SL && e2.source && e2.source.context.destroy();
        }
        setCameraTrack(e2) {
          return cb(this, null, function* () {
            this.cameraTrack = e2, this.update();
          });
        }
        setScreenTrack(e2) {
          return this.screenTrack = e2, this._isMixScreen && (this.screenNode ? this.screenNode.replaceTrack(e2.mediaTrack) : this.update()), e2.setOutputMediaStreamTrack(e2.mediaTrack);
        }
        getWatermarkImage(e2, t2) {
          return cb(this, null, function* () {
            let i2 = document.createElement("canvas");
            t2 && e2 && (i2.height = t2, i2.width = e2);
            let r2 = i2.getContext("2d");
            if (!r2)
              throw new vb({ code: Sb.NOT_SUPPORTED, message: "Make image failed because of canvas context is null" });
            return this.watermarkImageList.sort((e3, t3) => e3.zIndex - t3.zIndex), this.watermarkImageList.forEach((e3) => {
              let { image: t3, x: i3, y: n2, width: o2, height: s2 } = e3;
              r2.drawImage(t3, i3, n2, o2, s2);
            }), uO(i2.toDataURL());
          });
        }
        pushWaterMarkImageList(e2) {
          let { type: t2 } = e2;
          this.watermarkImageList.some((t3) => t3.imageUrl === e2.imageUrl && t3.height === e2.height && t3.width === e2.width && t3.x === e2.x && t3.y === e2.y && t3.type === e2.type && t3.zIndex === e2.zIndex) || (("mute" === t2 || "watermark" === t2) && (this.watermarkImageList = this.watermarkImageList.filter((e3) => e3.type !== t2)), this.watermarkImageList.push(e2));
        }
        setWatermark(e2) {
          return cb(this, null, function* () {
            let t2;
            try {
              t2 = yield uO((null == e2 ? void 0 : e2.imageElement) || e2.imageUrl);
            } catch (c2) {
              throw new vb({ code: Sb.INVALID_PARAMETER, message: "load image failed, url: ".concat(e2.imageUrl) });
            }
            let { x: i2 = 0, y: r2 = 0, width: n2 = t2.width, height: o2 = t2.height, type: s2 = "watermark", zIndex: a2 = 2 } = e2;
            this.pushWaterMarkImageList({ x: i2, y: r2, width: n2, height: o2, image: t2, zIndex: a2, type: s2, imageUrl: e2.imageUrl }), yield this.freshWatermark(), this.log.info("set watermark", JSON.stringify(this.watermarkImageList));
          });
        }
        deleteWatermark() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "watermark";
          return cb(this, null, function* () {
            this.watermarkImageList = this.watermarkImageList.filter((t2) => t2.type !== e2), this.log.info("delete watermark", e2, JSON.stringify(this.watermarkImageList)), yield this.freshWatermark();
          });
        }
        freshWatermark() {
          return cb(this, null, function* () {
            var e2, t2, i2;
            null == (e2 = this.waterMarkNode) || e2.close(), delete this.waterMarkNode, delete this._waterMarkOption;
            let r2 = yield this.getWatermarkImage(null == (t2 = this.cameraTrack) ? void 0 : t2.settings.width, null == (i2 = this.cameraTrack) ? void 0 : i2.settings.height);
            this._waterMarkOption = { x: 0, y: 0, width: r2.width, height: r2.height, image: r2 }, this.update();
          });
        }
        setVirtualBackground(e2) {
          return cb(this, null, function* () {
            if (e2) {
              if (this._use2d && !this._autoSwitchRenderMode)
                return Promise.reject(new Error("not support virtual background in 2d mode"));
              this._bgAssetPath = e2.assetPath, "image" === e2.type ? this._virtualBackground = yield uO(e2.imageUrl) : (this.blurRadius = e2.blurRadius || 3, this._virtualBackground = e2.type);
            } else
              this._virtualBackground = void 0;
            this.log.info("".concat(this._virtualBackground ? "start" : "stop", " visual background, ").concat((null == e2 ? void 0 : e2.type) || "")), this.update();
          });
        }
        get mixScreen() {
          return this._isMixScreen;
        }
        set mixScreen(e2) {
          var t2;
          this._isMixScreen = e2, this._isMixScreen || (null == (t2 = this.screenNode) || t2.close(), delete this.screenNode), this.update();
        }
        set mirror(e2) {
          var t2;
          this._isMirror !== e2 && (this._isMirror = e2, this._isMirror || (null == (t2 = this.mirrorNode) || t2.close(), delete this.mirrorNode), this.update());
        }
        get mirror() {
          return this._isMirror;
        }
        enableAr(e2) {
          this.arTrack = e2, this.isUsingArTrack = true, this.update();
        }
        updateAr() {
          return cb(this, null, function* () {
            var e2;
            null == (e2 = this.cameraTrack) || !e2.mediaTrack || (yield this.virtualBackgroundInstance.ar.updateInputTrack(this.cameraTrack.mediaTrack.clone()));
          });
        }
        disableAr() {
          var e2;
          this.isUsingArTrack = false, null == (e2 = this.arTrack) || e2.stop(), this.arTrack = void 0, this.update();
        }
        clear() {
          var e2;
          null == (e2 = this.videoContext) || e2.disconnect(), delete this.destination, delete this.cameraNode, delete this.mirrorNode, delete this.screenNode, delete this.waterMarkNode;
        }
      }, VU = 0, UU = class extends TP {
        constructor(e2) {
          super("room"), this.seq = ++VU, this.role = "anchor", this.localTracks = /* @__PURE__ */ new Set(), this.enableAutoPlayDialog = true, this.autoReceiveAudio = true, this.autoReceiveVideo = true, this.scheduleResult = { domains: null, iceServers: null, iceTransportPolicy: null, trtcAutoConf: null }, this._isUsingCachedSchedule = false, this._log = EO.createLogger({ id: "r".concat(this.seq) }), this._joinedTimestamp = 0, this.isDestroyed = false, this.useStringRoomId = !!e2.useStringRoomId, Vw(e2.autoReceiveAudio) && (this.autoReceiveAudio = e2.autoReceiveAudio), Vw(e2.autoReceiveVideo) && (this.autoReceiveVideo = e2.autoReceiveVideo), Vw(e2.enableAutoPlayDialog) && (this.enableAutoPlayDialog = e2.enableAutoPlayDialog), this._sdkType = e2.sdkType, this.keyPointManager = new hU({ room: this, frameWorkType: e2.frameWorkType, component: e2.component, language: e2.language }), this.callDurationCalculator = new mU({ room: this }), this.badCaseDetector = new _U({ room: this }), this.audioManager = new _L(this), this.videoManager = new xU(this);
        }
        get isMainStreamPublished() {
          for (let e2 of this.localTracks)
            if (4 & e2.mediaType)
              return true;
          return false;
        }
        get isAuxStreamPublished() {
          for (let e2 of this.localTracks)
            if (2 & e2.mediaType)
              return true;
          return false;
        }
        get hasAuxStream() {
          for (let e2 of this.remotePublishedUserMap.values())
            if (e2.muteState.hasAuxiliary)
              return true;
          return this.isAuxStreamPublished;
        }
        getLogger() {
          return this._log;
        }
        get isJoining() {
          return "joining" === this.state.toString();
        }
        get isJoined() {
          return "joined" === this.state;
        }
        get isLeft() {
          return "left" === this.state;
        }
        addTrack(e2) {
          return cb(this, null, function* () {
            return this.publish(e2);
          });
        }
        removeTrack(e2) {
          return cb(this, null, function* () {
            return this.unpublish(e2);
          });
        }
        replaceTrack(e2) {
          return cb(this, null, function* () {
          });
        }
        setEncodedDataProcessingListener(e2) {
          throw new Error("Method not implemented.");
        }
        enableAIVoice(e2) {
          throw new Error("Method not implemented.");
        }
        setProxyServer(e2) {
          if (Lw(e2))
            e2.startsWith("wss://") ? this.proxy_ws = e2 : e2.startsWith("https://") && (this.proxy_wt = e2);
          else if (Nw(e2)) {
            let { websocketProxy: t2, webtransportProxy: i2, loggerProxy: r2, scheduleProxy: n2, unifiedProxy: o2 } = e2;
            this.proxy_ws = t2, this.proxy_wt = i2, this.proxy_unified = o2, o2 ? (cw([o2, o2]), Ub("https://".concat(o2))) : (r2 && Ub(r2), n2 && cw(n2));
          }
          ew.once(gO.JOIN_RECEIVED_CMD_RES, () => this.sendAbilityStatus({ sched_domain: aw.main, sched_back_domain: aw.backup, signal_domain: this.proxy_ws || this.proxy_wt || "" }));
        }
        getRemoteAudioStats() {
          return cb(this, null, function* () {
            let e2 = {};
            return this.remotePublishedUserMap.forEach((t2) => {
              e2[t2.userId] = t2.remoteAudioTrack.stat;
            }), e2;
          });
        }
        getTransportStats() {
          return cb(this, null, function* () {
            var e2;
            let t2 = { rtt: (null == (e2 = this.quality) ? void 0 : e2.uplinkRTT) || 0, downlinksRTT: {} };
            if (this.quality)
              for (let i2 of this.quality.downlinkInfo)
                t2.downlinksRTT[i2.userId] = i2.rtt;
            return t2;
          });
        }
        getRemoteVideoStats() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "main";
            return function* () {
              let i2 = {};
              return e2.remotePublishedUserMap.forEach((e3) => {
                let r2 = "auxiliary" === t2 ? e3.remoteAuxiliaryTrack : e3.remoteVideoTrack;
                i2[e3.userId] = r2.stat;
              }), i2;
            }();
          });
        }
        checkDestroy() {
          if (this.isDestroyed)
            throw new vb({ code: Sb.INVALID_OPERATION, message: XD({ key: uN.CLIENT_DESTROYED, data: { funName: "join" } }) });
        }
        destroy() {
          if (this.isJoined)
            throw this._log.warn(hN.INVALID_DESTROY), new vb({ code: Sb.INVALID_OPERATION, message: XD({ key: uN.INVALID_DESTROY }) });
          this._log.info("destroy room"), this.audioManager.destroy(), this.videoManager.destroy(), this.keyPointManager.destroy(), this.callDurationCalculator.destroy(), this.badCaseDetector.destroy(), this.isDestroyed = true, ew.emit(gO.ROOM_DESTROY, { room: this });
        }
        schedule(e2, t2) {
          return cb(this, null, function* () {
            var i2, r2;
            let n2 = zw();
            try {
              let { isCached: o2, result: s2, detailCost: a2 } = yield sw({ userId: this.userId, sdkAppId: this.sdkAppId, roomId: e2, useStringRoomId: this.useStringRoomId, version: Nb, userSig: this.userSig, frameWorkType: t2 });
              this._isUsingCachedSchedule = o2, this._log.info("schedule cache:".concat(+o2, " ").concat(aO(s2, { keysToExclude: ["username", "credential"] }))), o2 && ew.once(gO.JOIN_RECEIVED_CMD_RES, () => this.sendAbilityStatus({ scheduleCache: 1 })), this.scheduleResult = eb(eb({}, this.scheduleResult), s2), xw(null == (i2 = s2.config) ? void 0 : i2.retryCount) && Nk(s2.config.retryCount), Lw(null == (r2 = s2.config) ? void 0 : r2.loggerDomain) && Ub(s2.config.loggerDomain), ew.emit(gO.JOIN_SCHEDULE_SUCCESS, { room: this, schedule: this.scheduleResult, detailCost: a2 }), mM.addSuccessEvent({ key: 521700, cost: zw() - n2, split: 50 });
            } catch (o2) {
              throw mM.addFailedEvent({ key: 521700, error: o2 }), o2;
            }
          });
        }
      }, FU = nb(lb()), BU = nb(gb()), HU = (e2) => {
        let { serverAbility: t2, clientAbility: i2, offerSDP: r2, enableCustomMessage: n2 } = e2, o2 = qV(r2), s2 = { extmapAllowMixed: "extmap-allow-mixed", groups: o2.groups, icelite: "ice-lite", media: [], msidSemantic: { semantic: "", token: "WMS" }, name: "-", origin: { address: "127.0.0.1", username: "-", sessionId: String(Date.now()), sessionVersion: 1, netType: "IN", ipVer: 4 }, timing: { start: 0, stop: 0 }, version: 0 }, a2 = { candidates: t2.candidates.map((e3) => ({ component: 1, foundation: "1", generation: 0, ip: e3.ip, port: e3.port, priority: e3.priority, transport: e3.foundation, type: e3.type })), connection: { version: 4, ip: "0.0.0.0" }, direction: ok.TRANSCEIVER_DIRECTION_RECVONLY, ext: t2.audio.extensions.map((e3) => ({ value: e3.id, uri: e3.uri })), fingerprint: { type: t2.dtls.hash, hash: t2.dtls.fingerprint }, fmtp: [{ payload: t2.audio.codecs[0].payload, config: t2.audio.codecs[0].fmtp }], icePwd: t2.ice.password, iceUfrag: t2.ice.ufrag, mid: "0", payloads: String(t2.audio.codecs[0].payload), port: o2.media[0].port, protocol: o2.media[0].protocol, type: ok.AUDIO, setup: t2.dtls.setup, rtcpFb: t2.audio.codecs[0].rtcpfb.map((e3) => ({ payload: t2.audio.codecs[0].payload, type: e3.id, subtype: e3.params[0] })), rtcpMux: "rtcp-mux", rtcpRsize: "rtcp-rsize", rtp: [{ payload: t2.audio.codecs[0].payload, codec: t2.audio.codecs[0].codec, rate: t2.audio.codecs[0].rate, encoding: t2.audio.codecs[0].channels }] };
        return s2.media.push(a2), [1, 2, 3].forEach((e3) => {
          s2.media.push(jU({ mid: e3, serverAbility: t2, clientAbility: i2, parsedOffer: o2 }));
        }), n2 && s2.media.push(o2.media.find((e3) => "dc" === e3.mid)), YV(s2);
      }, jU = (e2) => {
        let { mid: t2, serverAbility: i2, clientAbility: r2, parsedOffer: n2, useAllCodec: o2 = false } = e2, s2 = { candidates: i2.candidates.map((e3) => ({ component: 1, foundation: "1", generation: 0, ip: e3.ip, port: e3.port, priority: e3.priority, transport: e3.foundation, type: e3.type })), connection: { version: 4, ip: "0.0.0.0" }, direction: ok.TRANSCEIVER_DIRECTION_RECVONLY, ext: i2.video.extensions.map((e3) => ({ value: e3.id, uri: e3.uri })), fingerprint: { type: i2.dtls.hash, hash: i2.dtls.fingerprint }, fmtp: [], icePwd: i2.ice.password, iceUfrag: i2.ice.ufrag, mid: String(t2), payloads: "", port: n2.media[0].port, protocol: n2.media[0].protocol, type: ok.VIDEO, setup: i2.dtls.setup, rtcpFb: [], rtcpMux: "rtcp-mux", rtcpRsize: "rtcp-rsize", rtp: [] };
        if (i2.video.codecs.length > 0)
          if (o2)
            for (let a2 = 0; a2 < i2.video.codecs.length; a2++)
              GU(s2, i2.video.codecs[a2]);
          else {
            let e3 = i2.video.codecs.findIndex((e4) => e4.codec.toLowerCase() === (i2.useVp8 ? "vp8" : "h264"));
            GU(s2, i2.video.codecs[e3]);
          }
        else if (o2)
          for (let a2 = 0; a2 < r2.video.codecs.length; a2++)
            GU(s2, r2.video.codecs[a2]);
        else
          GU(s2, r2.video.codecs[0]);
        return s2.payloads = s2.payloads.trim(), s2;
      }, GU = (e2, t2) => {
        e2.payloads = "".concat(e2.payloads, " ").concat(t2.payload), e2.fmtp.push({ payload: t2.payload, config: t2.fmtp }), e2.rtcpFb = [...e2.rtcpFb || [], ...(t2.rtcpfb || t2.rtcpFb).map((e3) => ({ payload: t2.payload, type: e3.id, subtype: e3.params[0] }))], e2.rtp.push({ payload: t2.payload, codec: t2.codec.toUpperCase(), rate: t2.rate }), t2.rtx && (e2.payloads = "".concat(e2.payloads, " ").concat(t2.rtx), e2.fmtp.push({ payload: t2.rtx, config: "apt=".concat(t2.payload) }), e2.rtp.push({ payload: t2.rtx, codec: "rtx", rate: t2.rate }));
      };
      var WU, JU = (e2) => {
        let t2 = BU.default.parse(e2);
        return t2.media.forEach((e3) => {
          var i2;
          (e3.type === ok.AUDIO || e3.type === ok.VIDEO) && (function(e4) {
            if (!e4.rtcpFb)
              return;
            let t3 = [];
            e4.rtcpFb.forEach((i3, r2) => {
              var n2;
              t3.push(i3), e4.rtcpFb && (null == (n2 = e4.rtcpFb[r2 + 1]) ? void 0 : n2.payload) !== i3.payload && "rrtr" !== i3.type && t3.push({ payload: i3.payload, type: "rrtr" });
            }), e4.rtcpFb = t3;
          }(e3), function(e4) {
            e4.type === ok.VIDEO && e4.fmtp && e4.fmtp.forEach((e5) => {
              e5.config.includes("apt") || (e5.config += ";sps-pps-idr-in-keyframe=1");
            });
          }(e3), function(e4) {
            e4.type === ok.AUDIO && e4.fmtp && e4.fmtp.forEach((e5) => {
              e5.config += ";sprop-stereo=1;stereo=1";
            });
          }(e3), function(e4) {
            let t3 = /* @__PURE__ */ new Set(["urn:ietf:params:rtp-hdrext:sdes:mid", "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id", "urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id"]);
            e4.ext && (e4.ext = e4.ext.filter((e5) => !t3.has(e5.uri)));
          }(e3)), (null == (i2 = e3.payloads) ? void 0 : i2.includes("datachannel")) && t2.groups && e3.mid && (t2.groups[0].mids = t2.groups[0].mids.replace(e3.mid, "dc"), e3.mid = "dc");
        }), BU.default.write(t2);
      }, KU = class {
        constructor(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          this.dataView = e2, this.isSEI && (t2 ? this.addPreventionByte() : this.removePreventionByte());
        }
        addPreventionByte() {
          let e2 = this.seiPayloadStartIndex, t2 = this.dataView.byteLength - 2, i2 = [], r2 = 0;
          for (let o2 = e2; o2 <= t2; o2++) {
            let e3 = this.dataView.getInt8(o2);
            switch (e3) {
              case 0:
              case 1:
              case 2:
              case 3:
                2 === r2 && (i2.push(3), r2 = 0), 0 == e3 ? r2++ : r2 = 0, i2.push(e3);
                break;
              default:
                r2 = 0, i2.push(e3);
            }
          }
          i2.push(this.dataView.getInt8(this.dataView.byteLength - 1));
          let n2 = new DataView(new Uint8Array([...new Uint8Array(this.dataView.buffer).slice(0, e2), ...i2]).buffer);
          this.dataView = n2;
        }
        removePreventionByte() {
          let e2 = this.seiPayloadStartIndex, t2 = this.dataView.byteLength - 1, i2 = [], r2 = 0;
          for (let o2 = e2; o2 <= t2; o2++)
            switch (this.dataView.getInt8(o2)) {
              case 0:
                r2++, i2.push(this.dataView.getInt8(o2));
                break;
              case 3:
                2 !== r2 && i2.push(this.dataView.getInt8(o2)), r2 = 0;
                break;
              default:
                i2.push(this.dataView.getInt8(o2)), r2 = 0;
            }
          let n2 = new DataView(new Uint8Array([...new Uint8Array(this.dataView.buffer).slice(0, e2), ...i2]).buffer);
          this.dataView = n2;
        }
        get isSEI() {
          return 6 === this.dataView.getUint8(4);
        }
        get seiPayloadStartIndex() {
          let e2 = 6;
          for (let t2 = 6; t2 < this.dataView.buffer.byteLength && (e2++, 255 === this.dataView.getUint8(t2)); t2++)
            ;
          return e2;
        }
        get seiPayloadType() {
          return this.isSEI ? this.dataView.getUint8(5) : null;
        }
        get seiPayload() {
          if (!this.isSEI)
            return null;
          let e2 = 0, t2 = 6;
          for (let n2 = 6; n2 < this.dataView.buffer.byteLength; n2++) {
            let i3 = this.dataView.getUint8(n2);
            if (t2++, 255 !== i3) {
              e2 += i3;
              break;
            }
            e2 += 255;
          }
          let i2 = new ArrayBuffer(e2), r2 = new DataView(i2);
          for (let n2 = 0; n2 < i2.byteLength; n2++, t2++)
            r2.setInt8(n2, this.dataView.getInt8(t2));
          return r2;
        }
      }, zU = class {
        constructor(e2, t2) {
          this._singlePC = e2, this._log = t2, sb(this, "_seiMessageList", []), sb(this, "_smallSeiMessageList", []), sb(this, "_seiPayloadType", 243), sb(this, "_seiAbortMap", /* @__PURE__ */ new Map()), sb(this, "_nonSeiAbortMap", /* @__PURE__ */ new Map()), sb(this, "onSEIMessage", null);
        }
        isRunning(e2) {
          return this._seiAbortMap.has(e2);
        }
        start(e2) {
          let t2 = e2.direction === ok.TRANSCEIVER_DIRECTION_SENDONLY, i2 = (t2 ? e2.sender : e2.receiver).createEncodedStreams(), r2 = i2.readable, n2 = i2.writable, o2 = new TransformStream({ transform: t2 ? (t3, i3) => this.encodeVideoFrame(t3, i3, e2) : (t3, i3) => this.decodeVideoFrame(t3, i3, e2) }), s2 = new AbortController();
          r2.pipeThrough(o2).pipeTo(n2, s2).catch((e3) => {
            "destroy" !== e3 && this._log.warn(e3);
          }), this._seiAbortMap.set(e2, s2);
        }
        restart(e2) {
          this.stop(e2), this.start(e2);
        }
        stop(e2) {
          var t2;
          null == (t2 = this._seiAbortMap.get(e2)) || t2.abort(), this._seiAbortMap.delete(e2);
        }
        destroy() {
          this._seiAbortMap.forEach((e2) => e2.abort("destroy")), this._seiAbortMap.clear(), this._nonSeiAbortMap.forEach((e2) => e2.abort("destroy")), this._nonSeiAbortMap.clear(), this.onSEIMessage = null;
        }
        handleEncodedStreams() {
          try {
            this._singlePC.getPeerConnection().getTransceivers().forEach((e2, t2) => {
              var i2, r2;
              if ("inactive" !== e2.direction && e2.mid)
                if (t2 < 4)
                  1 === t2 || 2 === t2 ? this.isRunning(e2) || this.start(e2) : this._nonSeiAbortMap.has(e2) || this.pipeSenderOrReceiver(e2);
                else {
                  let n2 = (t2 - 4) % 3 == 1, o2 = (t2 - 4) % 3 == 2;
                  (null == (r2 = null == (i2 = e2.receiver) ? void 0 : i2.track) ? void 0 : r2.kind) === ok.VIDEO && (n2 || o2) ? this.isRunning(e2) || this.start(e2) : this._nonSeiAbortMap.has(e2) || this.pipeSenderOrReceiver(e2);
                }
            });
          } catch (rM2) {
            this._log.warn(rM2);
          }
        }
        pipeSenderOrReceiver(e2) {
          let t2 = e2.direction === ok.TRANSCEIVER_DIRECTION_SENDONLY ? e2.sender : e2.receiver, { readable: i2, writable: r2 } = t2.createEncodedStreams(), n2 = new AbortController();
          this._nonSeiAbortMap.set(e2, n2), i2.pipeTo(r2, n2).catch(() => {
          });
        }
        push(e2, t2) {
          var i2, r2;
          t2 && t2.seiPayloadType && (this._seiPayloadType = t2.seiPayloadType), this._seiMessageList.push(e2), (null == (r2 = null == (i2 = this._singlePC.getPeerConnection()) ? void 0 : i2.getSenders()[2]) ? void 0 : r2.track) && this._smallSeiMessageList.push(e2);
        }
        hasSEI(e2) {
          let t2 = new DataView(e2);
          return 1 === t2.getInt32(0) && 6 === t2.getInt8(4);
        }
        isEmptyFrame(e2) {
          return "empty" === e2.type || 0 === e2.data.byteLength;
        }
        getNaluCount(e2) {
          let t2 = 0, i2 = 0, r2 = new DataView(e2);
          for (let n2 = 0; n2 < e2.byteLength; n2++)
            switch (r2.getUint8(n2)) {
              case 0:
                t2++;
                break;
              case 1:
                (2 === t2 || 3 === t2) && i2++, t2 = 0;
                break;
              default:
                t2 = 0;
            }
          return i2;
        }
        encodeVideoFrame(e2, t2, i2) {
          try {
            let t3 = 2 === Number(i2.mid) ? this._smallSeiMessageList : this._seiMessageList;
            if (this._singlePC.isUsingH264 && t3.length > 0 && !this.isEmptyFrame(e2)) {
              let i3 = 9 - this.getNaluCount(e2.data);
              if (i3 <= 0)
                return;
              let r2 = t3.splice(0, i3).reverse().map(this.encodeSEINalu.bind(this)), n2 = r2.reduce((e3, t4) => e3 + t4.dataView.byteLength, 0), o2 = new ArrayBuffer(n2 + e2.data.byteLength), s2 = new DataView(o2), a2 = new DataView(e2.data), c2 = 0;
              for (let e3 = 0; e3 < r2.length; e3++)
                for (let t4 = 0; t4 < r2[e3].dataView.byteLength; t4++)
                  s2.setInt8(c2++, r2[e3].dataView.getInt8(t4));
              for (let t4 = 0; t4 < e2.data.byteLength; t4++)
                s2.setInt8(c2++, a2.getInt8(t4));
              e2.data = o2, this._log.debug("".concat(r2.length, " sei sent"));
            }
          } catch (Ob2) {
            this._log.warn(Ob2);
          }
          t2.enqueue(e2);
        }
        decodeVideoFrame(e2, t2, i2) {
          try {
            if (this._singlePC.isUsingH264 && !this.isEmptyFrame(e2) && this.hasSEI(e2.data)) {
              let t3 = [], r2 = new DataView(e2.data), n2 = 0, o2 = -1, s2 = -1;
              for (let i3 = 0; i3 < e2.data.byteLength; i3++) {
                let a2 = r2.getUint8(i3);
                if (0 === a2)
                  n2++;
                else if (1 === a2) {
                  if (2 === n2 || 3 === n2) {
                    let a3 = i3 - n2;
                    if (-1 === o2 ? o2 = a3 : -1 === s2 && (s2 = a3, t3.push(new KU(new DataView(r2.buffer.slice(o2, s2)))), o2 = a3, s2 = -1), 6 !== r2.getUint8(i3 + 1)) {
                      e2.data = new DataView(r2.buffer.slice(a3)).buffer;
                      break;
                    }
                  }
                  n2 = 0;
                } else
                  n2 = 0;
              }
              this._log.debug("".concat(t3.length, " sei received")), Pw(this.onSEIMessage) && t3.reverse().forEach((e3) => {
                let t4 = Number(i2.mid);
                this.onSEIMessage({ seiPayloadType: e3.seiPayloadType, data: e3.seiPayload.buffer, mid: t4, streamType: (t4 - 4) % 3 == 2 ? "auxiliary" : "main" });
              });
            }
          } catch (Ob2) {
            this._log.warn(Ob2);
          }
          t2.enqueue(e2);
        }
        encodeSEINalu(e2) {
          let t2 = e2.byteLength, i2 = parseInt(String(t2 / 255), 10), r2 = t2 % 255, n2 = [];
          n2.push(0, 0, 0, 1, 6, this._seiPayloadType);
          for (let s2 = 0; s2 < i2; s2++)
            n2.push(255);
          n2.push(r2);
          let o2 = new DataView(e2);
          return n2.push(...new Uint8Array(o2.buffer)), n2.push(128), new KU(new DataView(new Uint8Array(n2).buffer), true);
        }
      }, qU = ((WU = qU || {}).TRACK = "track", WU.DATA_CHANNEL_MESSAGE = "data_channel_msg", WU[WU.CONNECTION_STATE_CHANGED = "connection-state-changed"] = "CONNECTION_STATE_CHANGED", WU[WU.FIREWALL_RESTRICTION = "firewall-restriction"] = "FIREWALL_RESTRICTION", WU.RECONNECTED = "spc-reconnected", WU.RECONNECT_FAILED = "spc-reconnect-failed", WU.ERROR = "error", WU.SEI_MESSAGE = "sei-message", WU), YU = 0, QU = false, XU = /* @__PURE__ */ new Set(), $U = 1, ZU = class extends FU.default {
        constructor(e2) {
          let { signalChannel: t2, room: i2, enableCustomMessage: r2 } = e2;
          super(), sb(this, "stat", { iceStartTime: 0, iceEndTime: 0, dtlsStartTime: 0, dtlsEndTime: 0, peerConnectionStartTime: 0, peerConnectionEndTime: 0 }), sb(this, "currentState", "DISCONNECTED"), sb(this, "_room"), sb(this, "_signalChannel"), sb(this, "_peerConnection", null), sb(this, "_datachannel", null), sb(this, "_enableCustomMessage"), sb(this, "_log"), sb(this, "_downlinkMIDMap", /* @__PURE__ */ new Map()), sb(this, "_downlinkMIDUserIDMap", /* @__PURE__ */ new Map()), sb(this, "_reconnectionTimer", -1), sb(this, "reconnectionCount", 0), sb(this, "clientAbility"), sb(this, "_serverAbility", null), sb(this, "addDownlinkQueue", /* @__PURE__ */ new Set()), sb(this, "removeDownlinkQueue", /* @__PURE__ */ new Set()), sb(this, "_parsedAnswer", null), sb(this, "_updateSDPPromise", null), sb(this, "_waitForPCConnectedPromise"), sb(this, "_waitForPCConnectedPromiseReject", null), sb(this, "_isSDPLogged", false), sb(this, "seiCodec", null), this._room = i2, this._enableCustomMessage = r2, this._signalChannel = t2, this._log = EO.createLogger({ id: "spc".concat($U++), userId: this._room.userId, sdkAppId: this._room.sdkAppId }), this._room.enableSEI && iP && (this._log.info("create sei codec"), this.seiCodec = new zU(this, this._log), this.seiCodec.onSEIMessage = (e3) => {
            this.emit("sei-message", { userId: this._downlinkMIDUserIDMap.get(e3.mid), data: e3.data, seiPayloadType: e3.seiPayloadType, streamType: e3.streamType });
          });
        }
        get isH264EncodeSupported() {
          let e2 = this._room.checkSystemResult.detail.isH264EncodeSupported;
          return this._serverAbility && (e2 = e2 && !!this._serverAbility.video.codecs.find((e3) => "h264" === e3.codec.toLowerCase())), e2;
        }
        get isVP8EncodeSupported() {
          let e2 = this._room.checkSystemResult.detail.isVp8EncodeSupported;
          return this._serverAbility && (e2 = e2 && this._serverAbility.useVp8), e2;
        }
        get videoCodec() {
          var e2;
          return null != (e2 = this._serverAbility) && e2.useVp8 ? "vp8" : "h264";
        }
        get isUsingH264() {
          return "h264" === this.videoCodec;
        }
        get uplinkSSRC() {
          return this._peerConnection && this._peerConnection.localDescription ? ((e2) => {
            let t2 = qV(e2), i2 = { audioSsrc: 0, audioRtxSsrc: 0, bigVideoSsrc: 0, bigVideoRtxSsrc: 0, smallVideoSsrc: 0, smallVideoRtxSsrc: 0, auxVideoSsrc: 0, auxVideoRtxSsrc: 0 };
            return t2.media.forEach((e3, t3) => {
              var r2;
              if (e3.ssrcs && !Mw(e3.ssrcs[0].id)) {
                let n2 = Number(e3.ssrcs[0].id), o2 = Number(null == (r2 = e3.ssrcs.filter((e4) => "cname" === e4.attribute)[1]) ? void 0 : r2.id);
                switch (t3) {
                  case 0:
                    i2.audioSsrc = n2;
                    break;
                  case 1:
                    i2.bigVideoSsrc = n2, i2.bigVideoRtxSsrc = o2;
                    break;
                  case 2:
                    i2.smallVideoSsrc = n2, i2.smallVideoRtxSsrc = o2;
                    break;
                  case 3:
                    i2.auxVideoSsrc = n2, i2.auxVideoRtxSsrc = o2;
                }
              }
            }), i2;
          })(this._peerConnection.localDescription.sdp) : { audioSsrc: 0, audioRtxSsrc: 0, bigVideoSsrc: 0, bigVideoRtxSsrc: 0, smallVideoSsrc: 0, smallVideoRtxSsrc: 0, auxVideoSsrc: 0, auxVideoRtxSsrc: 0 };
        }
        get isReconnecting() {
          return "RECONNECTING" === this.currentState || this._reconnectionTimer > 0 || this.reconnectionCount > 0;
        }
        get dtlsTransport() {
          if (!this._peerConnection)
            return null;
          let e2 = this._peerConnection.getSenders();
          return 0 === e2.length ? null : e2[0].transport;
        }
        initialize() {
          return cb(this, null, function* () {
            let e2;
            try {
              return this._peerConnection = new RTCPeerConnection({ encodedInsertableStreams: this._room.enableSEI && iP, offerExtmapAllowMixed: true, iceServers: this._room.getIceServers(), iceTransportPolicy: this._room.getIceTransportPolicy(), sdpSemantics: this._room.sdpSemantics, bundlePolicy: "max-bundle", rtcpMuxPolicy: "require", tcpCandidatePolicy: "disable", IceTransportsType: "nohost" }), this._peerConnection.oniceconnectionstatechange = () => {
                if (!this._peerConnection)
                  return;
                let e3 = this._peerConnection.iceConnectionState;
                this._log.debug("ice state: ".concat(e3)), "checking" === e3 && 0 === this.stat.iceStartTime ? this.stat.iceStartTime = Date.now() : "connected" === e3 && 0 === this.stat.iceEndTime && (this.stat.iceEndTime = Date.now());
              }, this._peerConnection.onconnectionstatechange = this.onConnectionStateChange.bind(this), this._peerConnection.ontrack = (e3) => this.emit("track", e3), this._enableCustomMessage && (this._datachannel = this._peerConnection.createDataChannel("".concat(this._room.userId, "dc")), this._datachannel.binaryType = "arraybuffer", this._datachannel.onopen = () => {
                this._log.info("datachannel open");
              }, this._datachannel.onclose = () => {
                this._log.warn("datachannel close");
              }, this._datachannel.onmessage = (e3) => {
                let t2 = new tF(e3.data);
                this.emit("data_channel_msg", { data: t2 });
              }, this._datachannel.onerror = (e3) => {
                this._log.warn("datachannel error", e3);
              }), this._peerConnection.addTransceiver(ok.AUDIO, { direction: ok.TRANSCEIVER_DIRECTION_SENDONLY }), this._peerConnection.addTransceiver(ok.VIDEO, { direction: ok.TRANSCEIVER_DIRECTION_SENDONLY }), this._peerConnection.addTransceiver(ok.VIDEO, { direction: ok.TRANSCEIVER_DIRECTION_SENDONLY }), this._peerConnection.addTransceiver(ok.VIDEO, { direction: ok.TRANSCEIVER_DIRECTION_SENDONLY }), e2 = yield this._peerConnection.createOffer(), yield this.setOffer(e2), this.dtlsTransport && (this.dtlsTransport.onstatechange = () => {
                let { dtlsTransport: e3 } = this;
                !e3 || (this._log.debug("dtls state: ".concat(e3.state)), "connecting" === e3.state && 0 === this.stat.dtlsStartTime ? this.stat.dtlsStartTime = Date.now() : "connected" === e3.state && 0 === this.stat.dtlsEndTime && (this.stat.dtlsEndTime = Date.now()));
              }), this.clientAbility = ((e3, t2) => {
                var i2, r2;
                let n2 = qV(e3), o2 = { ice: { ufrag: "", password: "" }, dtls: { hash: "", fingerprint: "", setup: "" }, audio: { codecs: [], extensions: [] }, video: { codecs: [], extensions: [] }, useDataChannel: t2 };
                o2.ice.ufrag = String(n2.media[0].iceUfrag), o2.ice.password = n2.media[0].icePwd || "", n2.fingerprint && (o2.dtls.hash = n2.fingerprint.type, o2.dtls.fingerprint = n2.fingerprint.hash, o2.dtls.setup = n2.setup || ""), n2.media[0].fingerprint && (o2.dtls.hash = n2.media[0].fingerprint.type, o2.dtls.fingerprint = n2.media[0].fingerprint.hash), o2.dtls.setup = n2.media[0].setup || "";
                let s2 = n2.media[0], a2 = n2.media[1];
                s2.ext && (o2.audio.extensions = s2.ext.map((e4) => ({ id: e4.value, uri: e4.uri }))), a2.ext && (o2.video.extensions = a2.ext.map((e4) => ({ id: e4.value, uri: e4.uri })));
                let c2 = { codec: s2.rtp[0].codec, fmtp: s2.fmtp[0].config, payload: s2.fmtp[0].payload, rate: s2.rtp[0].rate, channel: s2.rtp[0].encoding, rtcpFb: [], rtx: 0 };
                null == (i2 = s2.rtcpFb) || i2.forEach((e4) => {
                  let { payload: t3, type: i3, subtype: r3 } = e4;
                  if (t3 === c2.payload) {
                    let e5 = { id: i3, params: [] };
                    r3 && e5.params.push(r3), c2.rtcpFb.push(e5);
                  }
                }), o2.audio.codecs.push(c2);
                for (let l2 = 0; l2 < a2.rtp.length; l2++) {
                  if (["rtx", "red", "ulpfec"].includes(a2.rtp[l2].codec))
                    continue;
                  let e4 = a2.fmtp.filter((e5) => e5.payload === a2.rtp[l2].payload)[0];
                  o2.video.codecs.push({ payload: a2.rtp[l2].payload, codec: a2.rtp[l2].codec, fmtp: e4 ? e4.config : "", rate: a2.rtp[l2].rate, rtx: "rtx" === (null == (r2 = a2.rtp[l2 + 1]) ? void 0 : r2.codec) ? a2.rtp[l2 + 1].payload : 0, rtcpFb: ((null == a2 ? void 0 : a2.rtcpFb) || []).filter((e5) => e5.payload === a2.rtp[l2].payload).map((e5) => {
                    let { type: t3, subtype: i3 } = e5;
                    return { id: t3, params: i3 ? [i3] : [] };
                  }) });
                }
                return o2;
              })(e2.sdp, this._enableCustomMessage), mM.addSuccessEvent({ key: 521707 }), this.clientAbility;
            } catch (wk2) {
              throw mM.addFailedEvent({ key: 521707, error: wk2 }), this._log.error("initialize failed ".concat(wk2, " \noffer: ").concat(null == e2 ? void 0 : e2.sdp)), wk2;
            }
          });
        }
        connect(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          return cb(this, null, function* () {
            var i2;
            try {
              if ("CONNECTED" === this.currentState)
                return;
              let r2 = zw(), n2 = { type: "answer", sdp: HU({ serverAbility: e2, clientAbility: this.clientAbility, offerSDP: this._peerConnection.localDescription.sdp, enableCustomMessage: this._enableCustomMessage }) };
              this._serverAbility = e2, yield this.setAnswer(n2), yield this.waitForPeerConnectionConnected(), t2 || mM.addSuccessEvent({ key: 521703, cost: zw() - r2 }), null == (i2 = this.seiCodec) || i2.handleEncodedStreams();
            } catch (tM2) {
              let i3 = tM2 instanceof vb && tM2.code === Sb.API_CALL_ABORTED;
              throw i3 || this._log.error("connect failed: ".concat(tM2), e2), this.reset(), !i3 && !this.isReconnecting && (mM.addFailedEvent({ key: 521703, error: tM2 }), this.emitConnectionStateChangedEvent("DISCONNECTED"), this.startReconnection()), tM2;
            }
          });
        }
        reconnect() {
          return cb(this, null, function* () {
            if (-1 === this._reconnectionTimer) {
              if (!this._signalChannel.isConnected)
                return this._log.warn("reconnect() wait signal channel is connected"), void this._signalChannel.once(rV, this.reconnect, this);
              try {
                this.reconnectionCount++, this._log.warn("reconnect() trying [".concat(this.reconnectionCount, "]")), this.reset();
                let e2 = yield this.initialize(), t2 = yield this._signalChannel.sendWaitForResponse({ command: NV, responseCommand: cV.REBUILD_PEER_CONNECTION_RES, data: { ability: e2 }, enableLog: false });
                if (0 !== t2.data.code)
                  throw new vb({ code: t2.data.code, message: t2.data.message });
                yield this.connect(t2.data.data.ability, true), mM.addSuccessEvent({ key: 521704 }), this._log.warn("reconnect() success"), this.stopReconnection(), ew.emit(gO.SPC_RECONNECTED, { room: this._room }), this.emit("spc-reconnected");
              } catch (wb2) {
                if (!this.isReconnecting)
                  return;
                if (null != wb2 && wb2.message.includes("timeout")) {
                  let e2 = ww(this.reconnectionCount);
                  this._log.warn("reconnect() timeout, try again after ".concat(e2 / 1e3, "s")), this._reconnectionTimer = window.setTimeout(() => {
                    this.clearReconnectionTimer(), this.reconnect();
                  }, e2);
                } else
                  this._log.error("reconnect() failed ".concat(null == wb2 ? void 0 : wb2.code, " ").concat(wb2)), mM.addFailedEvent({ key: 521704, error: wb2 }), this.reconnectionCount >= Dk() && this._log.warn("SDK has tried reconnect for ".concat(Dk(), " times, but all failed, please check your network")), this.stopReconnection(), this.emitConnectionStateChangedEvent("DISCONNECTED"), this.emit("error");
              }
            } else
              this._log.warn("reconnect() is reconnecting, ignore current reconnection");
          });
        }
        getPeerConnection() {
          return this._peerConnection;
        }
        startReconnection() {
          return cb(this, null, function* () {
            this._log.warn("start reconnect"), this._updateSDPPromise = null, this.emitConnectionStateChangedEvent("RECONNECTING"), yield this.reconnect();
          });
        }
        stopReconnection() {
          this.isReconnecting && (this._log.info("stop reconnect"), this.reconnectionCount = 0, this.clearReconnectionTimer(), this._signalChannel.off(rV, this.reconnect, this));
        }
        checkPeerConnectionToReconnect() {
          var e2;
          !this.isReconnecting && (null == (e2 = this._peerConnection) ? void 0 : e2.connectionState) === bk.CLOSED && this.startReconnection();
        }
        clearReconnectionTimer() {
          -1 !== this._reconnectionTimer && (clearTimeout(this._reconnectionTimer), this._reconnectionTimer = -1);
        }
        onConnectionStateChange(e2) {
          let t2 = this._peerConnection.iceConnectionState, i2 = this.getDTLSTransportState();
          this._log.info("connectionState: ".concat(e2.target.connectionState, " ICE: ").concat(t2, " DTLS: ").concat(i2)), e2.target.connectionState === bk.CONNECTING && (0 === this.stat.peerConnectionStartTime && (this.stat.peerConnectionStartTime = Date.now()), this.emitConnectionStateChangedEvent("CONNECTING")), (e2.target.connectionState === bk.FAILED || e2.target.connectionState === bk.CLOSED) && (this.emitConnectionStateChangedEvent("DISCONNECTED"), this.startReconnection()), (e2.target.connectionState === bk.CONNECTED || e2.target.connectionState === bk.COMPLETED) && (0 === this.stat.peerConnectionEndTime && (this.stat.peerConnectionEndTime = Date.now()), ew.emit(gO.SINGLE_CONNECTION_STAT, { room: this._room, stat: { ice: this.stat.iceEndTime - this.stat.iceStartTime, dtls: this.stat.dtlsEndTime - this.stat.dtlsStartTime, peerConnection: this.stat.peerConnectionEndTime - this.stat.peerConnectionStartTime } }), this.logSelectedCandidate(), this.emitConnectionStateChangedEvent("CONNECTED"));
        }
        getDTLSTransportState() {
          if (!this._peerConnection)
            return Ck;
          let e2 = null;
          return zO() && 0 !== this._peerConnection.getSenders().length ? (e2 = this._peerConnection.getSenders()[0].transport, KO() && 0 !== this._peerConnection.getReceivers().length && e2 ? e2.state : Ck) : Ck;
        }
        emitConnectionStateChangedEvent(e2) {
          e2 !== this.currentState && ("RECONNECTING" === this.currentState && "CONNECTING" === e2 || (this.emit(qU.CONNECTION_STATE_CHANGED, { prevState: this.currentState, state: e2 }), this.currentState = e2));
        }
        logSelectedCandidate() {
          return cb(this, null, function* () {
            if (!this._peerConnection)
              return;
            let e2 = yield this._peerConnection.getStats();
            for (let [t2, i2] of e2)
              if (FO(i2)) {
                let t3 = e2.get(i2.localCandidateId), r2 = e2.get(i2.remoteCandidateId);
                t3 && (this._log.info("local candidate: ".concat(t3.candidateType, " ").concat(t3.protocol, ":").concat(t3.ip || t3.address, ":").concat(t3.port, " ").concat(t3.networkType || "", " ").concat("relay" === t3.candidateType ? "relayProtocol:".concat(t3.relayProtocol) : "")), t3.networkType && Sw(t3.networkType)), r2 && this._log.info("remote candidate: ".concat(r2.candidateType, " ").concat(r2.protocol, ":").concat(r2.ip || r2.address, ":").concat(r2.port));
                break;
              }
          });
        }
        waitForPeerConnectionConnected() {
          return this._waitForPCConnectedPromise || (this._waitForPCConnectedPromise = new Promise((e2, t2) => {
            if ("CONNECTED" === this.currentState)
              return e2();
            this._waitForPCConnectedPromiseReject = t2;
            let i2 = (t3) => {
              "CONNECTED" === t3.state && (clearTimeout(o2), n2(), e2());
            }, r2 = (e3) => {
              let { room: i3 } = e3;
              i3 === this._room && (clearTimeout(o2), n2(), t2(new vb({ code: Sb.API_CALL_ABORTED, message: XD({ key: uN.CONNECTION_ABORTED, data: "leave room" }) })));
            }, n2 = () => {
              ew.off(gO.LEAVE_SUCCESS, r2, this), this.off(qU.CONNECTION_STATE_CHANGED, i2, this);
            }, o2 = setTimeout(() => {
              n2();
              let e3 = new vb({ code: Sb.API_CALL_TIMEOUT, message: "connection timeout" });
              var i3;
              YU += 1, i3 = this._signalChannel.isConnected, YU > 2 && !QU && 0 === XU.size && i3 && (this._log.warn("firewall restriction"), QU = true, this.emit(qU.FIREWALL_RESTRICTION)), t2(e3);
            }, Jk);
            ew.on(gO.LEAVE_SUCCESS, r2, this), this.on(qU.CONNECTION_STATE_CHANGED, i2, this);
          }), this._waitForPCConnectedPromise = this._waitForPCConnectedPromise.finally(() => {
            this._waitForPCConnectedPromise = null, this._waitForPCConnectedPromiseReject = null;
          })), this._waitForPCConnectedPromise;
        }
        waitForReconnected() {
          return this.isReconnecting ? new Promise((e2, t2) => {
            this.once("spc-reconnected", e2), this.once("error", t2);
          }) : Promise.resolve();
        }
        addDownlink(e2) {
          return cb(this, null, function* () {
            var t2;
            if (this._log.info("addDownlink(".concat(e2.userId, ") trying")), this.isReconnecting && (yield this.waitForReconnected()), this._updateSDPPromise && (yield this._updateSDPPromise), this.updateLocalAndRemoteSDPConfig(e2), 0 === this.addDownlinkQueue.size)
              try {
                yield this.updateSDP(), null == (t2 = this.seiCodec) || t2.handleEncodedStreams(), this._log.info("addDownlink(".concat(e2.userId, ") done"));
              } catch (Ob2) {
                this._log.error("addDownlink(".concat(e2.userId, ") failed ").concat(Ob2)), yield this.startReconnection();
              }
          });
        }
        updateLocalAndRemoteSDPConfig(e2) {
          let { ssrc: t2, userId: i2, tinyId: r2 } = e2;
          if (!this._peerConnection)
            return;
          this._log.info("updateLocalAndRemoteSDPConfig ".concat(i2, " ").concat(JSON.stringify(t2)));
          let n2 = this._peerConnection.getTransceivers().filter((e3) => "inactive" === e3.direction).slice(0, 3).map((e3) => (e3.direction = ok.TRANSCEIVER_DIRECTION_RECVONLY, Number(e3.mid)));
          this._parsedAnswer || (this._parsedAnswer = qV(this._peerConnection.remoteDescription.sdp));
          let o2, s2, a2, c2 = this._parsedAnswer.media.filter((e3) => {
            var t3;
            return null == (t3 = e3.ssrcs) ? void 0 : t3.find((e4) => {
              var t4;
              return null == (t4 = e4.value) ? void 0 : t4.includes(r2);
            });
          });
          if (3 === c2.length)
            o2 = c2[0], s2 = c2[1], a2 = c2[2];
          else if (3 === n2.length)
            o2 = this._parsedAnswer.media.find((e3) => Number(e3.mid) === Number(n2[0])), s2 = this._parsedAnswer.media.find((e3) => Number(e3.mid) === Number(n2[1])), a2 = this._parsedAnswer.media.find((e3) => Number(e3.mid) === Number(n2[2]));
          else if (0 === n2.length) {
            this._peerConnection.addTransceiver(ok.AUDIO, { direction: ok.TRANSCEIVER_DIRECTION_RECVONLY }), this._peerConnection.addTransceiver(ok.VIDEO, { direction: ok.TRANSCEIVER_DIRECTION_RECVONLY }), this._peerConnection.addTransceiver(ok.VIDEO, { direction: ok.TRANSCEIVER_DIRECTION_RECVONLY }), o2 = JSON.parse(JSON.stringify(this._parsedAnswer.media[0]));
            let e3 = jU({ mid: 1, serverAbility: this._serverAbility, clientAbility: this.clientAbility, parsedOffer: qV(this._peerConnection.localDescription.sdp), useAllCodec: true });
            s2 = JSON.parse(JSON.stringify(e3)), a2 = JSON.parse(JSON.stringify(e3)), o2.mid = this._parsedAnswer.media.length, this._parsedAnswer.media.push(o2), s2.mid = this._parsedAnswer.media.length, this._parsedAnswer.media.push(s2), a2.mid = this._parsedAnswer.media.length, this._parsedAnswer.media.push(a2);
          }
          o2.direction = ok.TRANSCEIVER_DIRECTION_SENDONLY;
          let l2 = "".concat(r2, "-").concat(t2.audio);
          o2.ssrcs = [{ id: t2.audio, attribute: "cname", value: "".concat(l2) }, { id: t2.audio, attribute: "msid", value: "".concat(l2, "-").concat(ok.MAIN, " ").concat(l2, "-audio") }], s2.direction = ok.TRANSCEIVER_DIRECTION_SENDONLY, s2.ssrcs = [{ id: t2.video, attribute: "cname", value: "".concat(l2) }, { id: t2.video, attribute: "msid", value: "".concat(l2, "-").concat(ok.MAIN, " ").concat(l2, "-bigvideo") }, { id: t2.videoRtx, attribute: "cname", value: "".concat(l2) }, { id: t2.videoRtx, attribute: "msid", value: "".concat(l2, "-").concat(ok.MAIN, " ").concat(l2, "-bigvideo") }], s2.ssrcGroups = [{ semantics: "FID", ssrcs: "".concat(t2.video, " ").concat(t2.videoRtx) }], a2.direction = ok.TRANSCEIVER_DIRECTION_SENDONLY;
          let d2 = "".concat(l2, "-aux");
          a2.ssrcs = [{ id: t2.auxiliary, attribute: "cname", value: d2 }, { id: t2.auxiliary, attribute: "msid", value: "".concat(d2, " ").concat(l2, "-aux").concat(ok.VIDEO) }, { id: t2.auxiliaryRtx, attribute: "cname", value: "".concat(d2, " ").concat(l2, "-aux").concat(ok.VIDEO) }, { id: t2.auxiliaryRtx, attribute: "msid", value: "".concat(d2, " ").concat(l2, "-aux").concat(ok.VIDEO) }], a2.ssrcGroups = [{ semantics: "FID", ssrcs: "".concat(t2.auxiliary, " ").concat(t2.auxiliaryRtx) }], this._parsedAnswer.groups && (this._parsedAnswer.groups[0].mids = this._parsedAnswer.media.map((e3) => e3.mid).join(" ")), this._downlinkMIDMap.set(i2, [o2.mid, s2.mid, a2.mid]), this._downlinkMIDUserIDMap.set(o2.mid, i2), this._downlinkMIDUserIDMap.set(s2.mid, i2), this._downlinkMIDUserIDMap.set(a2.mid, i2);
        }
        removeDownlink(e2) {
          return cb(this, null, function* () {
            if (!this._downlinkMIDMap.has(e2) || !this._peerConnection)
              return;
            this._log.info("removeDownlink(".concat(e2, ") trying")), this.isReconnecting && (yield this.waitForReconnected()), this._updateSDPPromise && (yield this._updateSDPPromise);
            let t2 = this._downlinkMIDMap.get(e2), i2 = false;
            this._peerConnection.getTransceivers().forEach((e3) => {
              null != t2 && t2.includes(Number(e3.mid)) && (i2 = true, e3.direction = "inactive");
            }), this._parsedAnswer || (this._parsedAnswer = qV(this._peerConnection.remoteDescription.sdp)), this._parsedAnswer.media.forEach((e3) => {
              null != t2 && t2.includes(Number(e3.mid)) && (i2 = true, e3.direction = "inactive", e3.ssrcs = [], e3.ssrcGroups = []);
            }), 0 === this.removeDownlinkQueue.size && i2 && (yield this.updateSDP()), this._downlinkMIDMap.delete(e2), null == t2 || t2.forEach((e3) => this._downlinkMIDUserIDMap.delete(e3)), this._log.info("removeDownlink(".concat(e2, ") done"));
          });
        }
        setBandwidth(e2) {
          return cb(this, null, function* () {
            if (!this._peerConnection)
              return;
            let { audio: t2, bigVideo: i2, smallVideo: r2, auxVideo: n2 } = e2;
            try {
              if (ZO()) {
                let e3 = this._peerConnection.getSenders().slice(0, 4);
                for (let s2 = 0; s2 < e3.length; s2++) {
                  let o3, a2 = e3[s2];
                  0 === s2 && t2 ? o3 = t2 : 1 === s2 && i2 ? o3 = i2 : 2 === s2 && r2 ? o3 = r2 : 3 === s2 && n2 && (o3 = n2), o3 && (yield this.setSenderMaxBitrate(a2, o3));
                }
                let o2 = false;
                i2 && e3[1].track && (o2 = this.setStartBitrate(1, i2)), n2 && e3[3].track && (o2 = this.setStartBitrate(3, n2) || o2), o2 && (yield this.updateSDP());
              } else
                yield this.setBandwidthBySDP(e2);
              this._log.info("setBandwidth ".concat(JSON.stringify(e2)));
            } catch (o2) {
              this._log.error("failed to set bandwidth: ".concat(o2));
            }
          });
        }
        setStartBitrate(e2, t2) {
          var i2, r2;
          return !(null == (i2 = this._peerConnection) || !i2.remoteDescription || (this._parsedAnswer || (this._parsedAnswer = qV(this._peerConnection.remoteDescription.sdp)), null == (r2 = this._parsedAnswer.media[e2]) || !r2.fmtp[0])) && (this._parsedAnswer.media[e2].fmtp[0].config += ";x-google-start-bitrate=".concat(t2 > 5e3 ? 5e3 : t2), true);
        }
        setSenderMaxBitrate(e2, t2) {
          let i2 = e2.getParameters();
          return (!i2.encodings || 0 === i2.encodings.length) && (i2.encodings = [{}]), "unlimited" === t2 ? delete i2.encodings[0].maxBitrate : i2.encodings[0].maxBitrate = 1e3 * t2, e2.setParameters(i2);
        }
        setBandwidthBySDP(e2) {
          let { audio: t2, bigVideo: i2, smallVideo: r2, auxVideo: n2 } = e2;
          if (!this._peerConnection || !this._peerConnection.localDescription)
            return;
          let o2 = qV(this._peerConnection.localDescription.sdp);
          this._parsedAnswer || (this._parsedAnswer = qV(this._peerConnection.remoteDescription.sdp));
          let s2 = NN ? "TIAS" : "AS";
          t2 && (o2.media[0].bandwidth = [{ type: s2, limit: NN ? 1e3 * t2 : t2 }], this._parsedAnswer.media[0].bandwidth = [{ type: s2, limit: NN ? 1e3 * t2 : t2 }]), i2 && (o2.media[1].bandwidth = [{ type: s2, limit: NN ? 1e3 * i2 : i2 }], this._parsedAnswer.media[1].bandwidth = [{ type: s2, limit: NN ? 1e3 * i2 : i2 }]), r2 && (o2.media[2].bandwidth = [{ type: s2, limit: NN ? 1e3 * r2 : r2 }], this._parsedAnswer.media[2].bandwidth = [{ type: s2, limit: NN ? 1e3 * r2 : r2 }]), n2 && (o2.media[3].bandwidth = [{ type: s2, limit: NN ? 1e3 * n2 : n2 }], this._parsedAnswer.media[3].bandwidth = [{ type: s2, limit: NN ? 1e3 * n2 : n2 }]);
          let a2 = { type: "offer", sdp: YV(o2) };
          return this.updateSDP({ localDescription: a2 });
        }
        setScaleResolutionDownBy(e2, t2) {
          if (1 === t2)
            return;
          let i2 = e2.getParameters();
          return (!i2.encodings || 0 === i2.encodings.length) && (i2.encodings = [{}]), i2.encodings[0].scaleResolutionDownBy = t2, e2.setParameters(i2);
        }
        updateSDP() {
          let { localDescription: e2 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (!this._parsedAnswer)
            return Promise.resolve();
          let t2 = YV(this._parsedAnswer);
          return this._updateSDPPromise = new Promise((i2, r2) => cb(this, null, function* () {
            var n2, o2;
            try {
              !e2 && this._peerConnection && (this._log.info("creating offer"), e2 = yield this._peerConnection.createOffer()), e2 && (yield this.setOffer(e2)), yield this.setAnswer({ type: "answer", sdp: t2 }), this._updateSDPPromise = null, i2();
            } catch (WU2) {
              this._log.error(WU2), !this._isSDPLogged && this._peerConnection && (this._log.warn("current offer: ".concat(this.filterSDPDirection(null == (n2 = this._peerConnection.localDescription) ? void 0 : n2.sdp), " \nnext offer: ").concat(this.filterSDPDirection(null == e2 ? void 0 : e2.sdp))), this._log.warn("current answer: ".concat(this.filterSDPDirection(null == (o2 = this._peerConnection.remoteDescription) ? void 0 : o2.sdp), " \nnext answer: ").concat(this.filterSDPDirection(t2))), this._log.warn("offer: ".concat(null == e2 ? void 0 : e2.sdp)), this._log.warn("answer: ".concat(t2)), this._log.warn("transceivers: ".concat(JSON.stringify(this._peerConnection.getTransceivers().map((e3) => {
                let { mid: t3, currentDirection: i3, direction: r3, stopped: n3 } = e3;
                return { mid: t3, currentDirection: i3, direction: r3, stopped: n3 };
              })))), this._log.warn("parsedAnswer: ".concat(JSON.stringify(this._parsedAnswer))), this._isSDPLogged = true), this._updateSDPPromise = null, r2(WU2);
            }
          })), this._updateSDPPromise;
        }
        filterSDPDirection() {
          return qV(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "").media.map((e2) => e2.direction);
        }
        setOffer(e2) {
          return this._log.info("setting offer"), this._peerConnection.setLocalDescription({ type: "offer", sdp: JU(e2.sdp) });
        }
        setAnswer(e2) {
          return this._log.info("setting answer"), this._room.enableHWEncoder && e2.sdp && (e2.sdp = e2.sdp.replaceAll("42e01f", "42001f")), this._peerConnection.setRemoteDescription(e2);
        }
        sendDataChannelMessage(e2) {
          var t2;
          null == (t2 = this._datachannel) || t2.send(e2);
        }
        reset() {
          var e2;
          null == (e2 = this._peerConnection) || e2.close(), this._waitForPCConnectedPromise = null, this._parsedAnswer = null;
        }
        close() {
          this._log.info("close pc"), this.seiCodec && (this.seiCodec.destroy(), this.seiCodec = null), this.reset(), this.emitConnectionStateChangedEvent("DISCONNECTED"), this._downlinkMIDMap.clear(), this.stopReconnection(), this.removeAllListeners();
        }
        sendSEI(e2, t2) {
          var i2;
          null == (i2 = this.seiCodec) || i2.push(e2, t2);
        }
      };
      ob([nL("reconnect")], ZU.prototype, "startReconnection", 1), ob([oL((e2) => e2.userId)], ZU.prototype, "addDownlink", 1), ob([oL((e2) => e2)], ZU.prototype, "removeDownlink", 1), ob([rL(true)], ZU.prototype, "updateSDP", 1);
      var eF = class {
        constructor(e2) {
          sb(this, "tag"), sb(this, "len"), sb(this, "data");
          let t2 = new DataView(e2);
          this.tag = t2.getUint16(), this.len = t2.getUint16(2), this.data = new Uint8Array(e2).slice(4, 4 + this.len).buffer;
        }
      }, tF = class {
        constructor(e2) {
          sb(this, "tinyId"), sb(this, "data");
          let t2 = new DataView(e2), i2 = 0, r2 = [];
          for (; i2 < t2.byteLength; ) {
            let n2 = t2.getUint16(i2 + 2), o2 = new eF(new Uint8Array(e2).slice(i2, i2 + 2 + 2 + n2).buffer);
            r2.push(o2), i2 += 4 + n2;
          }
          r2.forEach((e3) => {
            1 === e3.tag ? this.tinyId = new TextDecoder().decode(e3.data) : 2 === e3.tag && (this.data = e3.data);
          });
        }
      }, iF = /* @__PURE__ */ new Set();
      function rF() {
        let e2 = Math.floor(4294967296 * Math.random());
        return iF.has(e2) ? rF() : (iF.add(e2), e2);
      }
      var nF = nb(lb()), oF = class extends nF.default {
        constructor(e2) {
          super(), sb(this, "userId"), sb(this, "tinyId"), sb(this, "_sdpSemantics"), sb(this, "_isUplink"), sb(this, "_room"), sb(this, "_log"), sb(this, "_signalChannel"), sb(this, "_currentState", "DISCONNECTED"), sb(this, "_prevTime", -1), sb(this, "_enableSEI"), this.userId = e2.userId, this.tinyId = e2.tinyId, this._room = e2.room, this._sdpSemantics = e2.room.sdpSemantics, this._isUplink = e2.isUplink, this._log = EO.createLogger({ id: "n", userId: this._room.userId, remoteUserId: this._isUplink ? void 0 : this.userId, sdkAppId: this._room.sdkAppId, isLocal: this._isUplink }), this._signalChannel = e2.signalChannel, this._enableSEI = e2.enableSEI;
        }
        get _peerConnection() {
          var e2;
          return (null == (e2 = this.singlePC) ? void 0 : e2.getPeerConnection()) || null;
        }
        get singlePC() {
          return this._room.singlePC;
        }
        close(e2) {
          this._log.info("close connection"), this.emit("closed", e2);
        }
        emitConnectionStateChangedEvent(e2) {
          return e2 !== this._currentState && (ew.emit(gO.PEER_CONNECTION_STATE_CHANGED, { room: this._room, prevState: this._currentState, state: e2, remoteUserId: this._isUplink ? void 0 : this.userId }), this.emit("connection-state-changed", { prevState: this._currentState, state: e2 }), this._currentState = e2, true);
        }
        getPeerConnection() {
          return this._peerConnection;
        }
        getRoom() {
          return this._room;
        }
        getUserId() {
          return this.userId;
        }
        getTinyId() {
          return this.tinyId;
        }
        getCurrentState() {
          return this._currentState;
        }
        get isH264() {
          var e2, t2;
          return !(null == (t2 = null == (e2 = this._peerConnection) ? void 0 : e2.remoteDescription) || !t2.sdp.includes("H264"));
        }
      }, sF = class extends oF {
        constructor(e2) {
          super(tb(eb({}, e2), { isUplink: true })), sb(this, "localMainAudioTrack", null), sb(this, "localMainVideoTrack", null), sb(this, "localAuxAudioTrack", null), sb(this, "localAuxVideoTrack", null), sb(this, "_isPublishingAux", false), sb(this, "_publishingLocalAudioTrack"), sb(this, "_publishingLocalVideoTrack"), sb(this, "_mediaSettings", { videoCodec: "", videoWidth: 0, videoHeight: 0, videoBps: 0, videoFps: 0, audioCodec: "opus", audioFs: 0, audioChannel: 0, audioBps: 0, smallVideoWidth: 0, smallVideoHeight: 0, smallVideoFps: 0, smallVideoBps: 0, auxVideoWidth: 0, auxVideoHeight: 0, auxVideoFps: 0, auxVideoBps: 0 }), sb(this, "_flag", 0), sb(this, "_checkPublishStateTimeoutId", -1), this.initialize();
        }
        get ssrc() {
          if (!this.singlePC)
            return { audio: 0, video: 0, videoRtx: 0, small: 0, smallRtx: 0, auxiliary: 0, auxiliaryRtx: 0 };
          let { audioSsrc: e2, bigVideoSsrc: t2, bigVideoRtxSsrc: i2, smallVideoSsrc: r2, smallVideoRtxSsrc: n2, auxVideoSsrc: o2, auxVideoRtxSsrc: s2 } = this.singlePC.uplinkSSRC;
          return { audio: e2 || 0, video: t2 || 0, videoRtx: i2 || 0, small: r2 || 0, smallRtx: n2 || 0, auxiliary: o2 || 0, auxiliaryRtx: s2 || 0 };
        }
        get flag() {
          return this._flag;
        }
        set flag(e2) {
          this._flag !== e2 && (this._flag = e2, this.checkPublishState());
        }
        checkPublishState() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          if (!e2 && this._checkPublishStateTimeoutId > 0)
            return;
          let { publishState: t2, serverPublishState: i2 } = this, r2 = Object.keys(t2).find((e3) => t2[e3] !== i2[e3]);
          if (r2) {
            if (!e2)
              return void (this._checkPublishStateTimeoutId = yP.run(sN, () => this.checkPublishState(true), { delay: 1e4, count: 1 }));
            this._log.warn("publish state not matched, ".concat(r2, " local:").concat(t2[r2], " server:").concat(i2[r2], " ").concat(KD())), mM.addCount({ key: 521e3 });
          }
          yP.clearTask(this._checkPublishStateTimeoutId), this._checkPublishStateTimeoutId = -1;
        }
        get isMainStreamPublished() {
          return !(!this.localMainAudioTrack && !this.localMainVideoTrack);
        }
        get isAuxStreamPublished() {
          return !(!this.localAuxVideoTrack && !this.localAuxAudioTrack);
        }
        get publishState() {
          var e2, t2, i2, r2;
          let n2 = { audio: false, bigVideo: false, smallVideo: false, auxVideo: false };
          if (this._peerConnection) {
            let o2 = this._peerConnection.getSenders();
            o2 && (qO() ? (n2.audio = !(null == (e2 = o2[0]) || !e2.track), n2.bigVideo = !(null == (t2 = o2[1]) || !t2.track), n2.smallVideo = !(null == (i2 = o2[2]) || !i2.track), n2.auxVideo = !(null == (r2 = o2[3]) || !r2.track)) : o2.forEach((e3) => {
              e3.track && (e3.track.kind === ok.AUDIO ? n2.audio = true : (n2.bigVideo = true, this._room.videoManager.hasSmall && (n2.smallVideo = true)));
            }));
          }
          return n2;
        }
        get serverPublishState() {
          return { audio: !!(this.flag & hk), bigVideo: !!(this.flag & lk), smallVideo: !!(this.flag & dk), auxVideo: !!(this.flag & uk) };
        }
        get muteState() {
          var e2, t2, i2;
          return { audio: !(null == (e2 = this.localMainAudioTrack) || !e2.muted), bigVideo: !(null == (t2 = this.localMainVideoTrack) || !t2.muted), auxVideo: !(null == (i2 = this.localAuxVideoTrack) || !i2.muted) };
        }
        initialize() {
          this.installEvents();
        }
        reset() {
          this.uninstallEvents(), this.uninstallTrackMuteEvents(this.localMainAudioTrack, this.localMainVideoTrack, this.localAuxVideoTrack);
        }
        close(e2) {
          super.close(e2), this.reset(), this.emitConnectionStateChangedEvent("DISCONNECTED");
        }
        installEvents() {
          var e2;
          this.listeners("connection-state-changed").includes(this.handleConnectionStateChange) || this.on("connection-state-changed", this.handleConnectionStateChange, this), this.listeners("spc-reconnected").includes(this.onSinglePCReconnected) || null == (e2 = this.singlePC) || e2.on("spc-reconnected", this.onSinglePCReconnected, this);
        }
        uninstallEvents() {
          var e2;
          this.off("connection-state-changed", this.handleConnectionStateChange, this), null == (e2 = this.singlePC) || e2.off("spc-reconnected", this.onSinglePCReconnected, this);
        }
        emitConnectionStateChangedEvent(e2, t2) {
          var i2, r2, n2;
          let o2 = this._currentState, s2 = super.emitConnectionStateChangedEvent(e2);
          return s2 && o2 !== e2 && (t2 ? t2.emit("connection-state-changed", { prevState: o2, state: e2 }) : (null == (i2 = this.localMainVideoTrack) || i2.emit("connection-state-changed", { prevState: o2, state: e2 }), null == (r2 = this.localAuxVideoTrack) || r2.emit("connection-state-changed", { prevState: o2, state: e2 }), null == (n2 = this._publishingLocalVideoTrack) || n2.emit("connection-state-changed", { prevState: o2, state: e2 }))), s2;
        }
        publish(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { localAudioTrack: i2, localVideoTrack: r2, isAuxiliary: n2 } = e3;
            return function* () {
              var e4, o2, s2, a2, c2, l2, d2;
              if (!t2.singlePC)
                return;
              yield t2.singlePC.waitForPeerConnectionConnected();
              let u2, { publishState: h2, muteState: p2 } = t2;
              if (i2 && (t2._publishingLocalAudioTrack = i2, h2.audio = true, p2.audio = i2.muted), r2) {
                if (!t2.singlePC.isH264EncodeSupported && !t2.singlePC.isVP8EncodeSupported)
                  throw new vb({ code: Sb.NOT_SUPPORTED_H264, message: XD({ key: uN.NOT_SUPPORTED_H264ENCODE }) });
                RN && 115 === yD() && r2.profile.width * r2.profile.height <= 230400 && (t2._log.warn("fallback video to 480p"), r2.setProfile(rk["480p_2"]), yield r2.applyProfile()), t2._publishingLocalVideoTrack = r2, n2 ? (h2.auxVideo = true, p2.auxVideo = r2.muted) : (h2.bigVideo = true, p2.bigVideo = r2.muted);
              }
              if (t2._isPublishingAux = n2, r2 && !n2 && r2.small && (u2 = t2._room.videoManager.smallTrack, h2.smallVideo = true), yield t2._signalChannel.sendWaitForResponseWithRetry({ command: wV, responseCommand: cV.SPC_PUBLISH_RESULT, data: tb(eb({}, t2.singlePC.uplinkSSRC), { state: h2, muteState: p2 }), retries: 3 }), yield t2.publishByTransceiver({ localAudioTrack: i2, localVideoTrack: r2, smallTrack: u2, isAuxiliary: n2 }), null == (e4 = t2.singlePC.seiCodec) || e4.handleEncodedStreams(), t2._publishingLocalAudioTrack = null, t2._publishingLocalVideoTrack = null, t2._isPublishingAux = false, n2)
                r2 && (t2.localAuxVideoTrack = r2), i2 && (t2.localAuxAudioTrack = i2);
              else {
                if (r2) {
                  t2.localMainVideoTrack = r2;
                  let { scaleResolutionDownBy: e5 } = r2;
                  e5 > 1 && (t2._log.warn("setScaleResolutionDownBy main ".concat(e5)), yield t2.singlePC.setScaleResolutionDownBy(t2._peerConnection.getSenders()[1], e5));
                }
                i2 && (t2.localMainAudioTrack = i2);
              }
              yield t2.singlePC.setBandwidth({ audio: (null == (o2 = t2.localMainAudioTrack) ? void 0 : o2.profile.bitrate) || (null == (s2 = t2.localAuxAudioTrack) ? void 0 : s2.profile.bitrate), bigVideo: null == (a2 = t2.localMainVideoTrack) ? void 0 : a2.profile.bitrate, smallVideo: null == (l2 = null == (c2 = t2.localMainVideoTrack) ? void 0 : c2.small) ? void 0 : l2.bitrate, auxVideo: null == (d2 = t2.localAuxVideoTrack) ? void 0 : d2.profile.bitrate }), t2.sendMediaSettings(), t2.installTrackMuteEvents(i2, r2);
            }();
          });
        }
        publishByTransceiver(e2) {
          let { localAudioTrack: t2, localVideoTrack: i2, smallTrack: r2, isAuxiliary: n2 } = e2;
          if (!YO())
            return;
          this._log.info("publish by transceiver");
          let o2 = null == i2 ? void 0 : i2.outMediaTrack, s2 = null == t2 ? void 0 : t2.outMediaTrack, a2 = this._peerConnection.getTransceivers(), c2 = [], l2 = [];
          if (s2) {
            let e3 = a2[0].sender.replaceTrack(s2);
            l2.push(0), c2.push(e3);
          }
          if (o2)
            if (n2) {
              let e3 = a2[3].sender.replaceTrack(o2);
              l2.push(3), c2.push(e3);
            } else {
              let e3 = a2[1].sender.replaceTrack(o2);
              l2.push(1), c2.push(e3);
            }
          if (r2) {
            let e3 = a2[2].sender.replaceTrack(r2);
            l2.push(2), c2.push(e3);
          }
          let d2 = this.setTransceiverDirection(sk.SENDONLY, l2);
          return c2.push(d2), Promise.all(c2);
        }
        enableSmall(e2) {
          return cb(this, null, function* () {
            if (!this.singlePC)
              return;
            let t2 = this._peerConnection.getTransceivers();
            e2 ? this._room.videoManager.smallTrack && (yield t2[2].sender.replaceTrack(this._room.videoManager.smallTrack), yield this.setTransceiverDirection(sk.SENDONLY, [2])) : (yield t2[2].sender.replaceTrack(null), yield this.setTransceiverDirection(sk.INACTIVE, [2])), this.updateMediaSettings(), yield this.doPublishChange();
          });
        }
        installTrackMuteEvents() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          t2.forEach((e3) => {
            e3 && (null == e3 || e3.on("mute", this.sendMutedFlag, this), null == e3 || e3.on("unmute", this.sendMutedFlag, this));
          });
        }
        uninstallTrackMuteEvents() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          t2.forEach((e3) => {
            e3 && (null == e3 || e3.off("mute", this.sendMutedFlag, this), null == e3 || e3.off("unmute", this.sendMutedFlag, this));
          });
        }
        unpublish(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { localAudioTrack: i2, localVideoTrack: r2 } = e3;
            return function* () {
              let e4 = r2 && r2 === t2.localAuxVideoTrack, n2 = null == r2 ? void 0 : r2.outMediaTrack, o2 = t2._peerConnection.getSenders(), s2 = [];
              i2 && (yield o2[0].replaceTrack(null), s2.push(0), e4 ? t2.localAuxAudioTrack = null : t2.localMainAudioTrack = null), n2 && (e4 ? (yield o2[3].replaceTrack(null), t2.localAuxVideoTrack = null, t2._mediaSettings = tb(eb({}, t2._mediaSettings), { auxVideoBps: 0, auxVideoFps: 0, auxVideoWidth: 0, auxVideoHeight: 0 }), s2.push(3)) : (yield o2[1].replaceTrack(null), yield o2[2].replaceTrack(null), t2.localMainVideoTrack = null, t2._mediaSettings = tb(eb({}, t2._mediaSettings), { videoWidth: 0, videoHeight: 0, videoBps: 0, videoFps: 0, audioFs: 0, audioChannel: 0, audioBps: 0, smallVideoWidth: 0, smallVideoHeight: 0, smallVideoFps: 0, smallVideoBps: 0 }), s2.push(1, 2))), t2.isMainStreamPublished || t2.isAuxStreamPublished ? (yield t2.setTransceiverDirection(sk.INACTIVE, s2), yield t2.doPublishChange(false)) : yield t2.doUnpublish(), t2.uninstallTrackMuteEvents(i2, r2), null == r2 || r2.emit("connection-state-changed", { prevState: t2._currentState, state: "DISCONNECTED" });
            }();
          });
        }
        doPublishChange() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          return cb(this, null, function* () {
            let t2 = { state: this.publishState, constraintConfig: this._mediaSettings }, i2 = yield this._signalChannel.sendWaitForResponseWithRetry({ command: _V, data: t2, responseCommand: cV.PUBLISH_STATE_CHANGE_RESULT, enableLog: e2, retries: 3 });
            this.checkPublishResultCode(i2.data.code, i2.data.message);
          });
        }
        doUnpublish() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          return this._signalChannel.sendWaitForResponse({ command: fV, commandDesc: "unpublish", responseCommand: cV.UNPUBLISH_RESULT, enableLog: e2 }).catch((e3) => {
            if (e3.getCode() === Sb.API_CALL_TIMEOUT)
              return Promise.resolve();
            throw e3;
          });
        }
        updateMediaSettings() {
          let { detail: { isH264EncodeSupported: e2, isVp8EncodeSupported: t2 } } = this._room.checkSystemResult;
          e2 ? this._mediaSettings.videoCodec = "H264" : t2 && (this._mediaSettings.videoCodec = "VP8");
          let i2 = this._publishingLocalAudioTrack || this.localMainAudioTrack || this.localAuxAudioTrack, { localMainVideoTrack: r2, localAuxVideoTrack: n2 } = this;
          if (this._publishingLocalVideoTrack && (this._isPublishingAux ? n2 = this._publishingLocalVideoTrack : r2 = this._publishingLocalVideoTrack), eP) {
            if (i2 && i2.outMediaTrack) {
              let e3 = i2.outMediaTrack.getSettings();
              this._mediaSettings.audioChannel = e3.channelCount || 1, this._mediaSettings.audioBps = 1e3 * i2.profile.bitrate, this._mediaSettings.audioFs = e3.sampleRate || 0;
            }
            if (r2 && r2.outMediaTrack) {
              let e3 = r2.outMediaTrack.getSettings();
              this._mediaSettings.videoWidth = e3.width || 0, this._mediaSettings.videoHeight = e3.height || 0, this._mediaSettings.videoFps = e3.frameRate || 0, this._mediaSettings.videoBps = 1e3 * r2.profile.bitrate, r2.small && (this._mediaSettings.smallVideoWidth = r2.small.width, this._mediaSettings.smallVideoHeight = r2.small.height, this._mediaSettings.smallVideoFps = r2.small.frameRate, this._mediaSettings.smallVideoBps = 1e3 * r2.small.bitrate);
            }
            if (n2 && n2.outMediaTrack) {
              let e3 = n2.outMediaTrack.getSettings();
              this._mediaSettings.auxVideoWidth = e3.width || 0, this._mediaSettings.auxVideoHeight = e3.height || 0, this._mediaSettings.auxVideoFps = e3.frameRate || 0, this._mediaSettings.auxVideoBps = 1e3 * n2.profile.bitrate;
            }
          } else
            i2 && i2.outMediaTrack && (this._mediaSettings.audioChannel = i2.profile.channelCount, this._mediaSettings.audioBps = 1e3 * i2.profile.bitrate, this._mediaSettings.audioFs = i2.profile.sampleRate), r2 && r2.outMediaTrack && (this._mediaSettings.videoWidth = r2.profile.width, this._mediaSettings.videoHeight = r2.profile.height, this._mediaSettings.videoFps = r2.profile.frameRate, this._mediaSettings.videoBps = 1e3 * r2.profile.bitrate);
          this._log.info("updateMediaSettings: ".concat(JSON.stringify(this._mediaSettings)));
        }
        sendMediaSettings() {
          this.updateMediaSettings(), this._signalChannel.sendWaitForResponse({ command: kV, data: this._mediaSettings, responseCommand: cV.UPDATE_CONSTRAINT_CONFIG_RES }).then((e2) => {
            0 !== e2.data.code && this._log.warn(e2.data.message);
          }).catch(() => {
          });
        }
        addTrack(e2) {
          return cb(this, null, function* () {
            if (!this._peerConnection)
              return;
            let t2 = e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack;
            this._log.info("is adding ".concat(e2.kind, " track to current published local ").concat(t2 ? ok.AUXILIARY : ok.MAIN, " stream")), qO() && (yield this.addTrackByTransceiver(e2, t2));
          });
        }
        addTrackByTransceiver(e2, t2) {
          return cb(this, null, function* () {
            var i2;
            if (!e2.mediaTrack)
              return;
            let r2 = this._peerConnection.getTransceivers();
            if (e2.kind === ok.AUDIO)
              yield r2[0].sender.replaceTrack(e2.outMediaTrack);
            else {
              let n2 = t2 ? 3 : 1;
              yield r2[n2].sender.replaceTrack(e2.outMediaTrack), 1 === n2 && (null == (i2 = this.localMainVideoTrack) ? void 0 : i2.small) && (yield r2[2].sender.replaceTrack(this._room.videoManager.smallTrack)), r2[n2].direction === sk.INACTIVE && (yield this.setTransceiverDirection(sk.SENDONLY, [n2]));
            }
            this.updateMediaSettings(), yield this.doPublishChange();
          });
        }
        removeTrack(e2) {
          return cb(this, null, function* () {
            if (!this._peerConnection)
              return;
            let t2 = e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack;
            this._log.info("is removing ".concat(e2.kind, " track from current published local ").concat(t2 ? ok.AUXILIARY : ok.MAIN, " stream")), qO() && (yield this.removeTrackByTransceiver(e2, t2));
          });
        }
        removeTrackByTransceiver(e2, t2) {
          return cb(this, null, function* () {
            if (!e2.mediaTrack)
              return;
            let i2 = this._peerConnection.getTransceivers();
            if (e2.kind === ok.AUDIO)
              yield i2[0].sender.replaceTrack(null);
            else {
              let e3 = t2 ? 3 : 1;
              yield i2[e3].sender.replaceTrack(null), 1 === e3 && this._room.videoManager.hasSmall && (yield i2[2].sender.replaceTrack(null)), yield this.setTransceiverDirection(sk.INACTIVE, [e3]);
            }
            this.updateMediaSettings(), yield this.doPublishChange();
          });
        }
        setTransceiverDirection(e2, t2) {
          return cb(this, null, function* () {
            if (!NN)
              return;
            let i2 = false, r2 = false;
            this._log.info("setting transceiver ".concat(t2.join(","), " direction to ").concat(e2));
            let n2 = this._peerConnection.getTransceivers();
            if (t2.forEach((t3) => {
              n2[t3].direction !== e2 && (n2[t3].direction = e2, i2 = true);
            }), i2) {
              this._log.info("updating offer");
              let e3 = yield this._peerConnection.createOffer();
              yield this._peerConnection.setLocalDescription(e3);
            }
            let o2 = -1, s2 = this._peerConnection.remoteDescription.sdp.split("\r\n").map((i3) => {
              if (i3.match(new RegExp("a=(".concat(sk.INACTIVE, "|").concat(sk.RECVONLY, "|").concat(sk.SENDONLY, ")"))) && o2++, t2.includes(o2)) {
                if (e2 === sk.INACTIVE && i3.includes("a=".concat(sk.RECVONLY)))
                  return r2 = true, "a=".concat(e2);
                if (e2 === sk.SENDONLY && i3.includes("a=".concat(sk.INACTIVE)))
                  return r2 = true, "a=".concat(sk.RECVONLY);
              }
              return i3;
            }).join("\r\n");
            r2 && (this._log.info("updating answer"), yield this._peerConnection.setRemoteDescription({ type: "answer", sdp: s2 }));
          });
        }
        replaceTrack(e2) {
          return cb(this, null, function* () {
            var t2;
            let i2 = null == (t2 = this._peerConnection) ? void 0 : t2.getSenders(), r2 = e2.outMediaTrack || e2.mediaTrack;
            if (!i2 || 0 === i2.length || !r2 || i2.find((e3) => e3.track === r2))
              return;
            let n2 = e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack;
            this._log.info("is replacing ".concat(r2.kind, " track on ").concat(n2 ? ok.AUXILIARY : ok.MAIN, " stream")), r2.kind === ok.AUDIO && i2[0] && (yield i2[0].replaceTrack(r2)), r2.kind === ok.VIDEO && (!n2 && i2[1] && (yield i2[1].replaceTrack(r2)), n2 && i2[3] && (yield i2[3].replaceTrack(r2)));
          });
        }
        setBandwidth(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { bandwidth: i2, type: r2, videoType: n2 } = e3;
            return function* () {
              if (t2.singlePC) {
                let e4 = {};
                r2 === ok.AUDIO ? e4.audio = i2 : "big" === n2 ? e4.bigVideo = i2 : "small" === n2 ? e4.smallVideo = i2 : e4.auxVideo = i2, yield t2.singlePC.setBandwidth(e4);
              }
            }();
          });
        }
        sendMutedFlag(e2) {
          e2 === this.localAuxAudioTrack || e2 === this.localAuxVideoTrack || (this._log.info("send muted state: ".concat(JSON.stringify(this.muteState))), this._signalChannel.sendWaitForResponseWithRetry({ command: pV, responseCommand: cV.MUTE_RESULT, data: this.muteState, retries: 3 }).catch(() => {
          }));
        }
        handleConnectionStateChange(e2) {
          "CONNECTED" === e2.state && (this.localMainVideoTrack || this._publishingLocalVideoTrack && !this._isPublishingAux) && ew.emit(gO.SEND_FIRST_VIDEO_FRAME, { room: this._room });
        }
        getVideoTrackId() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ok.VIDEO;
          if (this._peerConnection) {
            let t2 = this._peerConnection.getSenders();
            if (e2 === ok.AUXILIARY && t2[3] && t2[3].track)
              return t2[3].track.id;
            if (e2 === ok.VIDEO && t2[1] && t2[1].track)
              return t2[1].track.id;
          }
          if (this.localMainVideoTrack && e2 === ok.VIDEO) {
            let e3 = this.localMainVideoTrack.mediaTrack;
            if (e3)
              return e3.id;
          }
          if (this.localAuxVideoTrack && e2 === ok.AUXILIARY) {
            let e3 = this.localAuxVideoTrack.mediaTrack;
            if (e3)
              return e3.id;
          }
          return "";
        }
        getSSRC() {
          return this.ssrc;
        }
        checkPublishResultCode(e2, t2) {
          if (0 !== e2)
            throw e2 === Fk ? (this._log.error(hN.NOT_SUPPORTED_H264ENCODE), new vb({ code: Sb.NOT_SUPPORTED_H264, message: XD({ key: uN.NOT_SUPPORTED_H264ENCODE }) })) : new vb({ code: Sb.UNKNOWN, message: XD({ key: uN.SIGNAL_RESPONSE_FAILED, data: { signalResponse: cV.PUBLISH_RESULT, code: e2, message: t2 } }) });
        }
        onSinglePCReconnected() {
          return cb(this, null, function* () {
            this.isMainStreamPublished && (this._log.warn("republish main stream"), yield this.publish({ localAudioTrack: this.localMainAudioTrack, localVideoTrack: this.localMainVideoTrack, isAuxiliary: false })), this.isAuxStreamPublished && (this._log.warn("republish aux stream"), yield this.publish({ localAudioTrack: this.localAuxAudioTrack, localVideoTrack: this.localAuxVideoTrack, isAuxiliary: true }));
          });
        }
      };
      function aF(e2) {
        return Object.keys(e2).filter((t2) => e2[t2]);
      }
      var cF = class extends oF {
        constructor(e2) {
          super(tb(eb({}, e2), { isUplink: false })), sb(this, "_flag", 0), sb(this, "role", "anchor"), sb(this, "remoteAudioTrack"), sb(this, "remoteVideoTrack"), sb(this, "remoteAuxiliaryTrack"), sb(this, "ssrc", { audio: 0, video: 0, videoRtx: 0, auxiliary: 0, auxiliaryRtx: 0 }), this.flag = e2.flag, this.remoteAudioTrack = new EL(this._room, this), this.remoteVideoTrack = new SL(this._room, this), this.remoteAuxiliaryTrack = new IL(this._room, this), this.initialize();
        }
        get subscribeState() {
          return { audio: this.remoteAudioTrack.isSubscribed || this.remoteAudioTrack.isSubscribing, video: this.remoteVideoTrack.isBig && (this.remoteVideoTrack.isSubscribed || this.remoteVideoTrack.isSubscribing), smallVideo: this.remoteVideoTrack.isSmall && (this.remoteVideoTrack.isSubscribed || this.remoteVideoTrack.isSubscribing), auxiliary: this.remoteAuxiliaryTrack.isSubscribed || this.remoteAuxiliaryTrack.isSubscribing };
        }
        get muteState() {
          return $w(this.flag, this.userId);
        }
        get flag() {
          return this._flag;
        }
        set flag(e2) {
          var t2, i2, r2;
          e2 !== this._flag && (this._flag = e2, null == (t2 = this.remoteAudioTrack) || t2.onFlagChanged(), null == (i2 = this.remoteVideoTrack) || i2.onFlagChanged(), null == (r2 = this.remoteAuxiliaryTrack) || r2.onFlagChanged());
        }
        get hasMainStream() {
          return this.muteState.hasAudio || this.muteState.hasVideo || this.muteState.hasSmall;
        }
        get hasAuxStream() {
          return this.muteState.hasAuxiliary;
        }
        get isMainStreamSubscribed() {
          return (this.subscribeState.audio || this.subscribeState.video || this.subscribeState.smallVideo) && (this.muteState.hasAudio || this.muteState.hasVideo || this.muteState.hasSmall);
        }
        get isAuxStreamSubscribed() {
          return this.subscribeState.auxiliary && this.muteState.hasAuxiliary;
        }
        get isSmallStreamSubscribed() {
          return this.subscribeState.smallVideo && this.muteState.hasSmall;
        }
        get isBigStreamSubscribed() {
          return this.subscribeState.video && this.muteState.hasVideo;
        }
        isStreamUnpublished(e2) {
          return e2 === ok.MAIN ? !this.muteState.hasAudio && !this.muteState.hasVideo : !this.muteState.hasAuxiliary;
        }
        initialize() {
          this.installEvents();
        }
        close(e2) {
          super.close(e2), this.emitConnectionStateChangedEvent("DISCONNECTED"), this.remoteAudioTrack.close(), this.remoteVideoTrack.close(), this.remoteAuxiliaryTrack.close(), this.uninstallEvents(), this.removeDownlink();
        }
        installEvents() {
          !this.singlePC || (this.listeners("track").includes(this.onTrack) || this.singlePC.on("track", this.onTrack, this), this.listeners("spc-reconnected").includes(this.onSinglePCReconnected) || this.singlePC.on("spc-reconnected", this.onSinglePCReconnected, this));
        }
        uninstallEvents() {
          !this.singlePC || (this.singlePC.off("track", this.onTrack, this), this.singlePC.off("spc-reconnected", this.onSinglePCReconnected, this));
        }
        emitConnectionStateChangedEvent(e2) {
          var t2, i2;
          let r2 = this._currentState, n2 = super.emitConnectionStateChangedEvent(e2);
          return n2 && r2 !== e2 && (null == (t2 = this.remoteVideoTrack) || t2.emit("connection-state-changed", { prevState: r2, state: e2 }), null == (i2 = this.remoteAuxiliaryTrack) || i2.emit("connection-state-changed", { prevState: r2, state: e2 })), n2;
        }
        onTrack(e2) {
          let t2 = e2.streams[0], { track: i2 } = e2;
          if (!t2.id.includes(this.tinyId))
            return;
          let r2 = t2.id.includes("aux") ? "auxiliary" : "main";
          this._log.debug("ontrack ".concat(r2, " ").concat(i2.kind));
          let n2 = ok.AUDIO;
          i2.kind === ok.VIDEO && (n2 = r2 === ok.MAIN ? ok.VIDEO : ok.AUXILIARY);
          let o2 = this.remoteAudioTrack;
          n2 === ok.VIDEO ? o2 = this.remoteVideoTrack : n2 === ok.AUXILIARY && (o2 = this.remoteAuxiliaryTrack), o2.setInputMediaStreamTrack(i2);
        }
        isSubscriptionStateNotChanged(e2) {
          return JSON.stringify(e2) === JSON.stringify(this.subscribeState);
        }
        subscribe(e2, t2) {
          return cb(this, null, function* () {
            try {
              if (this.isSubscriptionStateNotChanged(e2))
                return;
              if (this._log.info("subscribe ".concat(t2, " ").concat(aF(e2))), this.hasSSRC) {
                let t3 = "subscribe_change";
                Object.values(e2).find((e3) => true === e3) || (t3 = "unsubscribe"), yield this.sendSubscription(t3, e2);
              } else
                yield this.doSubscribe(e2), this.checkTrackEnded(e2);
            } catch (Ob2) {
              throw this._room.isJoined && this.isStreamUnpublished(t2) ? (this._log.warn("".concat(Ob2.message, " ").concat(JSON.stringify(this.muteState))), new vb({ code: Sb.REMOTE_STREAM_NOT_EXIST, message: "remote user ".concat(this.userId, " unpublished stream") })) : Ob2;
            }
          });
        }
        checkTrackEnded(e2) {
          var t2, i2, r2;
          (e2.audio && "ended" === (null == (t2 = this.remoteAudioTrack.mediaTrack) ? void 0 : t2.readyState) || e2.video && "ended" === (null == (i2 = this.remoteVideoTrack.mediaTrack) ? void 0 : i2.readyState) || e2.auxiliary && "ended" === (null == (r2 = this.remoteAuxiliaryTrack.mediaTrack) ? void 0 : r2.readState)) && this.singlePC && !this.singlePC.isReconnecting && (this._log.warn("remote track ended start spc reconnect"), this.singlePC.startReconnection());
        }
        unsubscribe(e2) {
          return cb(this, arguments, function(e3) {
            var t2 = this;
            let { remoteTracks: i2, streamType: r2 } = e3;
            return function* () {
              var e4;
              if ("main" === r2 && !t2.isMainStreamSubscribed || "auxiliary" === r2 && !t2.isAuxStreamSubscribed)
                return void t2._log.info("".concat(r2, " stream already unsubscribed"));
              let n2 = eb({}, t2.subscribeState);
              i2.forEach((e5) => {
                switch (e5.mediaType) {
                  case 1:
                    n2.audio = false;
                    break;
                  case 4:
                    n2.video = false;
                    break;
                  case 8:
                    n2.smallVideo = false;
                    break;
                  case 2:
                    n2.auxiliary = false;
                }
              });
              let o2 = "subscribe_change";
              Object.values(n2).find((e5) => true === e5) || (o2 = "unsubscribe"), t2._log.info("".concat("unsubscribe" === o2 ? o2 : "subscribe", " ").concat(r2, " [").concat(aF(n2), "]")), "unsubscribe" === o2 && (null == (e4 = t2.singlePC) || e4.removeDownlinkQueue.add(t2.tinyId)), yield t2.sendSubscription(o2, n2), "unsubscribe" === o2 && (yield t2.removeDownlink());
            }();
          });
        }
        sendSubscription(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.subscribeState, i2 = { srcTinyId: this.tinyId, srcUserId: this.userId }, r2 = TV, n2 = cV.UNSUBSCRIBE_RESULT;
          return "subscribe_change" === e2 && (i2 = { audio: t2.audio, bigVideo: t2.video, auxVideo: t2.auxiliary, smallVideo: t2.smallVideo, srcTinyId: this.tinyId }, r2 = EV, n2 = cV.SUBSCRIBE_CHANGE_RESULT), this._signalChannel.sendWaitForResponseWithRetry({ command: r2, data: i2, responseCommand: n2, timeout: 1e4, retries: 3 }).then((t3) => {
            let { data: i3 } = t3;
            if (0 !== i3.code) {
              let t4 = new vb({ code: i3.code, message: XD({ key: uN.ERROR_MESSAGE, data: { type: e2, message: i3.message } }) });
              throw this._log.error(t4), t4;
            }
          });
        }
        getMainStreamVideoTrackId() {
          return this.remoteVideoTrack && this.remoteVideoTrack.mediaTrack ? this.remoteVideoTrack.mediaTrack.id : "";
        }
        getAuxStreamVideoTrackId() {
          return this.remoteAuxiliaryTrack && this.remoteAuxiliaryTrack.mediaTrack ? this.remoteAuxiliaryTrack.mediaTrack.id : "";
        }
        setDelay(e2) {
          let { audioDelay: t2, videoDelay: i2 } = e2;
          this.remoteAudioTrack.stat.end2EndDelay = t2, this.remoteVideoTrack.stat.end2EndDelay = i2;
        }
        onSinglePCReconnected() {
          (this.ssrc.audio || this.ssrc.video || this.ssrc.auxiliary) && (this._log.warn("resubscribe ".concat(JSON.stringify(this.subscribeState))), this.doSubscribe(this.subscribeState));
        }
        get hasSSRC() {
          return this.ssrc.audio && this.ssrc.video && this.ssrc.auxiliary;
        }
        doSubscribe() {
          return cb(this, arguments, function() {
            var e2 = this;
            let t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.subscribeState, i2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            return function* () {
              if (e2.singlePC) {
                if (e2.singlePC.addDownlinkQueue.add(e2.tinyId), yield e2.singlePC.waitForPeerConnectionConnected(), i2 || !e2.hasSSRC) {
                  let i3 = { audioSsrc: rF(), bigVideoSsrc: rF(), bigVideoRtxSsrc: rF(), auxVideoSsrc: rF(), auxVideoRtxSsrc: rF() }, { audioSsrc: n2, bigVideoSsrc: o2, bigVideoRtxSsrc: s2, auxVideoSsrc: a2, auxVideoRtxSsrc: c2 } = i3;
                  e2.ssrc = { audio: n2, video: o2, videoRtx: s2, auxiliary: a2, auxiliaryRtx: c2 }, e2.singlePC.addDownlinkQueue.delete(e2.tinyId), yield e2.singlePC.addDownlink({ userId: e2.userId, tinyId: e2.tinyId, ssrc: e2.ssrc });
                  try {
                    let r2 = yield e2._signalChannel.sendWaitForResponseWithRetry({ command: OV, responseCommand: cV.SPC_SUBSCRIBE_RESULT, data: { srcUserId: e2.userId, srcTinyId: e2.tinyId, audio: t2.audio, bigVideo: t2.video, auxVideo: t2.auxiliary, smallVideo: t2.smallVideo, customData: false, ssrc: i3 }, retries: 3, retryTimeout: 0 });
                    if (0 !== r2.data.code)
                      throw new vb({ code: r2.data.code, message: r2.data.message });
                  } catch (r2) {
                    throw yield e2.removeDownlink(), r2;
                  }
                  return;
                }
                e2.singlePC.addDownlinkQueue.delete(e2.tinyId), yield e2.singlePC.addDownlink({ userId: e2.userId, tinyId: e2.tinyId, ssrc: e2.ssrc });
              }
            }();
          });
        }
        removeDownlink() {
          return cb(this, null, function* () {
            !this.singlePC || (this.ssrc = { audio: 0, video: 0, videoRtx: 0, auxiliary: 0, auxiliaryRtx: 0 }, this.singlePC.removeDownlinkQueue.delete(this.tinyId), yield this.singlePC.removeDownlink(this.userId));
          });
        }
      };
      ob([rL(), XM((e2) => function() {
        for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
          i2[r2] = arguments[r2];
        return new Promise((t3, r3) => {
          let n2 = (e3) => {
            this.off("closed", n2), r3(new vb({ code: Sb.API_CALL_ABORTED, message: XD({ key: uN.CONNECTION_ABORTED, data: e3 }) }));
          };
          this.on("closed", n2), e2.apply(this, i2).then(t3, r3).finally(() => {
            this.off("closed", n2);
          });
        });
      })], cF.prototype, "subscribe", 1), ob([rL()], cF.prototype, "unsubscribe", 1);
      var lF = cF;
      var dF = nb(lb());
      var uF = class extends dF.EventEmitter {
        constructor(e2, t2) {
          super(), this.room = e2, this.signalChannel = t2, sb(this, "log"), sb(this, "cmdIdSeqMap", /* @__PURE__ */ new Map()), sb(this, "messageMap", /* @__PURE__ */ new Map()), this.log = EO.createLogger({ id: "cmm", userId: e2.userId }), this.onReceiveMsg = this.onReceiveMsg.bind(this), t2.on(cV.RECEIVE_CUSTOM_MSG, this.onReceiveMsg);
        }
        send(e2) {
          let { cmdId: t2, data: i2 } = e2, r2 = this.cmdIdSeqMap.get(t2) || Math.floor(16383 * Math.random()), n2 = { cmdId: t2, msg: btoa(String.fromCharCode(...new Uint8Array(i2))), ordered: true, reliable: true, streamSeq: r2 };
          this.cmdIdSeqMap.set(t2, r2 + 1), this.signalChannel.send(LV, n2);
        }
        onReceiveMsg(e2) {
          let { data: t2 } = e2.data, i2 = this.room.tinyIdToUserIdMap.get(t2.srcTinyId);
          if (i2) {
            let e3 = { userId: i2, cmdId: t2.cmdId, seq: t2.streamSeq, data: Uint8Array.from(atob(t2.msg), (e4) => e4.charCodeAt(0)).buffer };
            if (t2.ordered) {
              let t3 = "".concat(i2, "_").concat(e3.cmdId), r2 = this.messageMap.get(t3);
              if (!r2 || Math.abs(r2.lastSeq - e3.seq) > uF.SEQ_INTERVAL)
                this.messageMap.set(t3, { lastSeq: e3.seq, cachedMessageMap: /* @__PURE__ */ new Map() }), this.emitMessage(e3);
              else if (e3.seq > r2.lastSeq) {
                if (e3.seq === r2.lastSeq + 1)
                  this.emitMessage(e3);
                else if (!r2.cachedMessageMap.has(e3.seq)) {
                  let t4 = setTimeout(() => this.emitMessage(e3, true), 5e3);
                  r2.cachedMessageMap.set(e3.seq, { message: e3, timeoutId: t4 });
                }
              } else
                this.log.debug("drop message ".concat(e3.userId, "-").concat(e3.cmdId, "-").concat(e3.seq));
            } else
              this.emit("message", e3);
          }
        }
        emitMessage(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          var i2;
          let r2 = this.messageMap.get("".concat(e2.userId, "_").concat(e2.cmdId)), n2 = e2;
          if (r2) {
            if (t2) {
              let e3 = [...r2.cachedMessageMap.values()].sort((e4, t3) => e4.message.seq - t3.message.seq);
              e3[0] && (n2 = e3[0].message);
            }
            n2.seq - r2.lastSeq > 1 && this.log.debug("msg lost userId: ".concat(n2.userId, " seq: ").concat(r2.lastSeq, " -> ").concat(n2.seq)), r2.lastSeq = n2.seq, clearTimeout(null == (i2 = r2.cachedMessageMap.get(n2.seq)) ? void 0 : i2.timeoutId), r2.cachedMessageMap.delete(n2.seq);
          }
          this.emit("message", n2);
          let o2 = null == r2 ? void 0 : r2.cachedMessageMap.get(n2.seq + 1);
          o2 && this.emitMessage(o2.message);
        }
      }, hF = uF;
      sb(hF, "SEQ_INTERVAL", 300);
      var pF, { isString: mF, isUndefined: _F, getNetworkType: fF, isEmpty: gF } = Cb, TF = class extends UU {
        constructor(e2) {
          super(e2), this._heartbeat = -1, this._lastHeartBeatTime = -1, this._joinTimeout = -1, this._firstPublishedList = null, this._joinReject = null, this._isRelayChanged = false, this._signalChannel = null, this.uplinkConnection = null, this.singlePC = null, this.enableSPC = QO, this._changeBigSmallRecords = /* @__PURE__ */ new Map(), this._networkQuality = null, this._turnServers = [], this._syncUserListInterval = -1, this._smallStreamConfig = { bitrate: 100, frameRate: 15, height: 120, width: 160 }, this.enableSEI = false, this._enableAudioVolumeEvaluation = false, this._audioVolumeIntervalId = 0, this._enableMultiAuxStream = false, this._pureAudioPushMode = false, this.enableHWEncoder = false, this._stats = new nU(this, this._log), this.userManager = new UL(this.userId, this._log), this._version = Nb, this.sdpSemantics = Uk, _F(e2.sdpSemantics) ? vO.isUnifiedPlanDefault() && (this.sdpSemantics = Vk) : this.sdpSemantics = e2.sdpSemantics, this._log.info("sdpSemantics: ".concat(this.sdpSemantics, ", netType: ").concat(fF())), e2.iceTransportPolicy && (this._iceTransportPolicy = e2.iceTransportPolicy), this._enableMultiAuxStream = !_F(e2.enableMultiAuxStream) && e2.enableMultiAuxStream, this.enableSEI = e2.enableSEI, !_F(e2.enableSPC) && QO && (this.enableSPC = e2.enableSPC), this.enableHWEncoder = e2.enableHWEncoder || false, this._initBusinessInfo(e2);
        }
        get isMainStreamPublished() {
          var e2;
          return !(null == (e2 = this.uplinkConnection) || !e2.isMainStreamPublished);
        }
        get isMainAudioPublished() {
          var e2;
          return !(null == (e2 = this.uplinkConnection) || !e2.localMainAudioTrack);
        }
        get isAuxStreamPublished() {
          var e2;
          return !(null == (e2 = this.uplinkConnection) || !e2.isAuxStreamPublished);
        }
        get hasAuxStream() {
          return [...this.remotePublishedUserMap.values()].findIndex((e2) => e2.muteState.hasAuxiliary) >= 0;
        }
        get userMap() {
          return this.userManager.userMap;
        }
        get remotePublishedUserMap() {
          return this.userManager.remotePublishedUserMap;
        }
        get tinyIdToUserIdMap() {
          return new Map([...this.userMap.values()].map((e2) => [e2.tinyId, e2.userId]));
        }
        join(e2, t2, i2) {
          return cb(this, null, function* () {
            return this.userManager.mySelfId = this.userId, this.userManager.on("1", (e3) => {
              this.emit("peer-join", e3);
            }), this.userManager.on("2", (e3) => {
              this.closeDownLinkConnection(e3, "remote user exitRoom"), this.emit("peer-leave", e3);
            }), this.userManager.on("3", this.createDownlinkConnection, this), this.userManager.on("5", this.closeDownLinkConnection, this), this.userManager.on("6", (e3) => {
              var t3 = ((e4, t4) => {
                var i3 = {};
                for (var r2 in e4)
                  YC.call(e4, r2) && t4.indexOf(r2) < 0 && (i3[r2] = e4[r2]);
                if (null != e4 && zC)
                  for (var r2 of zC(e4))
                    t4.indexOf(r2) < 0 && QC.call(e4, r2) && (i3[r2] = e4[r2]);
                return i3;
              })(e3, []);
              ew.emit(gO.REMOTE_PUBLISH_STATE_CHANGED, eb({ room: this }, t3)), this.emit("remote-publish-state-changed", eb({}, t3));
            }), this._joinOptions = e2, new Promise((t3, i3) => cb(this, null, function* () {
              var r2, n2;
              this._joinReject = i3;
              try {
                this.checkDestroy();
                try {
                  yield Promise.all([this.initialize(), this.initSinglePC()]);
                } catch (o2) {
                  if (!(o2 instanceof vb && o2.code === Sb.SPC_INITIALIZED_FAILED))
                    return i3(o2);
                  null == (r2 = this._signalChannel) || r2.destroy(), yield this.initialize();
                }
                yield this.doJoin(e2, null == (n2 = this.singlePC) ? void 0 : n2.clientAbility), t3(), this._firstPublishedList && this.onPublishedUserList({ data: { userList: this._firstPublishedList } });
              } catch (o2) {
                i3(o2);
              }
              this._joinReject = null;
            }));
          });
        }
        initSinglePC() {
          return cb(this, null, function* () {
            if (this.enableSPC && !this.singlePC) {
              this.singlePC = new ZU({ signalChannel: this._signalChannel, room: this, enableCustomMessage: false }), this.singlePC.on("sei-message", (e2) => this.emit("sei-message", e2)), this.singlePC.once("error", () => this.fallbackToMPC());
              try {
                return yield this.singlePC.initialize();
              } catch (wb2) {
                throw this.fallbackToMPC(), new vb({ code: Sb.SPC_INITIALIZED_FAILED, message: null == wb2 ? void 0 : wb2.message });
              }
            }
          });
        }
        doJoin(e2, t2) {
          return new Promise((i2, r2) => cb(this, null, function* () {
            var n2, o2, s2;
            e2.privateMapKey && (this.privateMapKey = e2.privateMapKey), this._signalChannel.once(tV, (e3) => {
              this.clearJoinTimeout(), ew.emit(gO.JOIN_SIGNAL_CONNECTION_END, { room: this, error: e3 }), r2(e3);
            }), Vw(null == (o2 = null == (n2 = this.scheduleResult) ? void 0 : n2.config) ? void 0 : o2.singlePC) && QO && (this.enableSPC = this.scheduleResult.config.singlePC), this.keyPointManager.setConnectionType(this.singlePC ? 1 : 2);
            let a2 = { roomId: String(e2.roomId || e2.strRoomId), useStringRoomId: this.useStringRoomId, privateMapKey: this.privateMapKey, trtcRole: e2.role, trtcScene: "live" === this.scene ? 2 : 1, sdpSemantics: this.sdpSemantics, version: this._version, ua: navigator && navigator.userAgent || "", terminalType: zD(), netType: Iw(), bussinessInfo: this._businessInfo, ability: t2, sdkType: this._sdkType, userSig: this.userSig };
            this._log.debug("join room signal data: ".concat(JSON.stringify(a2)));
            let c2 = 5e3;
            (null == (s2 = this.scheduleResult.config) ? void 0 : s2.enterRoomTimeout) && this.scheduleResult.config.enterRoomTimeout >= 1 && (c2 = 1e3 * this.scheduleResult.config.enterRoomTimeout), this._joinTimeout = window.setTimeout(() => {
              r2(new vb({ code: Sb.JOIN_ROOM_FAILED, message: XD({ key: uN.JOIN_ROOM_TIMEOUT }) }));
            }, c2), ew.emit(gO.JOIN_SEND_CMD, { room: this }), this._signalChannel.send(this.singlePC ? DV : dV, a2), this._signalChannel.once(cV.JOIN_ROOM_RESULT, (e3) => {
              this.clearJoinTimeout();
              let { code: t3, message: n3, data: o3, tinyId: s3 } = e3.data;
              ew.emit(gO.JOIN_RECEIVED_CMD_RES, { room: this, code: t3 }), 0 === t3 ? (this._log.info("Join room success, start heartbeat"), s3 && (this.tinyId = s3), this.startHeartbeat(), this.syncUserList(), this.startSyncUserListInterval(), this._firstPublishedList = o3.publishers, this.singlePC && this.singlePC.connect(o3.ability).catch(() => {
              }), i2()) : (this._log.error("Join room failed result: ".concat(t3, " error: ").concat(n3)), r2(new vb({ code: Sb.JOIN_ROOM_FAILED, extraCode: t3, message: XD({ key: uN.JOIN_ROOM_FAILED, data: { error: n3, code: t3 } }) })));
            });
          }));
        }
        reJoin() {
          let e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
          return cb(this, null, function* () {
            if (this.isJoined)
              try {
                this._log.warn("reJoin pending: ".concat(this._joinOptions.roomId));
                let t2, i2 = [];
                if (this.singlePC && (this.singlePC.close(), this.singlePC = null, i2.push(this.initSinglePC().then((e3) => (t2 = e3, e3)))), this._signalChannel && (this._signalChannel.race = e2, this._signalChannel.close(), i2.push(this._signalChannel.connect())), yield Promise.all(i2), yield this.doJoin(tb(eb({}, this._joinOptions), { role: "anchor" === this.role ? 20 : 21, privateMapKey: this.privateMapKey }), t2), this._log.warn("reJoin success"), iw.logSuccessEvent({ userId: this.userId, eventType: Pk.REJOIN }), this.singlePC) {
                  let e3 = (t3) => {
                    var i3;
                    "CONNECTED" === t3.state && (null == (i3 = this.singlePC) || i3.off(qU.CONNECTION_STATE_CHANGED, e3), this.uplinkConnection instanceof sF && this.uplinkConnection.onSinglePCReconnected(), this.remotePublishedUserMap.forEach((e4) => {
                      e4.installEvents(), e4.onSinglePCReconnected();
                    }));
                  };
                  this.singlePC.on(qU.CONNECTION_STATE_CHANGED, e3), this.checkConnectionsToReconnect(), this.uplinkConnection instanceof rU && !this.uplinkConnection.getIsReconnecting() && this.uplinkConnection.startReconnection();
                }
              } catch (wk2) {
                this._log.warn("reJoin fail ".concat(wk2)), this.reset(), iw.logFailedEvent({ userId: this.userId, eventType: Pk.REJOIN, error: wk2 }), this.emit("error", new vb({ code: Sb.JOIN_ROOM_FAILED, message: XD({ key: uN.REJOIN_ROOM_FAILED, data: { roomId: this._joinOptions.roomId } }) }));
              }
            else
              this._log.warn("reJoin abort");
          });
        }
        initialize() {
          return cb(this, null, function* () {
            let { mainUrl: e2, backupUrl: t2 } = this.getSignalChannelUrl(), i2 = this._signalChannel || function(e3) {
              let t3 = [...FV.values()].find((t4) => t4.room.userId === e3 && !t4.room.isJoined);
              return t3 || null;
            }(this.userId), r2 = !!(i2 && i2.isConnected && i2.keepAlive);
            return this._log.info("".concat(r2 ? "reuse" : "setup", " signal channel")), r2 ? (i2.url = e2, i2.backupUrl = t2, i2.room = this, this._signalChannel = i2) : (this._signalChannel = new BV({ sdkAppId: this.sdkAppId, userId: this.userId, userSig: this.userSig, url: e2, backupUrl: t2, race: this.enableSPC && !this.proxy_ws, room: this }), this._customMessageManager = new hF(this, this._signalChannel), this._customMessageManager.on("message", (e3) => {
              this.emit("custom-message", e3);
            })), this._networkQuality || (this._networkQuality = new aU({ signalChannel: this._signalChannel, room: this }), this._networkQuality.on(aU.EVENT_NETWORK_QUALITY, (e3) => {
              this.emit("network-quality", e3);
            })), bP(this, this._signalChannel).add(iV, (e3) => {
              ew.emit(gO.SIGNAL_CONNECTION_STATE_CHANGED, eb({ room: this }, e3)), this.emit("signal-connection-state-changed", e3);
            }).add(oV, (e3) => {
              this.reset(), this.emit("error", e3);
            }).add(cV.PEER_JOIN, (e3) => {
              let { srcTinyId: t3, userId: i3, role: r3 } = e3.data.data;
              this.userManager.addUser({ userId: i3, tinyId: t3, role: r3 });
            }).add(cV.PEER_LEAVE, (e3) => {
              let { userId: t3, reason: i3 = 0 } = e3.data.data;
              this.userManager.deleteUser(t3, i3);
            }).add(cV.UPDATE_REMOTE_MUTE_STAT, (e3) => {
              this._lastHeartBeatTime > 0 && Date.now() - this._lastHeartBeatTime >= 1e4 && this.doHeartbeat(), this.onPublishedUserList(e3.data);
            }).add(cV.CLIENT_BANNED, (e3) => {
              let t3 = e3.data.data, { reason: i3 } = t3;
              if (iw.uploadEvent({ log: "stat-banned:".concat(i3), userId: this.userId }), "user_time_out" === i3)
                return this._log.warn("".concat(i3, " last heart beat time: ").concat(this._lastHeartBeatTime, " interval: ").concat(Date.now() - this._lastHeartBeatTime, ", visibility: ").concat(document.visibilityState)), void this.reJoin();
              this._log["kick" === i3 ? "error" : "info"]("user was banned because of [".concat(i3, "]")), this.reset(), this.emit("banned", { reason: i3 });
            }), this._signalChannel.once(eV, (e3) => {
              this.tinyId = e3.signalInfo.tinyId, ew.emit(gO.JOIN_SIGNAL_CONNECTION_END, { room: this });
            }), ew.emit(gO.JOIN_SIGNAL_CONNECTION_START, { room: this }), yield this._signalChannel.connect(), r2 && ew.emit(gO.JOIN_SIGNAL_CONNECTION_END, { room: this }), r2;
          });
        }
        setSignalChannel(e2) {
          this._signalChannel = e2, e2 || kP(this);
        }
        leave() {
          return cb(this, null, function* () {
            var e2;
            try {
              yield this.doHeartbeat();
            } catch (wk2) {
            }
            this._log.info("leave() => leaving room"), ew.emit(gO.LEAVE_SEND_CMD, { room: this }), null == (e2 = this._signalChannel) || e2.send(uV);
          });
        }
        clearNetworkQuality() {
          this._networkQuality && (this._networkQuality.stop(), this._networkQuality = null);
        }
        closeConnections() {
          this.remotePublishedUserMap.forEach((e2) => {
            this.closeDownLinkConnection(e2.userId, "you exitRoom");
          });
        }
        clearJoinTimeout() {
          clearTimeout(this._joinTimeout), this._joinTimeout = -1;
        }
        startHeartbeat() {
          -1 === this._heartbeat && (this._heartbeat = yP.run(rN, this.doHeartbeat.bind(this), { delay: 2e3 }));
        }
        stopHeartbeat() {
          -1 !== this._heartbeat && (this._log.info("stopHeartbeat"), yP.clearTask(this._heartbeat), this._heartbeat = -1, this._lastHeartBeatTime = -1);
        }
        doHeartbeat() {
          return cb(this, null, function* () {
            var e2;
            let t2 = this.badCaseDetector.getMonitorFreeze(), i2 = yield this._stats.getStatsReport({ uplinkConnection: this.uplinkConnection, downlinkConnections: this.remotePublishedUserMap, freezeMap: t2 });
            if (this.badCaseDetector.resetMonitor(), null == (e2 = this._signalChannel) || !e2.isConnected)
              return;
            let r2 = this._signalChannel.isConnected ? function(e3) {
              if (LL.has(e3)) {
                let t3 = LL.get(e3).map((e4) => ({ uint32_event_id: e4.eventId, uint64_date: e4.timestamp, str_userid: e4.remoteUserId, str_event_json: e4.eventDesc }));
                return LL.delete(e3), t3;
              }
              return [];
            }(this.userId) : [], n2 = eb({ str_sdk_version: kb, uint64_datetime: (/* @__PURE__ */ new Date()).getTime(), msg_user_info: { str_identifier: this.userId, uint64_tinyid: this.tinyId }, msg_device_info: { uint32_terminal_type: 15, str_device_name: navigator.platform, str_os_version: "", uint32_net_type: Iw() }, msg_event_msg: r2, str_acc_ip: this.getSignalInfo().relayIp, str_client_ip: this.getSignalInfo().clientIp }, i2);
            ew.emit(gO.HEARTBEAT_REPORT, { room: this, report: n2 }), this._signalChannel.send(hV, n2), this.emit("heartbeat-report", tb(eb({}, n2), { bytes_sent: this._stats.totalBytesSent + this._signalChannel.bytesSent, bytes_received: this._stats.totalBytesReceived + this._signalChannel.bytesReceived }));
            let o2 = Date.now();
            this._lastHeartBeatTime > 0 && o2 - this._lastHeartBeatTime > 1e4 && this._log.warn("heartbeat took ".concat(o2 - this._lastHeartBeatTime)), this._signalChannel.isConnected && (this._lastHeartBeatTime = o2), !this._isRelayChanged && this.isRelayMaybeFailed() && (this.reJoin(), this._isRelayChanged = true);
          });
        }
        onPublishedUserList(e2) {
          if (!this.isJoined)
            return;
          let t2 = e2.data.userList.map((e3) => {
            let { userId: t3, srcTinyId: i2, flag: r2 } = e3;
            t3 === this.userId && this.uplinkConnection && (this.uplinkConnection.flag = r2);
            let n2 = this.remotePublishedUserMap.get(t3);
            return n2 && this.checkSubscribeBigSmallVideo(n2), { userId: t3, tinyId: i2, flag: r2 };
          });
          ew.emit(gO.RECEIVED_PUBLISHED_USER_LIST, { room: this, publishedUserList: t2 }), this.userManager.setRemotePublishedUserList(t2);
        }
        closeUplink() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "you unpublished";
          this.uplinkConnection && (this.localTracks.size > 0 && this.uplinkConnection.doUnpublish(), this.uplinkConnection.close(e2), this.uplinkConnection = null), this.localTracks.forEach((e3) => e3.unpublish()), this.localTracks.clear();
        }
        createDownlinkConnection(e2) {
          let { userId: t2, tinyId: i2, flag: r2 } = e2, n2 = new (this.singlePC ? lF : ZV)({ userId: t2, tinyId: i2, room: this, signalChannel: this._signalChannel, enableSEI: this.enableSEI, flag: r2 });
          this.userManager.addRemotePublishedUser(n2), this.installDownlinkEvents(n2, t2), this.emit("remote-published", n2);
        }
        closeDownLinkConnection(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "remote user unpublished", i2 = this.remotePublishedUserMap.get(e2);
          i2 && (i2.close(t2), this.emit("remote-unpublished", i2));
        }
        installDownlinkEvents(e2, t2) {
          e2.on("error", (e3) => {
            let i2 = e3.getCode();
            i2 !== Sb.ICE_TRANSPORT_ERROR && (i2 === Sb.DOWNLINK_RECONNECTION_FAILED && this.closeDownLinkConnection(t2), this.emit("error", e3));
          }), e2.on("connection-state-changed", (t3) => {
            this.emit("media-connection-state-changed", tb(eb({}, t3), { userId: e2.userId }));
          }), e2.on("firewall-restriction", () => {
            this.emit("firewall-restriction");
          });
        }
        startSyncUserListInterval() {
          -1 === this._syncUserListInterval && (this._syncUserListInterval = yP.run(rN, this.syncUserList.bind(this)));
        }
        stopSyncUserListInterval() {
          yP.clearTask(this._syncUserListInterval), this._syncUserListInterval = -1;
        }
        syncUserList() {
          return this.getUserList().then((e2) => {
            this.userManager.setUserList(e2);
          }).catch((e2) => {
            this._log.debug("sync user list failed: ".concat(e2));
          });
        }
        getUserList() {
          var e2;
          return null != (e2 = this._signalChannel) && e2.isConnected ? this._signalChannel.sendWaitForResponse({ command: CV, responseCommand: cV.USER_LIST_RES, enableLog: false, timeout: 2e3 }).then((e3) => {
            let { data: t2 } = e3, { code: i2, message: r2 } = t2;
            if (0 === i2)
              return (t2.data && t2.data.userList || []).map((e4) => {
                let { userId: t3, srcTinyId: i3, role: r3 } = e4;
                return { userId: t3, tinyId: i3, role: r3 };
              });
            throw XD({ key: uN.SIGNAL_RESPONSE_FAILED, data: { signalResponse: cV.USER_LIST_RES, code: i2, message: r2 } });
          }) : Promise.reject("not connected");
        }
        getAllConnections() {
          let e2 = [...this.remotePublishedUserMap.values()];
          return this.uplinkConnection && e2.push(this.uplinkConnection), e2;
        }
        isRelayMaybeFailed() {
          if (this._signalChannel && !this._signalChannel.isOnline || !JV)
            return false;
          if (this.singlePC)
            return this.singlePC.reconnectionCount > 6;
          let e2 = this.getAllConnections();
          if (0 === e2.length)
            return false;
          for (let t2 = 0; t2 < e2.length; t2++)
            if (e2[t2].getReconnectionCount() < 6)
              return false;
          return true;
        }
        checkConnectionsToReconnect() {
          var e2;
          this.singlePC ? (null == (e2 = this.singlePC.getPeerConnection()) ? void 0 : e2.connectionState) === bk.CLOSED && !this.singlePC.isReconnecting && (this._log.warn("spc pc is closed but not reconnect"), this.singlePC.startReconnection()) : this.getAllConnections().forEach((e3) => {
            if (e3 instanceof KV && !e3.getIsReconnecting()) {
              let t2 = e3.getPeerConnection();
              t2 && t2.connectionState === bk.CLOSED && (this._log.warn("[".concat(e3.getUserId(), "] pc is closed but not reconnect")), e3.startReconnection());
            }
          });
        }
        fallbackToMPC() {
          return cb(this, null, function* () {
            var e2;
            if (this._log.warn("fallback to multi pc"), iw.uploadEvent({ log: "stat-fallback", userId: this.userId }), this.enableSPC = false, null == (e2 = this.singlePC) || e2.close(), this.singlePC = null, this.isJoined && (yield this.reJoin(false)), this.uplinkConnection) {
              let e3 = this.uplinkConnection;
              this.uplinkConnection = new rU({ userId: this.userId, tinyId: this.tinyId, room: this, signalChannel: this._signalChannel, enableSEI: this.enableSEI, audioManager: this.audioManager }), e3.isMainStreamPublished && (yield this.uplinkConnection.publish({ localAudioTrack: e3.localMainAudioTrack, localVideoTrack: e3.localMainVideoTrack, isAuxiliary: false })), e3.isAuxStreamPublished && (yield this.uplinkConnection.publish({ localAudioTrack: e3.localAuxAudioTrack, localVideoTrack: e3.localAuxVideoTrack, isAuxiliary: true })), e3.close();
            }
            this.remotePublishedUserMap.forEach((e3) => {
              let t2 = new ZV({ userId: e3.userId, tinyId: e3.tinyId, room: this, signalChannel: this._signalChannel, enableSEI: this.enableSEI, flag: e3.flag, remoteAudioTrack: e3.remoteAudioTrack, remoteVideoTrack: e3.remoteVideoTrack, remoteAuxiliaryTrack: e3.remoteAuxiliaryTrack });
              this.installDownlinkEvents(t2, e3.userId), this.remotePublishedUserMap.set(e3.userId, t2), e3.isMainStreamSubscribed && t2.subscribe(e3.subscribeState, "main"), e3.isAuxStreamSubscribed && t2.subscribe(e3.subscribeState, "auxiliary");
            });
          });
        }
        destroy() {
          this.isDestroyed || (this._signalChannel && (this._log.info("destroying SignalChannel"), this._signalChannel.close(), this._signalChannel = null), super.destroy(), this._joinReject && (this._joinReject(new vb({ code: Sb.INVALID_OPERATION, message: XD({ key: uN.CLIENT_DESTROYED, data: { funName: "join" } }) })), this.clearJoinTimeout(), this.reset()), this.removeAllListeners());
        }
        switchRole(e2) {
          return cb(this, null, function* () {
            this.role !== e2 && ("audience" === e2 && this.uplinkConnection && this.closeUplink("you switch role to audience"), yield this.doSwitchRole(e2));
          });
        }
        doSwitchRole(e2) {
          let t2 = { command: bV, data: { role: "anchor" === e2 ? 20 : 21, privateMapKey: this.privateMapKey }, responseCommand: cV.SWITCH_ROLE_RES, retries: 1 };
          return this._log.info("switchRole signal data: ".concat(JSON.stringify(t2.data))), this._signalChannel.sendWaitForResponseWithRetry(t2).then((t3) => {
            let { code: i2, message: r2 } = t3.data;
            if (0 !== i2)
              throw new vb({ code: Sb.SWITCH_ROLE_FAILED, message: XD({ key: uN.SWITCH_ROLE_FAILED, data: { message: r2, code: i2 } }) });
            this.role = e2;
          }).catch((e3) => {
            throw e3 instanceof vb && e3.getCode() === Sb.API_CALL_TIMEOUT && (e3 = new vb({ code: Sb.SWITCH_ROLE_FAILED, message: XD({ key: uN.SWITCH_ROLE_TIMEOUT }) })), this._log.error(e3), e3;
          });
        }
        publish() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          return cb(this, null, function* () {
            let e3 = {}, i3 = {};
            t2.forEach((t3) => {
              t3 instanceof cL && (t3 instanceof mL ? i3.audio = t3 : e3.audio = t3), t3 instanceof lL && (t3 instanceof pL && 2 === t3.mediaType ? i3.video = t3 : e3.video = t3);
            });
            let r2 = gF(e3), n2 = gF(i3);
            (!r2 || !n2) && !this.uplinkConnection && (this.singlePC ? this.uplinkConnection = new sF({ userId: this.userId, tinyId: this.tinyId, room: this, signalChannel: this._signalChannel, enableSEI: this.enableSEI, audioManager: this.audioManager }) : this.uplinkConnection = new rU({ userId: this.userId, tinyId: this.tinyId, room: this, signalChannel: this._signalChannel, enableSEI: this.enableSEI, audioManager: this.audioManager }), this.uplinkConnection.on("connection-state-changed", (e4) => {
              this.emit("media-connection-state-changed", tb(eb({}, e4), { userId: this.userId }));
            }), this.uplinkConnection.on("firewall-restriction", () => {
              this.emit("firewall-restriction");
            }), this.uplinkConnection.on("error", (e4) => {
              let t3 = e4.getCode();
              t3 !== Sb.ICE_TRANSPORT_ERROR && (t3 === Sb.UPLINK_RECONNECTION_FAILED && this.closeUplink(), this.emit("error", e4));
            }));
            let o2 = t2.map((e4) => e4.kind).join(",");
            r2 || (this._log.info("publish() => main ".concat(o2)), yield this.uplinkConnection.publish({ localAudioTrack: e3.audio, localVideoTrack: e3.video, isAuxiliary: false }), this._log.info("main is published")), n2 || (this._log.info("publish() => aux ".concat(o2)), yield this.uplinkConnection.publish({ localAudioTrack: i3.audio, localVideoTrack: i3.video, isAuxiliary: true }), this._log.info("aux is published"));
          });
        }
        unpublish() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          return cb(this, null, function* () {
            if ("live" === this.scene && "anchor" !== this.role || !this.isMainStreamPublished && !this.isAuxStreamPublished || !this.uplinkConnection)
              return;
            let e3 = {}, i3 = {};
            t2.forEach((t3) => {
              !t3.mediaTrack || !t3.isPublished || (t3 instanceof cL && (t3 instanceof mL ? i3.audio = t3 : e3.audio = t3), t3 instanceof lL && (t3 instanceof pL && 2 === t3.mediaType ? i3.video = t3 : e3.video = t3));
            });
            try {
              let r2 = t2.map((e4) => e4.kind).join(",");
              gF(e3) || (this._log.info("unpublish() => main ".concat(r2)), yield this.uplinkConnection.unpublish({ localAudioTrack: e3.audio, localVideoTrack: e3.video })), gF(i3) || (this._log.info("unpublish() => aux ".concat(r2)), yield this.uplinkConnection.unpublish({ localAudioTrack: i3.audio, localVideoTrack: i3.video }));
            } catch (tM2) {
            }
            0 === this.localTracks.size && this.closeUplink("you unpublished");
          });
        }
        addTrack(e2) {
          if (!this.uplinkConnection || !e2.mediaTrack)
            return Promise.resolve();
          let t2 = this.uplinkConnection.addTrack(e2);
          return e2.publish(this, t2), t2;
        }
        removeTrack(e2) {
          return this.uplinkConnection && e2.mediaTrack ? this.uplinkConnection.removeTrack(e2).then((t2) => (e2.unpublish(), t2)) : Promise.resolve();
        }
        replaceTrack(e2) {
          return this.uplinkConnection && e2.mediaTrack && $O() ? this.uplinkConnection.replaceTrack(e2).then((t2) => {
            ew.emit(gO.LOCAL_TRACK_REPLACED, { track: e2 });
          }) : Promise.resolve();
        }
        setBandWidth(e2) {
          return cb(this, null, function* () {
            !this.uplinkConnection || (yield this.uplinkConnection.setBandwidth(e2), yield this.uplinkConnection.sendMediaSettings());
          });
        }
        enableSmall(e2) {
          return cb(this, null, function* () {
            if (!this.uplinkConnection || !this.uplinkConnection.localMainVideoTrack)
              return Promise.resolve();
            e2 && this.uplinkConnection.localMainVideoTrack.small && (yield this.setBandWidth({ type: ok.VIDEO, videoType: ok.SMALL, bandwidth: this.uplinkConnection.localMainVideoTrack.small.bitrate })), yield this.uplinkConnection.enableSmall(e2);
          });
        }
        subscribe() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          return cb(this, null, function* () {
            if (t2 = t2.filter((e4) => !e4.isSubscribed), 0 === t2.length)
              return;
            let { userId: e3 } = t2[0], i3 = this.remotePublishedUserMap.get(e3);
            if (!i3)
              return;
            let r2 = t2.find((e4) => 2 === e4.mediaType) ? "auxiliary" : "main";
            try {
              let n2 = eb({}, i3.subscribeState);
              t2.forEach((e4) => {
                switch (e4.mediaType) {
                  case 1:
                    n2.audio = true;
                    break;
                  case 4:
                    n2.video = true;
                    break;
                  case 8:
                    n2.smallVideo = true;
                    break;
                  case 2:
                    n2.auxiliary = true;
                }
              });
              let o2 = this._changeBigSmallRecords.get(e3);
              o2 && o2.options.smallVideo && i3.muteState.hasSmall && n2.video && (n2.video = false, n2.smallVideo = true), ew.emit(gO.SUBSCRIBE_START, { room: this, streamType: r2, remotePublishedUser: i3, subscribeState: n2 }), this._log.info("subscribe() => ".concat(e3, " ").concat(r2, " [").concat(QV(n2), "] prev: [").concat(QV(i3.subscribeState), "]")), yield i3.subscribe(n2, r2), this._log.info("subscribe ".concat(e3, " ").concat(r2, " done"));
              for (let e4 of t2)
                e4.mediaTrack || (yield e4.waitHasMediaTrack());
              ew.emit(gO.SUBSCRIBE_SUCCESS, { room: this, streamType: r2, remotePublishedUser: i3 });
            } catch (Pb2) {
              let i4 = Pb2 instanceof vb ? Pb2.getCode() : Sb.UNKNOWN, n2 = Pb2;
              throw Pb2 instanceof vb ? i4 === Sb.REMOTE_STREAM_NOT_EXIST && (n2 = new vb({ code: Sb.API_CALL_ABORTED, message: XD({ key: uN.API_CALL_ABORTED, data: { message: Pb2.message, userId: e3, streamType: r2 } }) }), this._log.warn(n2)) : (n2 = new vb({ code: i4, message: XD({ key: uN.SUBSCRIBE_FAILED, data: { message: Pb2.message, userId: e3, streamType: r2 } }) }), this._log.error(n2)), n2;
            }
          });
        }
        unsubscribe() {
          for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
            t2[i2] = arguments[i2];
          return cb(this, null, function* () {
            let { userId: e3 } = t2[0], i3 = this.remotePublishedUserMap.get(e3);
            if (!i3)
              return;
            let r2 = t2.find((e4) => 2 === e4.mediaType) ? "auxiliary" : "main";
            this._log.info("unsubscribe() => ".concat(e3, " ").concat(r2));
            try {
              yield i3.unsubscribe({ remoteTracks: t2, streamType: r2 });
            } catch (Pb2) {
              this._log.warn("unsubscribe() => failed ".concat(Pb2));
            }
            t2.forEach((e4) => {
              e4.unsubscribe(), 8 === e4.mediaType && e4.setMediaType(4);
            }), ew.emit(gO.UNSUBSCRIBE_SUCCESS, { room: this, streamType: r2, remotePublishedUser: i3 });
          });
        }
        setEncodedDataProcessingListener(e2) {
          throw new Error("Method not implemented.");
        }
        enableAudioVolumeEvaluation() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2e3, t2 = arguments.length > 1 ? arguments[1] : void 0;
          if (e2 <= 0)
            return this._enableAudioVolumeEvaluation = false, void yP.clearTask(this._audioVolumeIntervalId);
          e2 = Math.floor(Math.max(e2, 100)), ew.emit(gO.AUDIO_LEVEL_INTERVAL, { interval: e2 }), this._audioVolumeIntervalId && yP.clearTask(this._audioVolumeIntervalId), this._enableAudioVolumeEvaluation = true, this._audioVolumeIntervalId = yP.run(nN, () => {
            var e3;
            let t3 = [];
            null == (e3 = this.remotePublishedUserMap) || e3.forEach((e4) => {
              if (e4.muteState.hasAudio) {
                let i2 = Math.floor(100 * e4.remoteAudioTrack.getAudioLevel());
                t3.push({ userId: e4.userId, volume: i2 });
              }
            }), this.emit("audio-volume", t3);
          }, { fps: 1e3 / e2, backgroundTask: t2 });
        }
        getLocalAudioStats() {
          return cb(this, null, function* () {
            let e2 = {};
            if (e2[this.userId] = { bytesSent: 0, packetsSent: 0 }, this.uplinkConnection) {
              let t2 = yield this._stats.getSenderStats(this.uplinkConnection);
              e2[this.userId] = { bytesSent: t2.audio.bytesSent, packetsSent: t2.audio.packetsSent };
            }
            return e2;
          });
        }
        getLocalVideoStats() {
          return cb(this, null, function* () {
            let e2 = {};
            if (e2[this.userId] = { bytesSent: 0, packetsSent: 0, framesEncoded: 0, framesSent: 0, frameWidth: 0, frameHeight: 0 }, this.uplinkConnection) {
              let { video: { bytesSent: t2, packetsSent: i2, framesEncoded: r2, framesSent: n2, frameWidth: o2, frameHeight: s2 } } = yield this._stats.getSenderStats(this.uplinkConnection);
              e2[this.userId] = { bytesSent: t2, packetsSent: i2, framesEncoded: r2, framesSent: n2, frameWidth: o2, frameHeight: s2 };
            }
            return e2;
          });
        }
        getTransportStats() {
          return cb(this, null, function* () {
            let e2 = { rtt: 0, downlinksRTT: {} };
            if (this.uplinkConnection) {
              let t2 = yield this._stats.getSenderStats(this.uplinkConnection);
              e2.rtt = t2.rtt;
            }
            for (let [, t2] of this.remotePublishedUserMap) {
              let i2 = yield this._stats.getReceiverStats(t2);
              e2.downlinksRTT[i2.userId] = i2.rtt;
            }
            return e2;
          });
        }
        getRemoteVideoStats(e2) {
          return cb(this, null, function* () {
            let t2 = {};
            for (let [i2, r2] of this.remotePublishedUserMap)
              "main" === e2 && r2.muteState.hasVideo && (t2[i2] = r2.remoteVideoTrack.stat), "auxiliary" === e2 && r2.muteState.hasAuxiliary && (t2[i2] = r2.remoteAuxiliaryTrack.stat);
            return t2;
          });
        }
        getRemoteAudioStats() {
          return cb(this, null, function* () {
            let e2 = {};
            for (let [t2, i2] of this.remotePublishedUserMap)
              i2.muteState.hasAudio && (e2[t2] = i2.remoteAudioTrack.stat);
            return e2;
          });
        }
        setTurnServer(e2, t2) {
          this._log.info("set turn server: ".concat(JSON.stringify(e2), " ").concat(t2 || ""));
          let i2 = [];
          Array.isArray(e2) ? e2.forEach((e3) => i2.push(Cb.getTurnServer(e3))) : Cb.isPlainObject(e2) && i2.push(Cb.getTurnServer(e2)), this._turnServers = i2, t2 && (this._iceTransportPolicy = t2);
        }
        sendStartMixTranscode(e2) {
          return this._signalChannel.sendWaitForResponse({ command: AV, data: e2, timeout: 5e3, responseCommand: cV.START_MIX_TRANSCODE_RES, commandDesc: "startMixTranscode" });
        }
        sendStopMixTranscode(e2) {
          return this._signalChannel.sendWaitForResponse({ command: RV, data: e2, timeout: 5e3, responseCommand: cV.STOP_MIX_TRANSCODE_RES, commandDesc: "stopMixTranscode" });
        }
        sendStartPublishCDN(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          return this._signalChannel.sendWaitForResponse({ command: t2 ? SV : vV, data: e2, timeout: 5e3, responseCommand: t2 ? cV.START_PUBLISH_TENCENT_CDN_RES : cV.START_PUBLISH_GIVEN_CDN_RES, commandDesc: "startPublishCDN" });
        }
        sendStopPublishCDN(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          return this._signalChannel.sendWaitForResponse({ command: t2 ? IV : yV, data: e2, timeout: 5e3, responseCommand: t2 ? cV.STOP_PUBLISH_TENCENT_CDN_RES : cV.STOP_PUBLISH_GIVEN_CDN_RES, commandDesc: "stopPublishCDN" });
        }
        sendAbilityStatus(e2) {
          var t2;
          null == (t2 = this._signalChannel) || t2.sendWaitForResponse({ command: PV, data: e2, timeout: 5e3, responseCommand: cV.ABILITY_STATUS_REPORT_RESULT, commandDesc: "ability status report" }).catch((e3) => {
          });
        }
        getIceServers() {
          return 0 === this._turnServers.length && this.scheduleResult.iceServers ? this.scheduleResult.iceServers : this._turnServers;
        }
        getIceTransportPolicy() {
          return this._iceTransportPolicy || this.scheduleResult.iceTransportPolicy || "all";
        }
        getLogger() {
          return this._log;
        }
        enableAIVoice() {
          throw new Error("Method not implemented.");
        }
        getSignalChannelUrl() {
          let e2 = { mainUrl: "", backupUrl: "" }, t2 = Cb.getEnv();
          return t2 ? (e2.mainUrl = "wss://".concat(t2, ".rtc.qq.com"), e2.backupUrl = e2.mainUrl) : this.proxy_ws ? (e2.mainUrl = this.proxy_ws, e2.backupUrl = e2.mainUrl) : Array.isArray(this.scheduleResult.domains) && this.scheduleResult.domains.length > 0 && (e2.mainUrl = "wss://".concat(this.scheduleResult.domains[0]), e2.backupUrl = e2.mainUrl, this.scheduleResult.domains[1] && (e2.backupUrl = "wss://".concat(this.scheduleResult.domains[1]))), e2;
        }
        getSignalInfo() {
          var e2;
          return (null == (e2 = this._signalChannel) ? void 0 : e2.getSignalInfo()) || { clientIp: "", relayIp: "" };
        }
        reset() {
          let e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
          this.stopSyncUserListInterval(), this.stopHeartbeat(), this.closeConnections(), this.clearNetworkQuality(), this.closeUplink("you exitRoom"), this._signalChannel && (e2 && this._signalChannel.keepAlive && this._signalChannel.isConnected ? this._signalChannel.stopKeepAliveIn(3600) : this._signalChannel.close(), this.setSignalChannel(null)), this._stats.reset(), this.userManager.clear(), this.userManager.removeAllListeners(), this.singlePC && (this.singlePC.close(), this.singlePC = null), this.scheduleResult = { domains: null, iceServers: null, iceTransportPolicy: null, trtcAutoConf: null };
        }
        checkSubscribeBigSmallVideo(e2) {
          return cb(this, null, function* () {
            let { subscribeState: t2, userId: i2, muteState: { hasSmall: r2, hasVideo: n2 } } = e2;
            if (!r2 && !n2 || !t2.video && !t2.smallVideo)
              return;
            let o2 = this._changeBigSmallRecords.get(i2);
            if (!o2 || o2.isSubscribing || o2.reSubscribeCount <= 0)
              return;
            let { options: s2, reSubscribeCount: a2 } = o2;
            if (s2.video && t2.video || s2.smallVideo && t2.smallVideo && r2)
              return;
            let c2 = { audio: e2.remoteAudioTrack.isSubscribed || e2.remoteAudioTrack.isSubscribing, auxiliary: e2.remoteAuxiliaryTrack.isSubscribed || e2.remoteAuxiliaryTrack.isSubscribing, video: s2.video, smallVideo: s2.smallVideo };
            try {
              if (!r2 && c2.smallVideo && (c2.video = true, c2.smallVideo = false), c2.smallVideo === t2.smallVideo && c2.video === t2.video)
                return;
              o2.isSubscribing = true, o2.reSubscribeCount = a2 - 1, yield e2.subscribe(c2, "main"), e2.remoteVideoTrack.setMediaType(c2.smallVideo ? 8 : 4), this._log.info("change [".concat(i2, "] to ").concat(c2.smallVideo ? "small" : "big", " video successfully. count ").concat(tN - o2.reSubscribeCount, ".")), o2.isSubscribing = false, o2.reSubscribeCount = tN;
            } catch (l2) {
              this._log.info("change [".concat(i2, "] to ").concat(c2.smallVideo ? "small" : "big", " video failed. count ").concat(tN - o2.reSubscribeCount, ".")), o2.isSubscribing = false, 0 === o2.reSubscribeCount && this._changeBigSmallRecords.delete(i2);
            }
          });
        }
        changeType(e2, t2) {
          let i2 = { options: { video: !e2, smallVideo: e2 }, isSubscribing: false, reSubscribeCount: tN };
          this._changeBigSmallRecords.set(t2.userId, i2), this._log.info("set [".concat(t2.userId, "] video prefer type: ").concat(e2 ? "small" : "big"));
        }
        get smallStreamConfig() {
          return this._smallStreamConfig;
        }
        _initBusinessInfo(e2) {
          this._businessInfo = e2.businessInfo;
          let t2 = {};
          if (mF(e2.businessInfo) && (t2 = JSON.parse(e2.businessInfo)), !_F(e2.pureAudioPushMode)) {
            if (!Number.isInteger(Number(e2.pureAudioPushMode)))
              throw new vb({ code: Sb.INVALID_PARAMETER, message: XD({ key: uN.INVALID_PURE_AUDIO }) });
            this._pureAudioPushMode = e2.pureAudioPushMode, t2.Str_uc_params || (t2.Str_uc_params = {}), t2.Str_uc_params.pure_audio_push_mod = this._pureAudioPushMode;
          }
          if (!_F(e2.userDefineRecordId)) {
            let i2 = /^[A-Za-z0-9_-]{1,64}$/gi;
            if (null === e2.userDefineRecordId.match(i2))
              throw new vb({ code: Sb.INVALID_PARAMETER, message: XD({ key: uN.INVALID_USER_DEFINE_RECORDID }) });
            t2.Str_uc_params || (t2.Str_uc_params = {}), t2.Str_uc_params.userdefine_record_id = e2.userDefineRecordId;
          }
          if (!_F(e2.userDefinePushArgs)) {
            if (!(mF(e2.userDefinePushArgs) && String(e2.userDefinePushArgs) && String(e2.userDefinePushArgs).length <= 256))
              throw new vb({ code: Sb.INVALID_PARAMETER, message: XD({ key: uN.INVALID_USER_DEFINE_PUSH_ARGS }) });
            t2.Str_uc_params || (t2.Str_uc_params = {}), t2.Str_uc_params.userdefine_push_args = e2.userDefinePushArgs;
          }
          gF(t2) || (this._businessInfo = JSON.stringify(t2));
        }
        sendSEI(e2, t2) {
          this.singlePC && this.singlePC.sendSEI(e2, t2);
        }
        sendCustomMessage(e2) {
          var t2;
          null == (t2 = this._customMessageManager) || t2.send(e2);
        }
      };
      return ob([Yx(["left", $x.INIT], "joined"), VV({ settings: { retries: 1, timeout: 0 }, onError(e2, t2, i2) {
        this._isUsingCachedSchedule && !this.isDestroyed ? (this._log.warn("is using cached schedule, retry join"), ow(true), this.reset(), t2()) : this._signalChannel && this._signalChannel.isConnected && this._signalChannel.keepAlive ? (this._log.warn("is using keepAlive ws, retry join"), this._signalChannel.close(), this.reset(), t2()) : (this.reset(), this._log.error(e2), i2(e2));
      } }), XM((e2) => {
        let t2 = new Hx();
        return function(i2, r2, n2) {
          return cb(this, null, function* () {
            let o2 = String(i2.roomId || i2.strRoomId);
            if (this.userId = i2.userId, this.sdkAppId = i2.sdkAppId, this.userSig = i2.userSig, this._log.setSdkAppId(this.sdkAppId), this._log.setUserId(this.userId), this.scene = r2, i2.privateMapKey = i2.privateMapKey || "", this.isJoined)
              throw new vb({ code: Sb.INVALID_OPERATION, message: XD({ key: uN.INVALID_JOIN }) });
            if (this.checkDestroy(), t2.isJoined({ userId: this.userId, roomId: o2, sdkAppId: this.sdkAppId, room: this }))
              throw new vb({ code: Sb.INVALID_OPERATION, message: XD({ key: uN.REPEAT_JOIN, data: this.userId }) });
            t2.add({ room: this, roomId: o2 }), this.role = 21 === i2.role ? "audience" : "anchor", this._log.info("Join() => joining room: ".concat(o2, " useStringRoomId: ").concat(this.useStringRoomId, " scene: ").concat(this.scene, " role: ").concat(this.role)), ew.emit(gO.JOIN_START, { room: this, roomId: o2, params: i2 }), this.checkSystemResult = yield vO.checkSystemRequirementsInternal(), this.checkDestroy();
            let s2 = Cb.getEnv();
            s2 || (s2 = Yb.QCLOUD, this.proxy_ws && (this.proxy_ws.startsWith(ak.OLD_CLOUD_LADDER) ? s2 = Yb.OLD_CLOUD_LADDER : this.proxy_ws.startsWith(ak.WEBRTC) && (s2 = Yb.WEBRTC))), iw.setConfig({ env: s2, sdkAppId: String(this.sdkAppId), userId: this.userId, roomId: o2 }), jx.call(this);
            let { isH264EncodeSupported: a2, isVp8EncodeSupported: c2 } = this.checkSystemResult.detail;
            if (!vO.isWebRTCSupported() || !a2 && !c2)
              throw new vb({ code: Sb.NOT_SUPPORTED, message: XD({ key: uN.NOT_SUPPORTED_WEBRTC }) });
            try {
              !this.proxy_ws && !this.proxy_wt && !this.scheduleResult.domains && !Cb.getEnv() && (yield this.schedule(o2, n2));
              let t3 = yield e2.call(this, i2, r2, n2);
              return this.roomId = o2, this._joinedTimestamp = Cb.performanceNow(), ew.emit(gO.JOIN_SUCCESS, { room: this }), iw.uploadEvent({ log: "stat-conv-".concat(Number(UD), "-").concat(location.hostname), userId: this.userId }), t3;
            } catch (l2) {
              throw t2.delete({ room: this, roomId: o2 }), ew.emit(gO.JOIN_FAILED, { room: this, error: l2 }), l2;
            }
          });
        };
      })], TF.prototype, "join", 1), ob([Yx("joined", "left", { ignoreError: true, success() {
        this.reset(true);
      } }), XM((e2) => function() {
        return cb(this, null, function* () {
          ew.emit(gO.LEAVE_START, { room: this }), yield e2.call(this), ew.emit(gO.LEAVE_SUCCESS, { room: this, roomId: this.roomId });
        });
      }), nL("leave room"), UV({ fnName: "publish", validateArgs: false }), UV({ fnName: "unsubscribe", validateArgs: false })], TF.prototype, "leave", 1), ob([rL(), XM((e2) => function() {
        for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
          i2[r2] = arguments[r2];
        return cb(this, null, function* () {
          if ("live" === this.scene && "anchor" !== this.role || (i2 = i2.filter((e3) => e3.outMediaTrack && "capture" === e3.state), !i2.length))
            return;
          ew.emit("61", { room: this });
          let t3 = e2.apply(this, i2);
          return i2.forEach((e3) => e3.publish(this, t3)), t3;
        });
      }), VV({ settings: { retries: Dk, timeout: (e2) => ww(e2) }, onError(e2, t2, i2) {
        var r2;
        null != (r2 = e2.message) && r2.includes("timeout") ? (this._log.warn("publish timeout"), t2()) : (this._log.error("publish failed: ".concat(e2)), i2(e2), ew.emit(gO.PUBLISH_FAILED, { room: this }));
      } })], TF.prototype, "publish", 1), ob([UV({ fnName: "publish" }), (pF = "api-call", function(e2, t2, i2) {
        let r2 = i2.value;
        return i2.value = function() {
          for (var e3 = arguments.length, t3 = new Array(e3), i3 = 0; i3 < e3; i3++)
            t3[i3] = arguments[i3];
          let n2 = tL.get(this);
          if (n2) {
            let e4 = n2.queue.filter((e5, i4) => {
              if (0 === i4)
                return true;
              let r3 = true;
              return e5.args.forEach((e6) => {
                t3.find((t4) => t4 === e6) || (r3 = false);
              }), !r3 || (e5.reject(new vb({ code: Sb.API_CALL_ABORTED, message: pF })), false);
            });
            n2.queue = e4;
          }
          return r2.apply(this, t3);
        }, i2;
      }), rL(), XM((e2) => function() {
        for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
          i2[r2] = arguments[r2];
        let n2 = e2.apply(this, i2);
        return i2.forEach((e3) => e3.unpublish()), n2;
      })], TF.prototype, "unpublish", 1), ob([oL(function() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
          t2[i2] = arguments[i2];
        return t2[0].userId;
      }), fL(), XM((e2) => function() {
        for (var t2 = arguments.length, i2 = new Array(t2), r2 = 0; r2 < t2; r2++)
          i2[r2] = arguments[r2];
        let n2 = e2.apply(this, i2);
        return i2.forEach((e3) => !e3.isSubscribed && e3.subscribe(n2)), n2;
      }), VV({ settings: { retries: Dk, timeout: (e2) => ww(e2) }, onError(e2, t2, i2, r2) {
        e2.message.includes("timeout") ? (this._log.warn("subscribe timeout"), t2()) : (this._log.error("subscribe failed: ".concat(e2)), i2(e2), ew.emit(gO.SUBSCRIBE_FAILED, { room: this, remoteTracks: r2 }));
      } })], TF.prototype, "subscribe", 1), ob([UV({ fnName: "subscribe", callback() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
          t2[i2] = arguments[i2];
        this.singlePC || t2.forEach((e3) => {
          let t3 = this.remotePublishedUserMap.get(e3.userId);
          t3 && !t3.isMainStreamSubscribed && !t3.isAuxStreamSubscribed && t3.close("you unsubscribed");
        });
      } }), oL(function() {
        for (var e2 = arguments.length, t2 = new Array(e2), i2 = 0; i2 < e2; i2++)
          t2[i2] = arguments[i2];
        return t2[0].userId;
      })], TF.prototype, "unsubscribe", 1), Bx.create = Bx._create.bind(Bx, TF), Bx;
    });
  }
});
export default require_trtc();
//# sourceMappingURL=trtc-sdk-v5.js.map
